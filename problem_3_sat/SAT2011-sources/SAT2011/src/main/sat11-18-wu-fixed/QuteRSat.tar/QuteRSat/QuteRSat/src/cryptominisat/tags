!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.6	//
ALLOC_GROW_MULT	ClauseAllocator.cpp	41;"	d	file:
Alg_h	Alg.h	21;"	d
BINARY_TO_XOR_APPROX	constants.h	35;"	d
BITARRAY_H	BitArray.h	19;"	d
BIT_MORE_VERBOSITY	Subsumer.cpp	30;"	d	file:
BIT_MORE_VERBOSITY	XorSubsumer.cpp	24;"	d	file:
BOUNDEDQUEUE_H	BoundedQueue.h	11;"	d
BURST_SEARCH	constants.h	45;"	d
BasicHeap	BasicHeap.h	/^    BasicHeap(const C& c) : comp(c) { }$/;"	f	class:BasicHeap
BasicHeap	BasicHeap.h	/^class BasicHeap {$/;"	c
BasicHeap_h	BasicHeap.h	21;"	d
BinPropData	SolverTypes.h	/^struct BinPropData {$/;"	s
BinSorter	Subsumer.h	/^    struct BinSorter {$/;"	s	class:Subsumer
BinSorter2	Subsumer.h	/^    struct BinSorter2 {$/;"	s	class:Subsumer
BinXorToAdd	FailedLitSearcher.h	/^                BinXorToAdd(const Lit _lit1, const Lit _lit2, const bool _isEqualFalse, const uint32_t _group) :$/;"	f	class:FailedLitSearcher::BinXorToAdd
BinXorToAdd	FailedLitSearcher.h	/^        class BinXorToAdd$/;"	c	class:FailedLitSearcher
BitArray	BitArray.h	/^    BitArray() :$/;"	f	class:BitArray
BitArray	BitArray.h	/^    BitArray(const BitArray& b) :$/;"	f	class:BitArray
BitArray	BitArray.h	/^class BitArray$/;"	c
BitIter	DoublePackedRow.h	/^                inline BitIter(unsigned char& mp, const uint32_t _offset) :$/;"	f	class:MINISAT::DoublePackedRow::BitIter
BitIter	DoublePackedRow.h	/^        class BitIter {$/;"	c	class:MINISAT::DoublePackedRow
BitIterConst	DoublePackedRow.h	/^                inline BitIterConst(unsigned char& mp, const uint32_t _offset) :$/;"	f	class:MINISAT::DoublePackedRow::BitIterConst
BitIterConst	DoublePackedRow.h	/^        class BitIterConst {$/;"	c	class:MINISAT::DoublePackedRow
BoxedVec_h	BoxedVec.h	21;"	d
CFLAGS	Makefile	/^CFLAGS = -Wall -DHAVE_CONFIG_H -fopenmp$/;"	m
CHUNK_LIMIT	StreamBuffer.h	23;"	d
CLAUSEALLOCATOR_H	ClauseAllocator.h	19;"	d
CLAUSECLEANER_H	ClauseCleaner.h	19;"	d
CLAUSEOFFSET_H	ClauseOffset.h	2;"	d
CLAUSEVIVIFIER_H	ClauseVivifier.h	19;"	d
CLAUSE_H	Clause.h	11;"	d
CSET_H	CSet.h	6;"	d
CSet	CSet.h	/^class CSet {$/;"	c
ClAndBin	Subsumer.h	/^            ClAndBin(ClauseSimp& cl) :$/;"	f	class:Subsumer::ClAndBin
ClAndBin	Subsumer.h	/^            ClAndBin(const Lit _lit1, const Lit _lit2) :$/;"	f	class:Subsumer::ClAndBin
ClAndBin	Subsumer.h	/^    class ClAndBin {$/;"	c	class:Subsumer
Clause	Clause.h	/^    Clause(const V& ps, const uint32_t _group, const bool learnt)$/;"	f	struct:Clause
Clause	Clause.h	/^struct Clause$/;"	s
ClauseAllocator	ClauseAllocator.cpp	/^ClauseAllocator::ClauseAllocator()$/;"	f	class:ClauseAllocator
ClauseAllocator	ClauseAllocator.h	/^class ClauseAllocator {$/;"	c
ClauseCleaner	ClauseCleaner.cpp	/^ClauseCleaner::ClauseCleaner(Solver& _solver) :$/;"	f	class:ClauseCleaner
ClauseCleaner	ClauseCleaner.h	/^class ClauseCleaner$/;"	c
ClauseOffset	ClauseOffset.h	/^typedef uint32_t ClauseOffset;$/;"	t
ClauseSetType	ClauseCleaner.h	/^        enum ClauseSetType {clauses, binaryClauses, xorclauses, learnts};$/;"	g	class:ClauseCleaner
ClauseSimp	CSet.h	/^        ClauseSimp(Clause* c, const uint32_t _index) :$/;"	f	class:ClauseSimp
ClauseSimp	CSet.h	/^class ClauseSimp$/;"	c
ClauseTable	XorFinder.h	/^        typedef vector<pair<Clause*, uint32_t> > ClauseTable;$/;"	t	class:XorFinder
ClauseVivifier	ClauseVivifier.cpp	/^ClauseVivifier::ClauseVivifier(Solver& _solver) :$/;"	f	class:ClauseVivifier
ClauseVivifier	ClauseVivifier.h	/^class ClauseVivifier {$/;"	c
Clause_new	ClauseAllocator.cpp	/^Clause* ClauseAllocator::Clause_new(Clause& c)$/;"	f	class:ClauseAllocator
Clause_new	ClauseAllocator.cpp	/^Clause* ClauseAllocator::Clause_new(const T& ps, const unsigned int group, const bool learnt)$/;"	f	class:ClauseAllocator
ClausesStay	CompleteDetachReattacher.h	/^                ClausesStay() :$/;"	f	class:CompleteDetachReatacher::ClausesStay
ClausesStay	CompleteDetachReattacher.h	/^        class ClausesStay {$/;"	c	class:CompleteDetachReatacher
CompleteDetachReatacher	CompleteDetachReattacher.cpp	/^CompleteDetachReatacher::CompleteDetachReatacher(Solver& _solver) :$/;"	f	class:CompleteDetachReatacher
CompleteDetachReatacher	CompleteDetachReattacher.h	/^class CompleteDetachReatacher$/;"	c
DEBUG_ATTACH	constants.h	94;"	d
DEBUG_ATTACH_FULL	constants.h	78;"	d
DEBUG_COMMENT_PARSING	DimacsParser.cpp	17;"	d	file:
DEBUG_HYPERBIN	constants.h	96;"	d
DEBUG_PROPAGATEFROM	constants.h	92;"	d
DEBUG_REPLACER	constants.h	95;"	d
DEBUG_UNCHECKEDENQUEUE_LEVEL0	Solver.h	83;"	d
DEBUG_USELESS_LEARNT_BIN_REMOVAL	constants.h	77;"	d
DEBUG_VARELIM	constants.h	91;"	d
DEBUG_WATCHED	constants.h	93;"	d
DEBUG_XORFIND	XorFinder.h	27;"	d
DEFAULT_MAX_GLUE	constants.h	59;"	d
DIMACSPARSER_H	DimacsParser.h	10;"	d
DOUBLEPACKEDROW_H	DoublePackedRow.h	19;"	d
DYNAMICALLY_UPDATE_GLUE	constants.h	63;"	d
DataSync	DataSync.cpp	/^DataSync::DataSync(Solver& _solver, SharedData* _sharedData) :$/;"	f	class:DataSync
DataSync	DataSync.h	/^class DataSync$/;"	c
Datum	Vec.h	/^    typedef T   Datum;$/;"	t	class:vec
DeepEqual	Map.h	/^template<class K> struct DeepEqual { bool     operator()(const K* k1, const K* k2) const { return *k1 == *k2; } };$/;"	s
DeepHash	Map.h	/^template<class K> struct DeepHash  { uint32_t operator()(const K* k)               const { return hash(*k);  } };$/;"	s
DimacsParser	DimacsParser.cpp	/^DimacsParser::DimacsParser(Solver* _solver, const bool _debugLib, const bool _debugNewVar, const bool _grouping, const bool _addAsLearnt):$/;"	f	class:DimacsParser
DimacsParser	DimacsParser.h	/^class DimacsParser$/;"	c
DoublePackedRow	DoublePackedRow.h	/^        DoublePackedRow() :$/;"	f	class:MINISAT::DoublePackedRow
DoublePackedRow	DoublePackedRow.h	/^class DoublePackedRow$/;"	c	namespace:MINISAT
EFFECTIVELY_USEABLE_BITS	ClauseAllocator.cpp	43;"	d	file:
EXTRATIME_DIVIDER	UselessBinRemover.cpp	38;"	d	file:
Equal	Map.h	/^template<class K> struct Equal { bool     operator()(const K& k1, const K& k2) const { return k1 == k2; } };$/;"	s
FAILEDLITSEARCHER_H	FailedLitSearcher.h	19;"	d
FIXCLEANREPLACE	constants.h	29;"	d
FULLRESTART_MULTIPLIER	constants.h	49;"	d
FULLRESTART_MULTIPLIER_MULTIPLIER	constants.h	50;"	d
FailedLitSearcher	FailedLitSearcher.cpp	/^FailedLitSearcher::FailedLitSearcher(Solver& _solver):$/;"	f	class:FailedLitSearcher
FailedLitSearcher	FailedLitSearcher.h	/^class FailedLitSearcher {$/;"	c
GAUSSIANCONFIG_H	GaussianConfig.h	19;"	d
GAUSSIAN_H	Gaussian.h	19;"	d
GaussConf	GaussianConfig.h	/^    GaussConf() :$/;"	f	class:GaussConf
GaussConf	GaussianConfig.h	/^class GaussConf$/;"	c
Gaussian	Gaussian.cpp	/^Gaussian::Gaussian(Solver& _solver, const GaussConf& _config, const uint32_t _matrix_no, const vector<XorClause*>& _xorclauses) :$/;"	f	class:Gaussian
Gaussian	Gaussian.h	/^class Gaussian$/;"	c
HAVE_DLFCN_H	config.h	5;"	d
HAVE_INTTYPES_H	config.h	8;"	d
HAVE_IOSTREAM	config.h	11;"	d
HAVE_MALLOC	config.h	15;"	d
HAVE_MEMORY_H	config.h	18;"	d
HAVE_STDINT_H	config.h	21;"	d
HAVE_STDLIB_H	config.h	24;"	d
HAVE_STRINGS_H	config.h	27;"	d
HAVE_STRING_H	config.h	30;"	d
HAVE_SYS_STAT_H	config.h	33;"	d
HAVE_SYS_TYPES_H	config.h	36;"	d
HAVE_UNISTD_H	config.h	39;"	d
Hash	Map.h	/^template<class K> struct Hash  { uint32_t operator()(const K& k)               const { return hash(k);  } };$/;"	s
Heap	Heap.h	/^    Heap(const Comp& c) : lt(c) { }$/;"	f	class:Heap
Heap	Heap.h	/^    Heap(const Heap<Comp>& other) : lt(other.lt) {$/;"	f	class:Heap
Heap	Heap.h	/^class Heap {$/;"	c
Heap_h	Heap.h	21;"	d
Key	Vec.h	/^    typedef uint32_t Key;$/;"	t	class:vec
LT_OBJDIR	config.h	43;"	d
Lit	SolverTypes.h	/^    Lit() : x(2*var_Undef) {}   \/\/ (lit_Undef)$/;"	f	class:Lit
Lit	SolverTypes.h	/^    explicit Lit(Var var, bool sign) : x((var+var) + (int)sign) { }$/;"	f	class:Lit
Lit	SolverTypes.h	/^    explicit Lit(uint32_t i) : x(i) { };$/;"	f	class:Lit
Lit	SolverTypes.h	/^class Lit$/;"	c
LitOrder2	FailedLitSearcher.h	/^            LitOrder2(const vec<BinPropData>& _binPropData) :$/;"	f	struct:FailedLitSearcher::LitOrder2
LitOrder2	FailedLitSearcher.h	/^        struct LitOrder2$/;"	s	class:FailedLitSearcher
LitReachData	Solver.h	/^            LitReachData() :$/;"	f	class:Solver::LitReachData
LitReachData	Solver.h	/^    class LitReachData {$/;"	c	class:Solver
M	MersenneTwister.h	/^	enum { M = 397 };  \/\/ period parameter$/;"	e	enum:MTRand::__anon3
MAIN_H	Main.h	10;"	d
MATRIXFINDER_H	MatrixFinder.h	19;"	d
MAXSIZE	ClauseAllocator.cpp	44;"	d	file:
MAX_BINARY_PROP	Subsumer.cpp	1041;"	d	file:
MAX_CLAUSENUM_XORFIND	constants.h	34;"	d
MAX_CONFL_BETWEEN_SIMPLIFY	constants.h	44;"	d
MAX_GAUSS_XOR_CLAUSES	constants.h	56;"	d
MAX_GLUE_BITS	constants.h	60;"	d
MAX_REMOVE_BIN_FULL_PROPS	UselessBinRemover.cpp	34;"	d	file:
MAX_THEORETICAL_GLUE	constants.h	61;"	d
MERSENNETWISTER_H	MersenneTwister.h	58;"	d
MINISAT	DoublePackedRow.h	/^namespace MINISAT$/;"	n
MIN_GAUSS_XOR_CLAUSES	constants.h	55;"	d
MIN_GLUE_RESTART	constants.h	62;"	d
MIN_LIST_SIZE	ClauseAllocator.cpp	39;"	d	file:
MTRand	MersenneTwister.h	/^class MTRand {$/;"	c
MTRand	MersenneTwister.h	/^inline MTRand::MTRand( const uint32& oneSeed )$/;"	f	class:MTRand
MTRand	MersenneTwister.h	/^inline MTRand::MTRand( uint32 *const bigSeed, const uint32 seedLength )$/;"	f	class:MTRand
MTRand	MersenneTwister.h	/^inline MTRand::MTRand()$/;"	f	class:MTRand
MYFLAG	Solver.h	/^    uint64_t            MYFLAG; \/\/\/<For glue calculation$/;"	m	class:Solver
Main	Main.cpp	/^Main::Main(int _argc, char** _argv) :$/;"	f	class:Main
Main	Main.h	/^class Main$/;"	c
Map	Map.h	/^                   Map        (Map<K,D,H,E>& other) { assert(0); }$/;"	f	class:Map
Map	Map.h	/^     Map () : table(NULL), cap(0), size(0) {}$/;"	f	class:Map
Map	Map.h	/^     Map (const H& h, const E& e) : Map(), hash(h), equals(e) {}$/;"	f	class:Map
Map	Map.h	/^class Map {$/;"	c
Map_h	Map.h	21;"	d
MatrixFinder	MatrixFinder.cpp	/^MatrixFinder::MatrixFinder(Solver& _solver) :$/;"	f	class:MatrixFinder
MatrixFinder	MatrixFinder.h	/^class MatrixFinder {$/;"	c
MyComp	Subsumer.h	/^    struct MyComp {$/;"	s	class:Subsumer
N	MersenneTwister.h	/^	enum { N = 624 };       \/\/ length of state vector$/;"	e	enum:MTRand::__anon1
NBCLAUSESBEFOREREDUCE	constants.h	27;"	d
NUM_BITS_OUTER_OFFSET	ClauseAllocator.h	37;"	d
NUM_CONFL_BURST_SEARCH	constants.h	46;"	d
NewBinaryClause	Subsumer.h	/^            NewBinaryClause(const Lit _lit1, const Lit _lit2, const bool _learnt) :$/;"	f	class:Subsumer::NewBinaryClause
NewBinaryClause	Subsumer.h	/^    class NewBinaryClause$/;"	c	class:Subsumer
NewPointerAndOffset	ClauseAllocator.h	/^        struct NewPointerAndOffset$/;"	s	class:ClauseAllocator
ONLYNONLEARNTBINS_H	OnlyNonLearntBins.h	19;"	d
OnlyNonLearntBins	OnlyNonLearntBins.cpp	/^OnlyNonLearntBins::OnlyNonLearntBins(Solver& _solver) :$/;"	f	class:OnlyNonLearntBins
OnlyNonLearntBins	OnlyNonLearntBins.h	/^class OnlyNonLearntBins$/;"	c
PACKAGE	config.h	46;"	d
PACKAGE_BUGREPORT	config.h	49;"	d
PACKAGE_NAME	config.h	52;"	d
PACKAGE_STRING	config.h	55;"	d
PACKAGE_TARNAME	config.h	58;"	d
PACKAGE_URL	config.h	61;"	d
PACKAGE_VERSION	config.h	64;"	d
PACKEDMATRIX_H	PackedMatrix.h	19;"	d
PACKEDROW_H	PackedRow.h	19;"	d
PARTFINDER_H	PartFinder.h	19;"	d
PARTHANDLER_H	PartHandler.h	19;"	d
PERCENTAGECLEANCLAUSES	constants.h	31;"	d
PERCENTAGEPERFORMREPLACE	constants.h	30;"	d
PROPBY_H	PropBy.h	19;"	d
PackedMatrix	PackedMatrix.h	/^    PackedMatrix() :$/;"	f	class:PackedMatrix
PackedMatrix	PackedMatrix.h	/^    PackedMatrix(const PackedMatrix& b) :$/;"	f	class:PackedMatrix
PackedMatrix	PackedMatrix.h	/^class PackedMatrix$/;"	c
PackedRow	PackedRow.h	/^    PackedRow(const uint32_t _size, uint64_t*  const _mp) :$/;"	f	class:PackedRow
PackedRow	PackedRow.h	/^class PackedRow$/;"	c
Pair	Map.h	/^    struct Pair { K key; D data; };$/;"	s	class:Map
PartFinder	PartFinder.cpp	/^PartFinder::PartFinder(Solver& _solver) :$/;"	f	class:PartFinder
PartFinder	PartFinder.h	/^class PartFinder {$/;"	c
PartHandler	PartHandler.cpp	/^PartHandler::PartHandler(Solver& s) :$/;"	f	class:PartHandler
PartHandler	PartHandler.h	/^class PartHandler$/;"	c
PropBy	PropBy.h	/^        PropBy() :$/;"	f	class:PropBy
PropBy	PropBy.h	/^        PropBy(ClauseOffset offset) :$/;"	f	class:PropBy
PropBy	PropBy.h	/^        PropBy(const Lit lit) :$/;"	f	class:PropBy
PropBy	PropBy.h	/^        PropBy(const Lit lit1, const Lit lit2) :$/;"	f	class:PropBy
PropBy	PropBy.h	/^class PropBy$/;"	c
PropByFull	PropBy.h	/^        PropByFull() :$/;"	f	class:PropByFull
PropByFull	PropBy.h	/^        PropByFull(PropBy orig, Lit otherLit, ClauseAllocator& alloc) :$/;"	f	class:PropByFull
PropByFull	PropBy.h	/^        PropByFull(const PropByFull& other) :$/;"	f	class:PropByFull
PropByFull	PropBy.h	/^class PropByFull$/;"	c
Queue	Queue.h	/^    Queue(void) : first(0) { }$/;"	f	class:Queue
Queue	Queue.h	/^class Queue {$/;"	c
Queue_h	Queue.h	21;"	d
RANDOM_LOOKAROUND_SEARCHSPACE	constants.h	37;"	d
RATIOREMOVECLAUSES	constants.h	26;"	d
RESTARTTYPECHOOSER_H	RestartTypeChooser.h	19;"	d
RESTART_TYPE_DECIDER_FROM	constants.h	51;"	d
RESTART_TYPE_DECIDER_UNTIL	constants.h	52;"	d
RestartType	SolverTypes.h	/^enum RestartType {dynamic_restart, static_restart, auto_restart};$/;"	g
RestartTypeChooser	RestartTypeChooser.cpp	/^RestartTypeChooser::RestartTypeChooser(const Solver& s) :$/;"	f	class:RestartTypeChooser
RestartTypeChooser	RestartTypeChooser.h	/^class RestartTypeChooser$/;"	c
SAVE	MersenneTwister.h	/^	enum { SAVE = N + 1 };  \/\/ length of array for save()$/;"	e	enum:MTRand::__anon2
SCCFINDER_H	SCCFinder.h	19;"	d
SCCFinder	SCCFinder.cpp	/^SCCFinder::SCCFinder(Solver& _solver) :$/;"	f	class:SCCFinder
SCCFinder	SCCFinder.h	/^class SCCFinder {$/;"	c
SHARED_DATA_H	SharedData.h	19;"	d
SIGINT_handler	Main.cpp	/^void SIGINT_handler(int signum)$/;"	f
SILENT_DEBUG	constants.h	76;"	d
SILENT_DEBUG	constants.h	87;"	d
SIMPLIFIER_H	Subsumer.h	10;"	d
SIMPLIFY_MULTIPLIER	constants.h	42;"	d
SIMPLIFY_MULTIPLIER_MULTIPLIER	constants.h	43;"	d
SIZEOF_INT	config.h	67;"	d
SIZEOF_LONG	config.h	70;"	d
SIZEOF_SIZE_T	config.h	73;"	d
SOLVERCONF_H	SolverConf.h	19;"	d
SOLVERTYPES_H	SolverTypes.h	12;"	d
SOLVER_H	Solver.h	23;"	d
STATESAVER__H	StateSaver.h	19;"	d
STDC_HEADERS	config.h	76;"	d
STREAMBUFFER_H	StreamBuffer.h	21;"	d
SYNC_EVERY_CONFL	constants.h	67;"	d
SharedData	SharedData.h	/^class SharedData$/;"	c
Solver	Solver.cpp	/^Solver::Solver(const SolverConf& _conf, const GaussConf& _gaussconfig, SharedData* sharedData) :$/;"	f	class:Solver
Solver	Solver.h	/^class Solver$/;"	c
SolverConf	SolverConf.cpp	/^SolverConf::SolverConf() :$/;"	f	class:SolverConf
SolverConf	SolverConf.h	/^class SolverConf$/;"	c
StateSaver	StateSaver.cpp	/^StateSaver::StateSaver(Solver& _solver) :$/;"	f	class:StateSaver
StateSaver	StateSaver.h	/^class StateSaver$/;"	c
StreamBuffer	StreamBuffer.h	/^    StreamBuffer(FILE * i) : in(i), pos(0), size(0) {$/;"	f	class:StreamBuffer
StreamBuffer	StreamBuffer.h	/^class StreamBuffer$/;"	c
Subsumer	Subsumer.cpp	/^Subsumer::Subsumer(Solver& s):$/;"	f	class:Subsumer
Subsumer	Subsumer.h	/^class Subsumer$/;"	c
TIME_MEM_H	time_mem.h	22;"	d
TransCache	Solver.h	/^            TransCache() :$/;"	f	class:Solver::TransCache
TransCache	Solver.h	/^    class TransCache {$/;"	c	class:Solver
TwoLongXor	FailedLitSearcher.h	/^        class TwoLongXor$/;"	c	class:FailedLitSearcher
UNWINDING_DEBUG	Solver.cpp	45;"	d	file:
UPDATE_TRANSOTFSSR_CACHE	constants.h	38;"	d
UPDATE_VAR_ACTIVITY_BASED_ON_GLUE	constants.h	64;"	d
USELESSBINREMOVER_H	UselessBinRemover.h	19;"	d
USE_GAUSS	config.h	79;"	d
UselessBinRemover	UselessBinRemover.cpp	/^UselessBinRemover::UselessBinRemover(Solver& _solver) :$/;"	f	class:UselessBinRemover
UselessBinRemover	UselessBinRemover.h	/^class UselessBinRemover {$/;"	c
VARREPLACER_H	VarReplacer.h	19;"	d
VERBOSE_DEBUGSUBSUME0	XorSubsumer.cpp	23;"	d	file:
VERSION	config.h	82;"	d
Var	SolverTypes.h	/^typedef uint32_t Var;$/;"	t
VarFilter	Solver.h	/^        VarFilter(const Solver& _s) : s(_s) {}$/;"	f	struct:Solver::VarFilter
VarFilter	Solver.h	/^    struct VarFilter {$/;"	s	class:Solver
VarOcc	Subsumer.h	/^            VarOcc(const Var& v, const uint32_t num) :$/;"	f	class:Subsumer::VarOcc
VarOcc	Subsumer.h	/^    class VarOcc {$/;"	c	class:Subsumer
VarOrderLt	Solver.h	/^        VarOrderLt(const vec<uint32_t>&  act) : activity(act) { }$/;"	f	struct:Solver::VarOrderLt
VarOrderLt	Solver.h	/^    struct VarOrderLt {$/;"	s	class:Solver
VarReplacer	VarReplacer.cpp	/^VarReplacer::VarReplacer(Solver& _solver) :$/;"	f	class:VarReplacer
VarReplacer	VarReplacer.h	/^class VarReplacer$/;"	c
Vec_h	Vec.h	21;"	d
Vec_t	BoxedVec.h	/^    struct Vec_t {$/;"	s	class:bvec
WATCHED_H	Watched.h	19;"	d
Watched	Watched.h	/^        Watched(const ClauseOffset offset)$/;"	f	class:Watched
Watched	Watched.h	/^        Watched(const ClauseOffset offset, Lit blockedLit)$/;"	f	class:Watched
Watched	Watched.h	/^        Watched(const Lit lit, const bool learnt)$/;"	f	class:Watched
Watched	Watched.h	/^        Watched(const Lit lit1, const Lit lit2)$/;"	f	class:Watched
Watched	Watched.h	/^class Watched {$/;"	c
WatchedBin	OnlyNonLearntBins.h	/^            WatchedBin(Lit _impliedLit) : impliedLit(_impliedLit) {};$/;"	f	class:OnlyNonLearntBins::WatchedBin
WatchedBin	OnlyNonLearntBins.h	/^        class WatchedBin {$/;"	c	class:OnlyNonLearntBins
WatchedSorter	Watched.h	/^struct WatchedSorter$/;"	s
XORFINDER_H	XorFinder.h	19;"	d
XORSIMPLIFIER_H	XorSubsumer.h	10;"	d
XSET_H	XSet.h	6;"	d
XSet	XSet.h	/^class XSet {$/;"	c
XorClause	Clause.h	/^    XorClause(const V& ps, const bool xorEqualFalse, const uint32_t _group) :$/;"	f	class:XorClause
XorClause	Clause.h	/^class XorClause : public Clause$/;"	c
XorClauseSimp	XSet.h	/^        XorClauseSimp(XorClause* c, const uint32_t _index) :$/;"	f	class:XorClauseSimp
XorClauseSimp	XSet.h	/^class XorClauseSimp$/;"	c
XorClause_new	ClauseAllocator.cpp	/^XorClause* ClauseAllocator::XorClause_new(const T& ps, const bool xorEqualFalse, const unsigned int group)$/;"	f	class:ClauseAllocator
XorElimedClause	XorSubsumer.h	/^    struct XorElimedClause$/;"	s	class:XorSubsumer
XorFinder	XorFinder.cpp	/^XorFinder::XorFinder(Solver& _solver, vec<Clause*>& _cls) :$/;"	f	class:XorFinder
XorFinder	XorFinder.h	/^class XorFinder$/;"	c
XorSubsumer	XorSubsumer.cpp	/^XorSubsumer::XorSubsumer(Solver& s):$/;"	f	class:XorSubsumer
XorSubsumer	XorSubsumer.h	/^class XorSubsumer$/;"	c
__builtin_prefetch	ClauseCleaner.cpp	23;"	d	file:
__builtin_prefetch	FailedLitSearcher.cpp	35;"	d	file:
__builtin_prefetch	Solver.cpp	40;"	d	file:
__builtin_prefetch	Subsumer.cpp	25;"	d	file:
__builtin_prefetch	XorFinder.cpp	30;"	d	file:
__builtin_prefetch	XorSubsumer.cpp	18;"	d	file:
_insert	Map.h	/^    void   _insert (const K& k, const D& d) { table[index(k)].push(); table[index(k)].last().key = k; table[index(k)].last().data = d; }$/;"	f	class:Map
a	XorFinder.h	/^            Lit const *a;$/;"	m	struct:XorFinder::clause_sorter_primary
abs64	Solver.cpp	/^inline int64_t abs64(int64_t a)$/;"	f
abst	Clause.h	/^    uint32_t abst; \/\/Abstraction of clause$/;"	m	struct:Clause
abstractLevel	Solver.h	/^inline uint32_t Solver::abstractLevel (const Var x) const$/;"	f	class:Solver
act	Subsumer.h	/^        float act;$/;"	m	struct:Subsumer::subsume0Happened
activity	Solver.h	/^        const vec<uint32_t>&  activity;$/;"	m	struct:Solver::VarOrderLt
activity	Solver.h	/^    vec<uint32_t>       activity;         \/\/\/< A heuristic measurement of the activity of a variable.$/;"	m	class:Solver
add	CSet.h	/^        const bool add(const ClauseSimp& c) {$/;"	f	class:CSet
add	XSet.h	/^        bool add(const XorClauseSimp& c) {$/;"	f	class:XSet
addAllXorAsNorm	XorFinder.cpp	/^void XorFinder::addAllXorAsNorm()$/;"	f	class:XorFinder
addAsLearnt	DimacsParser.h	/^        const bool addAsLearnt;$/;"	m	class:DimacsParser
addBackToSolver	Subsumer.cpp	/^void Subsumer::addBackToSolver()$/;"	f	class:Subsumer
addBackToSolver	XorSubsumer.cpp	/^void XorSubsumer::addBackToSolver()$/;"	f	class:XorSubsumer
addBin	FailedLitSearcher.cpp	/^void FailedLitSearcher::addBin(const Lit lit1, const Lit lit2)$/;"	f	class:FailedLitSearcher
addBinaryXorClause	VarReplacer.cpp	/^void VarReplacer::addBinaryXorClause(Lit lit1, Lit lit2, const uint32_t group, const bool addBinAsLearnt)$/;"	f	class:VarReplacer
addClause	Solver.cpp	/^bool Solver::addClause(T& ps, const uint32_t group, const char* group_name)$/;"	f	class:Solver
addClauseHelper	Solver.cpp	/^template<class T> const bool Solver::addClauseHelper(T& ps, const uint32_t group, const char* group_name)$/;"	f	class:Solver
addClauseInt	Solver.cpp	/^Clause* Solver::addClauseInt(T& ps, uint32_t group$/;"	f	class:Solver
addDegrees	RestartTypeChooser.cpp	/^void RestartTypeChooser::addDegrees(const vec<T*>& cs, vector<uint32_t>& degrees) const$/;"	f	class:RestartTypeChooser
addDegreesBin	RestartTypeChooser.cpp	/^void RestartTypeChooser::addDegreesBin(vector<uint32_t>& degrees) const$/;"	f	class:RestartTypeChooser
addFromSolver	FailedLitSearcher.cpp	/^void FailedLitSearcher::addFromSolver(const vec< XorClause* >& cs)$/;"	f	class:FailedLitSearcher
addFromSolver	Subsumer.cpp	/^const uint64_t Subsumer::addFromSolver(vec<Clause*>& cs)$/;"	f	class:Subsumer
addFromSolver	XorSubsumer.cpp	/^void XorSubsumer::addFromSolver(vec<XorClause*>& cs)$/;"	f	class:XorSubsumer
addInfo	RestartTypeChooser.cpp	/^void RestartTypeChooser::addInfo()$/;"	f	class:RestartTypeChooser
addLearntClause	Solver.cpp	/^bool Solver::addLearntClause(T& ps, const uint32_t group, const char* group_name, const uint32_t glue, const float miniSatActivity)$/;"	f	class:Solver
addOneBinToOthers	DataSync.cpp	/^void DataSync::addOneBinToOthers(const Lit lit1, const Lit lit2)$/;"	f	class:DataSync
addSavedState	PartHandler.cpp	/^void PartHandler::addSavedState()$/;"	f	class:PartHandler
addSymmBreakClauses	SolverMisc.cpp	/^void Solver::addSymmBreakClauses()$/;"	f	class:Solver
addToCannotEliminate	XorSubsumer.cpp	/^inline void XorSubsumer::addToCannotEliminate(Clause* it)$/;"	f	class:XorSubsumer
addToPart	PartFinder.cpp	/^void PartFinder::addToPart(const vec<T*>& cs)$/;"	f	class:PartFinder
addToPartBins	PartFinder.cpp	/^void PartFinder::addToPartBins()$/;"	f	class:PartFinder
addToPartClause	PartFinder.cpp	/^void PartFinder::addToPartClause(T& cl)$/;"	f	class:PartFinder
addVarFromXors	FailedLitSearcher.cpp	/^inline void FailedLitSearcher::addVarFromXors(const Var var)$/;"	f	class:FailedLitSearcher
addXorAsNormal3	XorFinder.cpp	/^void XorFinder::addXorAsNormal3(XorClause& c)$/;"	f	class:XorFinder
addXorAsNormal4	XorFinder.cpp	/^void XorFinder::addXorAsNormal4(XorClause& c)$/;"	f	class:XorFinder
addXorClause	Solver.cpp	/^bool Solver::addXorClause(T& ps, bool xorEqualFalse, const uint32_t group, const char* group_name)$/;"	f	class:Solver
addXorClauseInt	Solver.cpp	/^XorClause* Solver::addXorClauseInt(T& ps, bool xorEqualFalse, const uint32_t group, const bool learnt)$/;"	f	class:Solver
addedBin	FailedLitSearcher.h	/^        uint32_t addedBin;$/;"	m	class:FailedLitSearcher
addedClauseLits	Subsumer.h	/^    uint64_t addedClauseLits;$/;"	m	class:Subsumer
allAddedToSeen2	Solver.h	/^    vec<Lit>            allAddedToSeen2;  \/\/\/<To reduce temoprary data creation overhead. Used in minimiseLeartFurther()$/;"	m	class:Solver
allTautology	Subsumer.cpp	/^const bool Subsumer::allTautology(const T& ps, const Lit lit)$/;"	f	class:Subsumer
alloc	BoxedVec.h	/^        static Vec_t* alloc(Vec_t* x, int size){$/;"	f	struct:bvec::Vec_t
allocEnough	ClauseAllocator.cpp	/^void* ClauseAllocator::allocEnough(const uint32_t size)$/;"	f	class:ClauseAllocator
alreadyIn	CSet.h	/^        const bool alreadyIn(const ClauseSimp& c) const {$/;"	f	class:CSet
alreadyIn	VarReplacer.cpp	/^bool VarReplacer::alreadyIn(const Var var, const Lit lit)$/;"	f	class:VarReplacer
alsoLearnt	Subsumer.h	/^    bool alsoLearnt;$/;"	m	class:Subsumer
altvec	BoxedVec.h	/^    altvec (altvec<T>& other)                  { assert(0); }$/;"	f	class:bvec
altvec	BoxedVec.h	/^    altvec(int size)               : ref (Vec_t::alloc(NULL, fitSize(size))) { fill(size);      ref->sz = size; }$/;"	f	class:bvec
altvec	BoxedVec.h	/^    altvec(int size, const T& pad) : ref (Vec_t::alloc(NULL, fitSize(size))) { fill(size, pad); ref->sz = size; }$/;"	f	class:bvec
altvec	BoxedVec.h	/^    altvec(void)                   : ref (NULL) { }$/;"	f	class:bvec
analyse_confl	Gaussian.cpp	/^void Gaussian::analyse_confl(const matrixset& m, const uint32_t row, int32_t& maxlevel, uint32_t& size, uint32_t& best_row) const$/;"	f	class:Gaussian
analyze	Solver.cpp	/^Clause* Solver::analyze(PropBy conflHalf, vec<Lit>& out_learnt, int& out_btlevel, uint32_t &glue, const bool update)$/;"	f	class:Solver
analyzeFinal	Solver.cpp	/^void Solver::analyzeFinal(Lit p, vec<Lit>& out_conflict)$/;"	f	class:Solver
analyze_stack	Solver.h	/^    vec<Lit>            analyze_stack;$/;"	m	class:Solver
analyze_toclear	Solver.h	/^    vec<Lit>            analyze_toclear;$/;"	m	class:Solver
argc	Main.h	/^        int argc;$/;"	m	class:Main
argv	Main.h	/^        char** argv;$/;"	m	class:Main
assigns	Solver.h	/^    vec<lbool>          assigns;          \/\/\/< The current assignments$/;"	m	class:Solver
assumptions	Solver.h	/^    vec<Lit>            assumptions;      \/\/\/< Current set of assumptions provided to solve by the user.$/;"	m	class:Solver
assureLookahead	StreamBuffer.h	/^    void assureLookahead() {$/;"	f	class:StreamBuffer
attachBinClause	Solver.cpp	/^void Solver::attachBinClause(const Lit lit1, const Lit lit2, const bool learnt)$/;"	f	class:Solver
attachClause	Solver.cpp	/^void Solver::attachClause(Clause& c)$/;"	f	class:Solver
attachClause	Solver.cpp	/^void Solver::attachClause(XorClause& c)$/;"	f	class:Solver
auto_restart	SolverTypes.h	/^enum RestartType {dynamic_restart, static_restart, auto_restart};$/;"	e	enum:RestartType
avg	RestartTypeChooser.cpp	/^const double RestartTypeChooser::avg() const$/;"	f	class:RestartTypeChooser
avgBranchDepth	Solver.h	/^    bqueue<uint32_t>    avgBranchDepth;   \/\/\/< Avg branch depth. We collect this, and use it to do random look-around in the searchspace during simplifyProblem()$/;"	m	class:Solver
b	XorFinder.h	/^            Lit const *b;$/;"	m	struct:XorFinder::clause_sorter_primary
backup_activity	StateSaver.h	/^        vec<uint32_t> backup_activity;$/;"	m	class:StateSaver
backup_order_heap	StateSaver.h	/^        Heap<Solver::VarOrderLt> backup_order_heap;$/;"	m	class:StateSaver
backup_polarities	StateSaver.h	/^        vector<bool> backup_polarities;$/;"	m	class:StateSaver
backup_propagations	StateSaver.h	/^        uint64_t backup_propagations;$/;"	m	class:StateSaver
backup_random_var_freq	StateSaver.h	/^        uint32_t backup_random_var_freq;$/;"	m	class:StateSaver
backup_restartType	StateSaver.h	/^        RestartType backup_restartType;$/;"	m	class:StateSaver
backup_var_inc	StateSaver.h	/^        uint32_t backup_var_inc;$/;"	m	class:StateSaver
badlevel	Gaussian.h	/^    uint32_t badlevel;$/;"	m	class:Gaussian
begin	CSet.h	/^        const_iterator begin() const$/;"	f	class:CSet
begin	CSet.h	/^        iterator begin()$/;"	f	class:CSet
begin	XSet.h	/^        iterator begin()$/;"	f	class:XSet
beginMatrix	PackedMatrix.h	/^    inline iterator beginMatrix()$/;"	f	class:PackedMatrix
beginVarset	PackedMatrix.h	/^    inline iterator beginVarset()$/;"	f	class:PackedMatrix
binClausesRemoved	PartHandler.h	/^        vector<pair<Lit, Lit> > binClausesRemoved;$/;"	m	class:PartHandler
binPropData	FailedLitSearcher.h	/^            const vec<BinPropData>& binPropData;$/;"	m	struct:FailedLitSearcher::LitOrder2
binPropData	Solver.h	/^    vec<BinPropData>    binPropData;$/;"	m	class:Solver
binXorFind	FailedLitSearcher.h	/^        bool binXorFind;$/;"	m	class:FailedLitSearcher
binXorToAdd	FailedLitSearcher.h	/^        vector<BinXorToAdd> binXorToAdd;$/;"	m	class:FailedLitSearcher
binaryClauses	ClauseCleaner.h	/^        enum ClauseSetType {clauses, binaryClauses, xorclauses, learnts};$/;"	e	enum:ClauseCleaner::ClauseSetType
bins	SharedData.h	/^        std::vector<std::vector<Lit> > bins;$/;"	m	class:SharedData
binwatches	OnlyNonLearntBins.h	/^        vec<vec<WatchedBin> > binwatches; \/\/\/<Internal wathclists for non-learnt binary clauses$/;"	m	class:OnlyNonLearntBins
blockedClauseElimAll	Subsumer.cpp	/^void Subsumer::blockedClauseElimAll(const Lit lit)$/;"	f	class:Subsumer
blockedClauseRemoval	Subsumer.cpp	/^void Subsumer::blockedClauseRemoval()$/;"	f	class:Subsumer
boolToLBool	SolverTypes.h	/^inline lbool boolToLBool(const bool b)$/;"	f
bothInvert	FailedLitSearcher.h	/^        uint32_t bothInvert;$/;"	m	class:FailedLitSearcher
bothSame	FailedLitSearcher.h	/^        vec<Lit> bothSame;$/;"	m	class:FailedLitSearcher
bqueue	BoundedQueue.h	/^    bqueue(void) :$/;"	f	class:bqueue
bqueue	BoundedQueue.h	/^class bqueue {$/;"	c
buf	StreamBuffer.h	/^    char    buf[CHUNK_LIMIT];$/;"	m	class:StreamBuffer
bvec	BoxedVec.h	/^class bvec {$/;"	c
calcAbstraction	Clause.h	/^uint32_t calcAbstraction(const T& ps) {$/;"	f
calcAbstractionClause	Clause.h	/^    void calcAbstractionClause()$/;"	f	struct:Clause
calcHeap	RestartTypeChooser.cpp	/^void RestartTypeChooser::calcHeap()$/;"	f	class:RestartTypeChooser
calcIn	PartFinder.cpp	/^void PartFinder::calcIn(const vec<T*>& cs, vector<uint32_t>& numClauseInPart, vector<uint32_t>& sumLitsInPart)$/;"	f	class:PartFinder
calcInBins	PartFinder.cpp	/^void PartFinder::calcInBins(vector<uint32_t>& numClauseInPart, vector<uint32_t>& sumLitsInPart)$/;"	f	class:PartFinder
calcNBLevels	Solver.cpp	/^inline const uint32_t Solver::calcNBLevels(const T& ps)$/;"	f	class:Solver
calcReachability	Solver.cpp	/^void Solver::calcReachability()$/;"	f	class:Solver
calcXorAbstraction	XSet.h	/^uint32_t calcXorAbstraction(const T& ps) {$/;"	f
calculateDefaultPolarities	Solver.cpp	/^void Solver::calculateDefaultPolarities()$/;"	f	class:Solver
called	Gaussian.h	/^    uint32_t called; \/\/how many times called the Gauss$/;"	m	class:Gaussian
cancelUntil	Solver.cpp	/^void Solver::cancelUntil(int level)$/;"	f	class:Solver
cancelUntilLight	Solver.cpp	/^void Solver::cancelUntilLight()$/;"	f	class:Solver
cancel_until_sublevel	Gaussian.cpp	/^void Gaussian::cancel_until_sublevel(const uint32_t until_sublevel)$/;"	f	class:Gaussian
canceling	Gaussian.h	/^inline void Gaussian::canceling(const uint32_t sublevel)$/;"	f	class:Gaussian
cannot_eliminate	Subsumer.h	/^    vec<char>              cannot_eliminate;\/\/\/<Variables that cannot be eliminated due to, e.g. XOR-clauses$/;"	m	class:Subsumer
cannot_eliminate	VarReplacer.h	/^        vec<char> cannot_eliminate;$/;"	m	class:VarReplacer
cannot_eliminate	XorSubsumer.h	/^    vec<char> cannot_eliminate;$/;"	m	class:XorSubsumer
cap	BoxedVec.h	/^        int cap;$/;"	m	struct:bvec::Vec_t
cap	Map.h	/^    int        cap;$/;"	m	class:Map
cap	Vec.h	/^    uint32_t cap;$/;"	m	class:vec
capacity	BoxedVec.h	/^    void     capacity (int size)             { growTo(size); }$/;"	f	class:bvec
capacity	Vec.h	/^    void     capacity (uint32_t size) { grow(size); }$/;"	f	class:vec
changed_rows	Gaussian.h	/^    vector<unsigned char> changed_rows; \/\/used to store which rows were deemed propagatable during elimination$/;"	m	class:Gaussian
checkClauseMovement	PartHandler.cpp	/^const bool PartHandler::checkClauseMovement(const Solver& thisSolver, const uint32_t part, const PartFinder& partFinder) const$/;"	f	class:PartHandler
checkElimedUnassigned	Subsumer.cpp	/^const bool Subsumer::checkElimedUnassigned() const$/;"	f	class:Subsumer
checkElimedUnassigned	XorSubsumer.cpp	/^const bool XorSubsumer::checkElimedUnassigned() const$/;"	f	class:XorSubsumer
checkFullRestart	Solver.cpp	/^const bool Solver::checkFullRestart(uint64_t& nof_conflicts, uint64_t& nof_conflicts_fullrestart, uint32_t& lastFullRestart)$/;"	f	class:Solver
checkLiteralCount	SolverDebug.cpp	/^void Solver::checkLiteralCount()$/;"	f	class:Solver
checkOnlyThisPart	PartHandler.cpp	/^const bool PartHandler::checkOnlyThisPart(const vec<T*>& cs, const uint32_t part, const PartFinder& partFinder) const$/;"	f	class:PartHandler
checkOnlyThisPartBin	PartHandler.cpp	/^const bool PartHandler::checkOnlyThisPartBin(const Solver& thisSolver, const uint32_t part, const PartFinder& partFinder) const$/;"	f	class:PartHandler
checkSolution	SolverDebug.cpp	/^void Solver::checkSolution()$/;"	f	class:Solver
check_first_one_in_row	Gaussian.cpp	/^const void Gaussian::check_first_one_in_row(matrixset& m, const uint32_t j)$/;"	f	class:Gaussian
check_last_one_in_cols	Gaussian.cpp	/^const bool Gaussian::check_last_one_in_cols(matrixset& m) const$/;"	f	class:Gaussian
check_matrix_against_varset	Gaussian.cpp	/^void Gaussian::check_matrix_against_varset(PackedMatrix& matrix, const matrixset& m) const$/;"	f	class:Gaussian
check_no_conflict	Gaussian.cpp	/^bool Gaussian::check_no_conflict(matrixset& m) const$/;"	f	class:Gaussian
choose	RestartTypeChooser.cpp	/^const RestartType RestartTypeChooser::choose()$/;"	f	class:RestartTypeChooser
chooseRestartType	Solver.cpp	/^const bool Solver::chooseRestartType(const uint32_t& lastFullRestart)$/;"	f	class:Solver
clBinTouched	Subsumer.h	/^    list<NewBinaryClause> clBinTouched; \/\/\/<Binary clauses strengthened\/added$/;"	m	class:Subsumer
cl_touched	Subsumer.h	/^    CSet                   cl_touched;     \/\/\/<Clauses strengthened\/added$/;"	m	class:Subsumer
claBumpActivity	Solver.h	/^inline void Solver::claBumpActivity (Clause& c)$/;"	f	class:Solver
claDecayActivity	Solver.h	/^inline void Solver::claDecayActivity()$/;"	f	class:Solver
cla_inc	Solver.h	/^    float               cla_inc;          \/\/\/< Amount to bump learnt clause oldActivity with$/;"	m	class:Solver
clause	CSet.h	/^        Clause* clause; \/\/\/<The clause to be stored$/;"	m	class:ClauseSimp
clause	PropBy.h	/^        Clause* clause;$/;"	m	class:PropByFull
clause	XSet.h	/^        XorClause* clause;$/;"	m	class:XorClauseSimp
clauseAllocator	Solver.h	/^    ClauseAllocator     clauseAllocator;  \/\/\/< Handles memory allocation for claues$/;"	m	class:Solver
clauseCleaner	Solver.h	/^    ClauseCleaner*      clauseCleaner;$/;"	m	class:Solver
clauseEqual	XorFinder.cpp	/^bool XorFinder::clauseEqual(const Clause& c1, const Clause& c2) const$/;"	f	class:XorFinder
clauseFree	ClauseAllocator.cpp	/^void ClauseAllocator::clauseFree(Clause* c)$/;"	f	class:ClauseAllocator
clauseID	Subsumer.h	/^    uint32_t clauseID;         \/\/\/<We need to have clauseIDs since clauses don't natively have them. The ClauseID is stored by ClauseSimp, which also stores a pointer to the clause$/;"	m	class:Subsumer
clauseID	XorSubsumer.h	/^    uint32_t clauseID;$/;"	m	class:XorSubsumer
clauseVivifier	Solver.h	/^    ClauseVivifier*     clauseVivifier;$/;"	m	class:Solver
clause_decay	SolverConf.h	/^        double    clause_decay;       \/\/\/<Inverse of the clause activity decay factor. Only applies if using MiniSat-style clause activities  (default: 1 \/ 0.999)$/;"	m	class:SolverConf
clause_sorter_primary	XorFinder.h	/^        struct clause_sorter_primary {$/;"	s	class:XorFinder
clause_sorter_secondary	XorFinder.h	/^        struct clause_sorter_secondary {$/;"	s	class:XorFinder
clause_vareq	XorFinder.h	/^        bool clause_vareq(const Clause* c1, const Clause* c2) const$/;"	f	class:XorFinder
clauses	ClauseCleaner.h	/^        enum ClauseSetType {clauses, binaryClauses, xorclauses, learnts};$/;"	e	enum:ClauseCleaner::ClauseSetType
clauses	Solver.h	/^    vec<Clause*>        clauses;          \/\/\/< List of problem clauses that are normally larger than 2. Sometimes, due to on-the-fly self-subsuming resoulution, clauses here become 2-long. They are never purposfully put here such that they are long$/;"	m	class:Solver
clauses	Subsumer.h	/^    vec<ClauseSimp>        clauses;$/;"	m	class:Subsumer
clauses	XorSubsumer.h	/^    vec<XorClauseSimp>        clauses;$/;"	m	class:XorSubsumer
clausesRemoved	PartHandler.h	/^        vec<Clause*> clausesRemoved;$/;"	m	class:PartHandler
clauses_cut	XorSubsumer.h	/^    uint32_t clauses_cut;$/;"	m	class:XorSubsumer
clauses_literals	Solver.h	/^    uint64_t clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Solver
clauses_subsumed	Subsumer.h	/^    uint32_t clauses_subsumed; \/\/\/<Number of clauses subsumed in this run$/;"	m	class:Subsumer
clauses_subsumed	XorSubsumer.h	/^    uint32_t clauses_subsumed;$/;"	m	class:XorSubsumer
clauses_toclear	Gaussian.h	/^    vector<pair<Clause*, uint32_t> > clauses_toclear;$/;"	m	class:Gaussian
cleanAndAttachClauses	CompleteDetachReattacher.cpp	/^inline void CompleteDetachReatacher::cleanAndAttachClauses(vec<Clause*>& cs)$/;"	f	class:CompleteDetachReatacher
cleanAndAttachClauses	CompleteDetachReattacher.cpp	/^inline void CompleteDetachReatacher::cleanAndAttachClauses(vec<XorClause*>& cs)$/;"	f	class:CompleteDetachReatacher
cleanClause	ClauseCleaner.cpp	/^inline const bool ClauseCleaner::cleanClause(Clause*& cc)$/;"	f	class:ClauseCleaner
cleanClause	ClauseCleaner.cpp	/^inline const bool ClauseCleaner::cleanClause(XorClause& c)$/;"	f	class:ClauseCleaner
cleanClause	CompleteDetachReattacher.cpp	/^inline const bool CompleteDetachReatacher::cleanClause(Clause*& cl)$/;"	f	class:CompleteDetachReatacher
cleanClause	CompleteDetachReattacher.cpp	/^inline const bool CompleteDetachReatacher::cleanClause(XorClause& ps)$/;"	f	class:CompleteDetachReatacher
cleanClause	Subsumer.cpp	/^const bool Subsumer::cleanClause(Clause& ps)$/;"	f	class:Subsumer
cleanClause	Subsumer.cpp	/^const bool Subsumer::cleanClause(vec<Lit>& ps) const$/;"	f	class:Subsumer
cleanClauses	ClauseCleaner.cpp	/^void ClauseCleaner::cleanClauses(vec<Clause*>& cs, ClauseSetType type, const uint32_t limit)$/;"	f	class:ClauseCleaner
cleanClauses	ClauseCleaner.cpp	/^void ClauseCleaner::cleanClauses(vec<XorClause*>& cs, ClauseSetType type, const uint32_t limit)$/;"	f	class:ClauseCleaner
clear	BasicHeap.h	/^    void clear     (bool dealloc = false)       { heap.clear(dealloc); }$/;"	f	class:BasicHeap
clear	BoundedQueue.h	/^    void clear(bool dealloc = false)   {$/;"	f	class:bqueue
clear	BoxedVec.h	/^    void     clear  (bool dealloc = false) { $/;"	f	class:bvec
clear	CSet.h	/^        void clear(void) {$/;"	f	class:CSet
clear	Heap.h	/^    void clear(bool dealloc = false) $/;"	f	class:Heap
clear	Map.h	/^    void clear  () {$/;"	f	class:Map
clear	Queue.h	/^    void clear(bool dealloc = false)   { elems.clear(dealloc); first = 0; }$/;"	f	class:Queue
clear	Vec.h	/^void vec<T>::clear(bool dealloc) {$/;"	f	class:vec
clear	XSet.h	/^        void clear(void) {$/;"	f	class:XSet
clearAll	Subsumer.cpp	/^void Subsumer::clearAll()$/;"	f	class:Subsumer
clearBit	BitArray.h	/^    inline void clearBit(const uint32_t i)$/;"	f	class:BitArray
clearBit	PackedRow.h	/^    inline void clearBit(const uint32_t i)$/;"	f	class:PackedRow
clearGaussMatrixes	Solver.cpp	/^const bool Solver::clearGaussMatrixes()$/;"	f	class:Solver
clearWatchNotBinNotTri	CompleteDetachReattacher.cpp	/^const CompleteDetachReatacher::ClausesStay CompleteDetachReatacher::clearWatchNotBinNotTri(vec<Watched>& ws, const bool removeTri)$/;"	f	class:CompleteDetachReatacher
cls	XorFinder.h	/^        vec<Clause*>& cls;$/;"	m	class:XorFinder
clsimp	Subsumer.h	/^            ClauseSimp clsimp;$/;"	m	class:Subsumer::ClAndBin
col_to_var	Gaussian.h	/^        vector<Var> col_to_var; \/\/ col_to_var[COL] tells which variable is at a given column in the matrix. Gives unassigned_var if the COL has been zeroed (i.e. the variable assigned)$/;"	m	class:Gaussian::matrixset
col_to_var_original	Gaussian.h	/^    vector<Var> col_to_var_original; \/\/Matches columns to variables$/;"	m	class:Gaussian
combineOuterInterOffsets	ClauseAllocator.cpp	/^inline const ClauseOffset ClauseAllocator::combineOuterInterOffsets(const uint32_t outerOffset, const uint32_t interOffset) const$/;"	f	class:ClauseAllocator
conf	Main.h	/^        SolverConf conf;$/;"	m	class:Main
conf	Solver.h	/^    SolverConf conf;$/;"	m	class:Solver
config	Gaussian.h	/^    const GaussConf& config;$/;"	m	class:Gaussian
configureNewSolver	PartHandler.cpp	/^void PartHandler::configureNewSolver(Solver& newSolver) const$/;"	f	class:PartHandler
conflSizeHist	Solver.h	/^    bqueue<uint32_t>    conflSizeHist;$/;"	m	class:Solver
conflict	Gaussian.h	/^    enum gaussian_ret {conflict, unit_conflict, propagation, unit_propagation, nothing};$/;"	e	enum:Gaussian::gaussian_ret
conflict	Solver.h	/^    vec<Lit>   conflict;          \/\/\/<If problem is unsatisfiable (possibly under assumptions), this vector represent the final conflict clause expressed in the assumptions.$/;"	m	class:Solver
conflictLastUpdated	Solver.h	/^            uint64_t conflictLastUpdated;$/;"	m	class:Solver::TransCache
conflicts	Solver.h	/^    uint64_t conflicts; \/\/\/<Num conflicts$/;"	m	class:Solver
conglomerate	Solver.h	/^    Conglomerate*       conglomerate;$/;"	m	class:Solver
consolidate	ClauseAllocator.cpp	/^void ClauseAllocator::consolidate(Solver* solver)$/;"	f	class:ClauseAllocator
const_iterator	CSet.h	/^                const_iterator(const ClauseSimp* _it) :$/;"	f	class:CSet::const_iterator
const_iterator	CSet.h	/^        class const_iterator$/;"	c	class:CSet
copyTo	BoxedVec.h	/^    void copyTo(altvec<T>& copy) const { copy.clear(); for (int i = 0; i < size(); i++) copy.push(ref->data[i]); }$/;"	f	class:bvec
copyTo	Vec.h	/^    void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (uint32_t i = 0; i != sz; i++) new (&copy[i]) T(data[i]); }$/;"	f	class:vec
correctReturnValue	Main.cpp	/^int Main::correctReturnValue(const lbool ret) const$/;"	f	class:Main
countImpairs	XorFinder.cpp	/^void XorFinder::countImpairs(const ClauseTable::iterator& begin, const ClauseTable::iterator& end, uint32_t& numImpair, uint32_t& numPair) const$/;"	f	class:XorFinder
countNumBinClauses	SolverMisc.cpp	/^const uint32_t Solver::countNumBinClauses(const bool alsoLearnt, const bool alsoNonLearnt) const$/;"	f	class:Solver
countVarsDegreeStDev	RestartTypeChooser.cpp	/^const std::pair<double, double> RestartTypeChooser::countVarsDegreeStDev() const$/;"	f	class:RestartTypeChooser
cpuTime	time_mem.h	/^static inline double cpuTime(void)$/;"	f
cpuTimeTotal	time_mem.h	/^static inline double cpuTimeTotal(void)$/;"	f
cur_matrixset	Gaussian.h	/^    matrixset cur_matrixset; \/\/ The current matrixset, i.e. the one we are working on, or the last one we worked on$/;"	m	class:Gaussian
currentlyUsedSizes	ClauseAllocator.h	/^        vec<size_t> currentlyUsedSizes;$/;"	m	class:ClauseAllocator
data	BoxedVec.h	/^        T   data[0];$/;"	m	struct:bvec::Vec_t
data	Clause.h	/^    Lit     data[0];$/;"	m	struct:Clause
data	Clause.h	/^    Lit     data[1];$/;"	m	struct:Clause
data	Map.h	/^    struct Pair { K key; D data; };$/;"	m	struct:Map::Pair
data	Vec.h	/^    T*  data;$/;"	m	class:vec
data1	Watched.h	/^        uint32_t data1;$/;"	m	class:Watched
data1AsLit	Watched.h	/^        const Lit data1AsLit() const$/;"	f	class:Watched
data2	Watched.h	/^        uint32_t data2;$/;"	m	class:Watched
data2AsLit	Watched.h	/^        const Lit data2AsLit() const$/;"	f	class:Watched
dataStarts	ClauseAllocator.h	/^        vec<uint32_t*> dataStarts; \/\/\/<Stacks start at these positions$/;"	m	class:ClauseAllocator
dataSync	Solver.h	/^    DataSync* dataSync;$/;"	m	class:Solver
debugLib	DimacsParser.h	/^        const bool debugLib;$/;"	m	class:DimacsParser
debugLib	Main.h	/^        bool debugLib;$/;"	m	class:Main
debugLibPart	DimacsParser.h	/^        uint32_t debugLibPart; \/\/\/<printing partial solutions to debugLibPart1..N.output when "debugLib" is set to TRUE$/;"	m	class:DimacsParser
debugNewVar	DimacsParser.h	/^        const bool debugNewVar;$/;"	m	class:DimacsParser
debugNewVar	Main.h	/^        bool debugNewVar;$/;"	m	class:Main
decisionLevel	Solver.h	/^inline uint32_t      Solver::decisionLevel ()      const$/;"	f	class:Solver
decisionVarRemoved	PartHandler.h	/^        vec<Var> decisionVarRemoved; \/\/\/<List of variables whose decision-ness has been removed (set to FALSE)$/;"	m	class:PartHandler
decision_until	GaussianConfig.h	/^    uint32_t decision_until; \/\/do Gauss until this level$/;"	m	class:GaussConf
decision_var	Solver.h	/^    vector<bool>        decision_var;     \/\/\/< Declares if a variable is eligible for selection in the decision heuristic.$/;"	m	class:Solver
decisions	Solver.h	/^    uint64_t decisions;     \/\/\/<Number of decisions made$/;"	m	class:Solver
decrease	Heap.h	/^    void decrease  (uint32_t n) { assert(inHeap(n)); percolateUp(indices[n]); }$/;"	f	class:Heap
defaultPolarity	Solver.cpp	/^inline bool Solver::defaultPolarity()$/;"	f	class:Solver
detachClause	Solver.cpp	/^void Solver::detachClause(const Clause& c)$/;"	f	class:Solver
detachClause	Solver.cpp	/^void Solver::detachClause(const XorClause& c)$/;"	f	class:Solver
detachModifiedClause	Solver.cpp	/^void Solver::detachModifiedClause(const Lit lit1, const Lit lit2, const Lit lit3, const uint32_t origSize, const Clause* address)$/;"	f	class:Solver
detachModifiedClause	Solver.cpp	/^void Solver::detachModifiedClause(const Var var1, const Var var2, const uint32_t origSize, const XorClause* address)$/;"	f	class:Solver
detachNonBinsNonTris	CompleteDetachReattacher.cpp	/^void CompleteDetachReatacher::detachNonBinsNonTris(const bool removeTri)$/;"	f	class:CompleteDetachReatacher
disable_if_necessary	Gaussian.cpp	/^void Gaussian::disable_if_necessary()$/;"	f	class:Gaussian
disabled	Gaussian.h	/^    bool disabled; \/\/ Gauss is disabled$/;"	m	class:Gaussian
doBlockedClause	SolverConf.h	/^        bool      doBlockedClause;    \/\/\/<Should try to remove blocked clauses$/;"	m	class:SolverConf
doCacheOTFSSR	SolverConf.h	/^        bool      doCacheOTFSSR;$/;"	m	class:SolverConf
doCalcReach	SolverConf.h	/^        bool      doCalcReach; \/\/\/<Calculate reachability, and influence variable decisions with that$/;"	m	class:SolverConf
doClausVivif	SolverConf.h	/^        bool      doClausVivif;      \/\/\/<Perform asymmetric branching at the beginning of the solving$/;"	m	class:SolverConf
doConglXors	SolverConf.h	/^        bool      doConglXors;        \/\/\/<Do variable elimination at the XOR-level (xor-ing 2 xor clauses thereby removing a variable)$/;"	m	class:SolverConf
doExtendedSCC	SolverConf.h	/^        bool      doExtendedSCC;$/;"	m	class:SolverConf
doFailedLit	SolverConf.h	/^        bool      doFailedLit;        \/\/\/<Carry out Failed literal probing + doubly propagated literal detection + 2-long xor clause detection during failed literal probing + hyper-binary resoolution$/;"	m	class:SolverConf
doFindEqLits	SolverConf.h	/^        bool      doFindEqLits;       \/\/\/<Automatically find binary xor clauses (i.e. variable equi- and antivalences)$/;"	m	class:SolverConf
doFindXors	SolverConf.h	/^        bool      doFindXors;         \/\/\/<Automatically find non-binary xor clauses and convert them to xor clauses$/;"	m	class:SolverConf
doHeuleProcess	SolverConf.h	/^        bool      doHeuleProcess;     \/\/\/<Perform local subsitutuion as per Heule's theis$/;"	m	class:SolverConf
doHyperBinRes	SolverConf.h	/^        bool      doHyperBinRes;      \/\/\/<Should try carry out hyper-binary resolution$/;"	m	class:SolverConf
doMaxGlueDel	SolverConf.h	/^        bool      doMaxGlueDel;$/;"	m	class:SolverConf
doMinimLMoreRecur	SolverConf.h	/^        bool      doMinimLMoreRecur;  \/\/\/<Always perform recursive\/transitive on-the-fly self self-subsuming resolution --> an enhancement of "strong minimization" of PrecoSat$/;"	m	class:SolverConf
doMinimLearntMore	SolverConf.h	/^        bool      doMinimLearntMore;  \/\/\/<Perform learnt-clause minimisation using watchists' binary and tertiary clauses? ("strong minimization" in PrecoSat)$/;"	m	class:SolverConf
doPartHandler	SolverConf.h	/^        bool      doPartHandler;      \/\/\/<Should try to find disconnected components and solve them individually?$/;"	m	class:SolverConf
doPerformPreSimp	SolverConf.h	/^        bool doPerformPreSimp;$/;"	m	class:SolverConf
doPrintAvgBranch	SolverConf.h	/^        bool      doPrintAvgBranch;$/;"	m	class:SolverConf
doRegFindEqLits	SolverConf.h	/^        bool      doRegFindEqLits;    \/\/\/<Regularly find binary xor clauses (i.e. variable equi- and antivalences)$/;"	m	class:SolverConf
doRemUselessBins	SolverConf.h	/^        bool      doRemUselessBins;   \/\/\/<Should try to remove useless binary clauses at the beginning of solving?$/;"	m	class:SolverConf
doRemUselessLBins	SolverConf.h	/^        bool      doRemUselessLBins; \/\/\/<Try to remove useless learnt binary clauses$/;"	m	class:SolverConf
doReplace	SolverConf.h	/^        bool      doReplace;          \/\/\/<Should var-replacing be performed? If set to FALSE, equi- and antivalent variables will not be replaced with one another. NOTE: This precludes using a lot of the algorithms!$/;"	m	class:SolverConf
doSatELite	SolverConf.h	/^        bool      doSatELite;         \/\/\/<Should try to subsume & self-subsuming resolve & variable-eliminate & block-clause eliminate?$/;"	m	class:SolverConf
doSchedSimp	SolverConf.h	/^        bool      doSchedSimp;        \/\/\/<Should simplifyProblem() be scheduled regularly? (if set to FALSE, a lot of opmitisations are disabled)$/;"	m	class:SolverConf
doSortWatched	SolverConf.h	/^        bool      doSortWatched;      \/\/\/<Sort watchlists according to size&type: binary, tertiary, normal (>3-long), xor clauses$/;"	m	class:SolverConf
doSubsWBins	SolverConf.h	/^        bool      doSubsWBins;$/;"	m	class:SolverConf
doSubsWNonExistBins	SolverConf.h	/^        bool      doSubsWNonExistBins;  \/\/\/<Try to do subsumption and self-subsuming resolution with non-existent binary clauses (i.e. binary clauses that don't exist but COULD exists)$/;"	m	class:SolverConf
doSubsume1	SolverConf.h	/^        bool      doSubsume1;         \/\/\/<Perform self-subsuming resolution$/;"	m	class:SolverConf
doVarElim	SolverConf.h	/^        bool      doVarElim;          \/\/\/<Perform variable elimination$/;"	m	class:SolverConf
doXorSubsumption	SolverConf.h	/^        bool      doXorSubsumption;   \/\/\/<Should try to subsume & local-subsitute xor clauses$/;"	m	class:SolverConf
doit	SCCFinder.h	/^inline void SCCFinder::doit(const Lit lit, const uint32_t vertex) {$/;"	f	class:SCCFinder
doneNum	Subsumer.h	/^    uint32_t doneNum;$/;"	m	class:Subsumer
dontDisable	GaussianConfig.h	/^    bool dontDisable; \/\/If activated, gauss elimination is never disabled$/;"	m	class:GaussConf
dontRemoveAncestor	FailedLitSearcher.h	/^        BitArray dontRemoveAncestor;$/;"	m	class:FailedLitSearcher
dump	Watched.h	/^        void dump(FILE* outfile, const Lit lit) const$/;"	f	class:Watched
dumpBinClauses	SolverMisc.cpp	/^void Solver::dumpBinClauses(const bool alsoLearnt, const bool alsoNonLearnt, FILE* outfile) const$/;"	f	class:Solver
dumpOrigClauses	SolverMisc.cpp	/^void Solver::dumpOrigClauses(const std::string& fileName) const$/;"	f	class:Solver
dumpSortedLearnts	SolverMisc.cpp	/^void Solver::dumpSortedLearnts(const std::string& fileName, const uint32_t maxSize)$/;"	f	class:Solver
dynStarts	Solver.h	/^    uint64_t dynStarts; \/\/\/<Num dynamic restarts$/;"	m	class:Solver
dynamic_behaviour_analysis	Solver.h	/^    bool     dynamic_behaviour_analysis; \/\/ Is logger running?$/;"	m	class:Solver
dynamic_restart	SolverTypes.h	/^enum RestartType {dynamic_restart, static_restart, auto_restart};$/;"	e	enum:RestartType
elems	BoundedQueue.h	/^    vec<T>  elems;$/;"	m	class:bqueue
elems	Queue.h	/^    vec<T>  elems;$/;"	m	class:Queue
elimedOutVar	Subsumer.h	/^    map<Var, vector<vector<Lit> > > elimedOutVar; \/\/\/<Contains the clauses to use to uneliminate a variable$/;"	m	class:Subsumer
elimedOutVar	XorSubsumer.h	/^    map<Var, vector<XorElimedClause> > elimedOutVar;$/;"	m	class:XorSubsumer
elimedOutVarBin	Subsumer.h	/^    map<Var, vector<std::pair<Lit, Lit> > > elimedOutVarBin; \/\/\/<Contains the clauses to use to uneliminate a variable$/;"	m	class:Subsumer
eliminate	Gaussian.cpp	/^uint32_t Gaussian::eliminate(matrixset& m, uint32_t& conflict_row)$/;"	f	class:Gaussian
eliminateVars	Subsumer.cpp	/^const bool Subsumer::eliminateVars()$/;"	f	class:Subsumer
empty	BasicHeap.h	/^    bool empty     ()                     const { return heap.size() == 0; }$/;"	f	class:BasicHeap
empty	Heap.h	/^    bool empty     ()          const { return heap.size() == 0; }$/;"	f	class:Heap
empty	Vec.h	/^    const bool empty() const {return size() == 0;}$/;"	f	class:vec
end	CSet.h	/^        const_iterator end() const$/;"	f	class:CSet
end	CSet.h	/^        iterator end()$/;"	f	class:CSet
end	XSet.h	/^        iterator end()$/;"	f	class:XSet
end	XorFinder.h	/^            Lit const *end;$/;"	m	struct:XorFinder::clause_sorter_primary
endMatrix	PackedMatrix.h	/^    inline iterator endMatrix()$/;"	f	class:PackedMatrix
endVarset	PackedMatrix.h	/^    inline iterator endVarset()$/;"	f	class:PackedMatrix
equals	Map.h	/^    E          equals;$/;"	m	class:Map
exclude	CSet.h	/^        bool exclude(const ClauseSimp& c) {$/;"	f	class:CSet
exclude	XSet.h	/^        bool exclude(const XorClauseSimp& c) {$/;"	f	class:XSet
expensive_ccmin	SolverConf.h	/^        bool      expensive_ccmin;    \/\/\/<Should clause minimisation by Sorensson&Biere be used?                                    (default TRUE)$/;"	m	class:SolverConf
extendModel	Subsumer.cpp	/^void Subsumer::extendModel(Solver& solver2)$/;"	f	class:Subsumer
extendModel	XorSubsumer.cpp	/^void XorSubsumer::extendModel(Solver& solver2)$/;"	f	class:XorSubsumer
extendModelImpossible	VarReplacer.cpp	/^void VarReplacer::extendModelImpossible(Solver& solver2) const$/;"	f	class:VarReplacer
extendModelPossible	VarReplacer.cpp	/^void VarReplacer::extendModelPossible() const$/;"	f	class:VarReplacer
extraTime	UselessBinRemover.h	/^        uint32_t extraTime; \/\/\/<Time that cannot be meausured in bogoprops (~propagation time)$/;"	m	class:UselessBinRemover
extraTimeNonExist	Subsumer.h	/^    uint64_t extraTimeNonExist;$/;"	m	class:Subsumer
failBinLit	Solver.h	/^    Lit                 failBinLit;       \/\/\/< Used to store which watches[~lit] we were looking through when conflict occured$/;"	m	class:Solver
failed	FailedLitSearcher.h	/^        bool failed; \/\/\/<For checking that a specific propagation failed (=conflict). It is used in many places$/;"	m	class:FailedLitSearcher
failed	UselessBinRemover.h	/^        bool failed; \/\/\/<Has the previous propagation failed? (=conflict)$/;"	m	class:UselessBinRemover
failedLitMultiplier	SolverConf.h	/^        double failedLitMultiplier;$/;"	m	class:SolverConf
failedLitSearcher	Solver.h	/^    FailedLitSearcher*  failedLitSearcher;$/;"	m	class:Solver
fastclear	BoundedQueue.h	/^    void fastclear() {first = 0; last = 0; queuesize=0; sumofqueue=0;} \/\/ to be called after restarts... Discard the queue$/;"	f	class:bqueue
fileNamePresent	Main.h	/^        bool fileNamePresent;$/;"	m	class:Main
filesToRead	Main.h	/^        std::vector<std::string> filesToRead;$/;"	m	class:Main
fill	BoxedVec.h	/^    void fill (int size) {$/;"	f	class:bvec
fill	BoxedVec.h	/^    void fill (int size, const T& pad) {$/;"	f	class:bvec
fill	OnlyNonLearntBins.cpp	/^const bool OnlyNonLearntBins::fill()$/;"	f	class:OnlyNonLearntBins
fill	PackedRow.cpp	/^const bool PackedRow::fill(vec<Lit>& tmp_clause, const vec<lbool>& assigns, const vector<Var>& col_to_var_original) const$/;"	f	class:PackedRow
fillBinImpliesMinusLast	UselessBinRemover.cpp	/^const bool UselessBinRemover::fillBinImpliesMinusLast(const Lit origLit, const Lit lit, vec<Lit>& wrong)$/;"	f	class:UselessBinRemover
fillCannotEliminate	Subsumer.cpp	/^void Subsumer::fillCannotEliminate()$/;"	f	class:Subsumer
fillCannotEliminate	XorSubsumer.cpp	/^void XorSubsumer::fillCannotEliminate()$/;"	f	class:XorSubsumer
fillClAndBin	Subsumer.cpp	/^void Subsumer::fillClAndBin(vec<ClAndBin>& all, vec<ClauseSimp>& cs, const Lit lit)$/;"	f	class:Subsumer
fillImplies	FailedLitSearcher.cpp	/^void FailedLitSearcher::fillImplies(const Lit lit)$/;"	f	class:FailedLitSearcher
fillSubs	Subsumer.cpp	/^void inline Subsumer::fillSubs(const T& ps, uint32_t abs, vec<ClauseSimp>& out_subsumed, vec<Lit>& out_lits, const Lit lit)$/;"	f	class:Subsumer
fill_matrix	Gaussian.cpp	/^void Gaussian::fill_matrix(matrixset& origMat)$/;"	f	class:Gaussian
filter	Heap.h	/^    void filter(const F& filt) {$/;"	f	class:Heap
find	Alg.h	/^static inline bool find(V& ts, const T& t)$/;"	f
find2LongXors	SCCFinder.cpp	/^const bool SCCFinder::find2LongXors()$/;"	f	class:SCCFinder
findAllAttach	Solver.h	/^inline void Solver::findAllAttach() const$/;"	f	class:Solver
findAllAttach	SolverDebug.cpp	/^void Solver::findAllAttach() const$/;"	f	class:Solver
findClause	SolverDebug.cpp	/^const bool Solver::findClause(Clause* c) const$/;"	f	class:Solver
findClause	SolverDebug.cpp	/^const bool Solver::findClause(XorClause* c) const$/;"	f	class:Solver
findMatrixes	MatrixFinder.cpp	/^const bool MatrixFinder::findMatrixes()$/;"	f	class:MatrixFinder
findParts	MatrixFinder.cpp	/^void MatrixFinder::findParts(vector<Var>& xorFingerprintInMatrix, vector<XorClause*>& xorsInMatrix)$/;"	f	class:MatrixFinder
findParts	PartFinder.cpp	/^const bool PartFinder::findParts()$/;"	f	class:PartFinder
findSubsumed	Subsumer.cpp	/^void Subsumer::findSubsumed(const T& ps, uint32_t abs, vec<ClauseSimp>& out_subsumed)$/;"	f	class:Subsumer
findSubsumed	XorSubsumer.cpp	/^void XorSubsumer::findSubsumed(XorClause& ps, vec<XorClauseSimp>& out_subsumed)$/;"	f	class:XorSubsumer
findSubsumed1	Subsumer.cpp	/^void Subsumer::findSubsumed1(const T& ps, uint32_t abs, vec<ClauseSimp>& out_subsumed, vec<Lit>& out_lits)$/;"	f	class:Subsumer
findUnMatched	XorSubsumer.cpp	/^void XorSubsumer::findUnMatched(const T& A, const T& B, vec<Lit>& unmatchedPart)$/;"	f	class:XorSubsumer
findW	Alg.h	/^static inline bool findW(V& ts, const T& t)$/;"	f
findWBin	Alg.h	/^static inline bool findWBin(const vec<vec<Watched> >& wsFull, const Lit lit1, const Lit impliedLit)$/;"	f
findWBin	Alg.h	/^static inline bool findWBin(const vec<vec<Watched> >& wsFull, const Lit lit1, const Lit impliedLit, const bool learnt)$/;"	f
findWCl	Alg.h	/^static inline bool findWCl(const vec<Watched>& ws, const ClauseOffset c)$/;"	f
findWTri	Alg.h	/^static inline const bool findWTri(const vec<Watched> &ws, const Lit lit1, const Lit lit2)$/;"	f
findWXCl	Alg.h	/^static inline bool findWXCl(const vec<Watched>& ws, const ClauseOffset c)$/;"	f
findWatchedOfBin	Alg.h	/^static inline Watched& findWatchedOfBin(vec<vec<Watched> >& wsFull, const Lit lit1, const Lit lit2)$/;"	f
findWatchedOfBin	Alg.h	/^static inline Watched& findWatchedOfBin(vec<vec<Watched> >& wsFull, const Lit lit1, const Lit lit2, const bool learnt)$/;"	f
findXors	XorFinder.cpp	/^const bool XorFinder::findXors(uint32_t& sumLengths)$/;"	f	class:XorFinder
find_sublevel	Gaussian.cpp	/^uint32_t Gaussian::find_sublevel(const Var v) const$/;"	f	class:Gaussian
find_truths	Gaussian.cpp	/^llbool Gaussian::find_truths(vec<Lit>& learnt_clause, uint64_t& conflictC)$/;"	f	class:Gaussian
fingerprint	MatrixFinder.cpp	/^inline const Var MatrixFinder::fingerprint(const XorClause& c) const$/;"	f	class:MatrixFinder
finished	Main.cpp	/^std::set<uint32_t> finished;$/;"	v
first	BoundedQueue.h	/^    uint32_t first;$/;"	m	class:bqueue
first	Queue.h	/^    int     first;$/;"	m	class:Queue
firstPartOfSecond	MatrixFinder.cpp	/^inline const bool MatrixFinder::firstPartOfSecond(const XorClause& c1, const XorClause& c2) const$/;"	f	class:MatrixFinder
firstVars	RestartTypeChooser.h	/^        vector<Var> firstVars; \/\/\/<The top x variables (in terms of var activity)$/;"	m	class:RestartTypeChooser
firstVarsOld	RestartTypeChooser.h	/^        vector<Var> firstVarsOld; \/\/\/<The previous top x variables (in terms of var activity)$/;"	m	class:RestartTypeChooser
first_one_in_row	Gaussian.h	/^        vector<uint16_t> first_one_in_row;$/;"	m	class:Gaussian::matrixset
fitSize	BoxedVec.h	/^    static int   fitSize  (int needed)  { int x; for (x = init_size; needed > x; x = nextSize(x)); return x; }$/;"	f	class:bvec
fixRestartType	SolverConf.h	/^        RestartType fixRestartType;   \/\/\/<If set, the solver will always choose the given restart strategy instead of automatically trying to guess a strategy. Note that even if set to dynamic_restart, there will be a few restarts made statically after each full restart.$/;"	m	class:SolverConf
foundXors	XorFinder.h	/^        uint32_t foundXors;$/;"	m	class:XorFinder
free	CSet.h	/^    vec<uint32_t>       free;   \/\/\/<List of positions holding 'Clause_NULL'.$/;"	m	class:CSet
free	XSet.h	/^    vec<uint32_t>       free;   \/\/ List of positions holding 'Clause_NULL'.$/;"	m	class:XSet
freeLater	Solver.h	/^    vec<XorClause*>     freeLater;        \/\/\/< xor clauses that need to be freed later (this is needed due to Gauss) \\todo Get rid of this$/;"	m	class:Solver
freeMemory	Subsumer.cpp	/^void Subsumer::freeMemory()$/;"	f	class:Subsumer
fullFindXors	XorFinder.cpp	/^const bool XorFinder::fullFindXors(const uint32_t minSize, const uint32_t maxSize)$/;"	f	class:XorFinder
fullStarts	Solver.h	/^    uint64_t fullStarts;    \/\/\/<Number of full restarts made$/;"	m	class:Solver
full_init	Gaussian.cpp	/^const bool Gaussian::full_init()$/;"	f	class:Gaussian
gauss_last_level	Gaussian.h	/^    int gauss_last_level;$/;"	m	class:Gaussian
gauss_matrixes	Solver.h	/^    vector<Gaussian*> gauss_matrixes;$/;"	m	class:Solver
gaussconfig	Main.h	/^        GaussConf gaussconfig;$/;"	m	class:Main
gaussconfig	Solver.h	/^    GaussConf gaussconfig;   \/\/\/<Configuration for the gaussian elimination can be set here$/;"	m	class:Solver
gaussian	Gaussian.cpp	/^Gaussian::gaussian_ret Gaussian::gaussian(PropBy& confl)$/;"	f	class:Gaussian
gaussian_ret	Gaussian.h	/^    enum gaussian_ret {conflict, unit_conflict, propagation, unit_propagation, nothing};$/;"	g	class:Gaussian
getAbst	Clause.h	/^    uint32_t getAbst()$/;"	f	struct:Clause
getAvgAllDouble	BoundedQueue.h	/^    double getAvgAllDouble() const {return (double)sumOfAllElems\/(double)totalNumElems;}$/;"	f	class:bqueue
getAvgDouble	BoundedQueue.h	/^    double getAvgDouble() const {return (double)sumofqueue\/(double)queuesize;}$/;"	f	class:bqueue
getAvgUInt	BoundedQueue.h	/^    uint32_t getAvgUInt() const {return (uint64_t)sumofqueue\/(uint64_t)queuesize;}$/;"	f	class:bqueue
getBinWatchSize	SolverMisc.cpp	/^const uint32_t Solver::getBinWatchSize(const bool alsoLearnt, const Lit lit)$/;"	f	class:Solver
getBinWatches	OnlyNonLearntBins.h	/^inline const vec<vec<OnlyNonLearntBins::WatchedBin> >& OnlyNonLearntBins::getBinWatches() const$/;"	f	class:OnlyNonLearntBins
getBlockedLit	Watched.h	/^        const Lit getBlockedLit() const$/;"	f	class:Watched
getBool	DoublePackedRow.h	/^                inline const bool getBool() const {$/;"	f	class:MINISAT::DoublePackedRow::BitIter
getBool	DoublePackedRow.h	/^                inline const bool getBool() const {$/;"	f	class:MINISAT::DoublePackedRow::BitIterConst
getBool	SolverTypes.h	/^    inline const bool getBool() const {$/;"	f	class:lbool
getClause	PropBy.h	/^        Clause* getClause()$/;"	f	class:PropByFull
getClause	PropBy.h	/^        ClauseOffset getClause()$/;"	f	class:PropBy
getClause	PropBy.h	/^        const Clause* getClause() const$/;"	f	class:PropByFull
getClause	PropBy.h	/^        const ClauseOffset getClause() const$/;"	f	class:PropBy
getData	Clause.h	/^    Lit* getData()$/;"	f	struct:Clause
getData	Clause.h	/^    const Lit* getData() const$/;"	f	struct:Clause
getData	Vec.h	/^    T* getData() {return data; }$/;"	f	class:vec
getData	Vec.h	/^    const T* getData() const {return data; }$/;"	f	class:vec
getDataEnd	Clause.h	/^    Lit* getDataEnd()$/;"	f	struct:Clause
getDataEnd	Clause.h	/^    const Lit* getDataEnd() const$/;"	f	struct:Clause
getDataEnd	Vec.h	/^    T* getDataEnd() {return data + size(); }$/;"	f	class:vec
getDataEnd	Vec.h	/^    const T* getDataEnd() const {return data + size(); }$/;"	f	class:vec
getElimedOutVar	Subsumer.h	/^inline const map<Var, vector<vector<Lit> > >& Subsumer::getElimedOutVar() const$/;"	f	class:Subsumer
getElimedOutVar	XorSubsumer.h	/^inline const map<Var, vector<XorSubsumer::XorElimedClause> >& XorSubsumer::getElimedOutVar() const$/;"	f	class:XorSubsumer
getElimedOutVarBin	Subsumer.h	/^inline const map<Var, vector<std::pair<Lit, Lit> > >& Subsumer::getElimedOutVarBin() const$/;"	f	class:Subsumer
getFreed	Clause.h	/^    const bool getFreed() const$/;"	f	struct:Clause
getGlue	Clause.h	/^    const uint32_t getGlue() const$/;"	f	struct:Clause
getGroup	Clause.h	/^    const uint32_t getGroup() const$/;"	f	struct:Clause
getInterOffset	ClauseAllocator.cpp	/^inline uint32_t ClauseAllocator::getInterOffset(const Clause* ptr, uint32_t outerOffset) const$/;"	f	class:ClauseAllocator
getLearnt	Watched.h	/^        const bool getLearnt() const$/;"	f	class:Watched
getMatrixAt	PackedMatrix.h	/^    inline PackedRow getMatrixAt(const uint32_t i)$/;"	f	class:PackedMatrix
getMatrixAt	PackedMatrix.h	/^    inline const PackedRow getMatrixAt(const uint32_t i) const$/;"	f	class:PackedMatrix
getMiniSatAct	Clause.h	/^    const float& getMiniSatAct() const$/;"	f	struct:Clause
getMiniSatAct	Clause.h	/^    float& getMiniSatAct()$/;"	f	struct:Clause
getNewToReplaceVars	VarReplacer.h	/^inline const uint32_t VarReplacer::getNewToReplaceVars() const$/;"	f	class:VarReplacer
getNextXor	XorFinder.cpp	/^bool XorFinder::getNextXor(ClauseTable::iterator& begin, ClauseTable::iterator& end, bool& impair)$/;"	f	class:XorFinder
getNormOffset	Watched.h	/^        const ClauseOffset getNormOffset() const$/;"	f	class:Watched
getNumElimSubsume	SolverMisc.cpp	/^const uint32_t Solver::getNumElimSubsume() const$/;"	f	class:Solver
getNumElimXorSubsume	SolverMisc.cpp	/^const uint32_t Solver::getNumElimXorSubsume() const$/;"	f	class:Solver
getNumElimed	Subsumer.h	/^inline const uint32_t Subsumer::getNumElimed() const$/;"	f	class:Subsumer
getNumElimed	XorSubsumer.h	/^inline const uint32_t XorSubsumer::getNumElimed() const$/;"	f	class:XorSubsumer
getNumLastReplacedVars	VarReplacer.h	/^inline const uint32_t VarReplacer::getNumLastReplacedVars() const$/;"	f	class:VarReplacer
getNumReplacedLits	VarReplacer.h	/^inline const uint32_t VarReplacer::getNumReplacedLits() const$/;"	f	class:VarReplacer
getNumReplacedVars	VarReplacer.h	/^inline const uint32_t VarReplacer::getNumReplacedVars() const$/;"	f	class:VarReplacer
getNumTrees	VarReplacer.h	/^inline const uint32_t VarReplacer::getNumTrees() const$/;"	f	class:VarReplacer
getNumXorTrees	SolverMisc.cpp	/^const uint32_t Solver::getNumXorTrees() const$/;"	f	class:Solver
getNumXorTreesCrownSize	SolverMisc.cpp	/^const uint32_t Solver::getNumXorTreesCrownSize() const$/;"	f	class:Solver
getOffset	ClauseAllocator.cpp	/^const ClauseOffset ClauseAllocator::getOffset(const Clause* ptr) const$/;"	f	class:ClauseAllocator
getOtherLit	PropBy.h	/^        const Lit getOtherLit() const$/;"	f	class:PropBy
getOtherLit	Watched.h	/^        const Lit getOtherLit() const$/;"	f	class:Watched
getOtherLit2	PropBy.h	/^        const Lit getOtherLit2() const$/;"	f	class:PropBy
getOtherLit2	Watched.h	/^        const Lit getOtherLit2() const$/;"	f	class:Watched
getOuterOffset	ClauseAllocator.cpp	/^inline uint32_t ClauseAllocator::getOuterOffset(const Clause* ptr) const$/;"	f	class:ClauseAllocator
getPartVars	PartFinder.h	/^inline const vector<Var>& PartFinder::getPartVars(const uint32_t part)$/;"	f	class:PartFinder
getPointer	ClauseAllocator.h	/^        inline Clause* getPointer(const uint32_t offset) const$/;"	f	class:ClauseAllocator
getRecvBinData	DataSync.h	/^inline const uint32_t DataSync::getRecvBinData() const$/;"	f	class:DataSync
getRecvUnitData	DataSync.h	/^inline const uint32_t DataSync::getRecvUnitData() const$/;"	f	class:DataSync
getRemoved	Clause.h	/^    const bool getRemoved() const$/;"	f	struct:Clause
getReplaceTable	VarReplacer.h	/^inline const vector<Lit>& VarReplacer::getReplaceTable() const$/;"	f	class:VarReplacer
getReplacingVars	VarReplacer.cpp	/^const vector<Var> VarReplacer::getReplacingVars() const$/;"	f	class:VarReplacer
getReverseTable	PartFinder.h	/^inline const map<uint32_t, vector<Var> >& PartFinder::getReverseTable() const$/;"	f	class:PartFinder
getSavedState	PartHandler.h	/^inline const vec<lbool>& PartHandler::getSavedState()$/;"	f	class:PartHandler
getSentBinData	DataSync.h	/^inline const uint32_t DataSync::getSentBinData() const$/;"	f	class:DataSync
getSentUnitData	DataSync.h	/^inline const uint32_t DataSync::getSentUnitData() const$/;"	f	class:DataSync
getSize	BitArray.h	/^    inline const uint32_t getSize() const$/;"	f	class:BitArray
getSize	PackedMatrix.h	/^    inline const uint32_t getSize() const$/;"	f	class:PackedMatrix
getStrenghtened	Clause.h	/^    const bool getStrenghtened() const$/;"	f	struct:Clause
getTable	PartFinder.h	/^inline const vector<Var>& PartFinder::getTable() const$/;"	f	class:PartFinder
getTotalNumeElems	BoundedQueue.h	/^    uint64_t getTotalNumeElems() const {return totalNumElems;}$/;"	f	class:bqueue
getTotalTime	FailedLitSearcher.h	/^inline const double FailedLitSearcher::getTotalTime() const$/;"	f	class:FailedLitSearcher
getTotalTime	SCCFinder.h	/^inline const double SCCFinder::getTotalTime() const$/;"	f	class:SCCFinder
getTotalTime	Subsumer.h	/^inline const double Subsumer::getTotalTime() const$/;"	f	class:Subsumer
getTotalTime	XorSubsumer.h	/^inline const double XorSubsumer::getTotalTime() const$/;"	f	class:XorSubsumer
getTotalTimeFailedLitSearcher	SolverMisc.cpp	/^const double Solver::getTotalTimeFailedLitSearcher() const$/;"	f	class:Solver
getTotalTimeSCC	SolverMisc.cpp	/^const double Solver::getTotalTimeSCC() const$/;"	f	class:Solver
getTotalTimeSubsumer	SolverMisc.cpp	/^const double Solver::getTotalTimeSubsumer() const$/;"	f	class:Solver
getTotalTimeXorSubsumer	SolverMisc.cpp	/^const double Solver::getTotalTimeXorSubsumer() const$/;"	f	class:Solver
getTwoLongXor	FailedLitSearcher.cpp	/^const FailedLitSearcher::TwoLongXor FailedLitSearcher::getTwoLongXor(const XorClause& c)$/;"	f	class:FailedLitSearcher
getVarElimed	Subsumer.h	/^inline const vec<char>& Subsumer::getVarElimed() const$/;"	f	class:Subsumer
getVarElimed	XorSubsumer.h	/^inline const vec<char>& XorSubsumer::getVarElimed() const$/;"	f	class:XorSubsumer
getVarPart	PartFinder.h	/^inline const uint32_t PartFinder::getVarPart(const Var var) const$/;"	f	class:PartFinder
getVarsetAt	PackedMatrix.h	/^    inline PackedRow getVarsetAt(const uint32_t i)$/;"	f	class:PackedMatrix
getVarsetAt	PackedMatrix.h	/^    inline const PackedRow getVarsetAt(const uint32_t i) const$/;"	f	class:PackedMatrix
getWatchSize	OnlyNonLearntBins.h	/^inline const uint32_t OnlyNonLearntBins::getWatchSize(const Lit lit) const$/;"	f	class:OnlyNonLearntBins
getXorOffset	Watched.h	/^        const ClauseOffset getXorOffset() const$/;"	f	class:Watched
get_called	Gaussian.h	/^inline const uint32_t Gaussian::get_called() const$/;"	f	class:Gaussian
get_disabled	Gaussian.h	/^inline const bool Gaussian::get_disabled() const$/;"	f	class:Gaussian
get_learnts	SolverMisc.cpp	/^const vec<Clause*>& Solver::get_learnts() const$/;"	f	class:Solver
get_sorted_learnts	SolverMisc.cpp	/^const vec<Clause*>& Solver::get_sorted_learnts()$/;"	f	class:Solver
get_sum_gauss_called	Solver.h	/^inline const uint32_t Solver::get_sum_gauss_called() const$/;"	f	class:Solver
get_sum_gauss_confl	Solver.h	/^inline const uint32_t Solver::get_sum_gauss_confl() const$/;"	f	class:Solver
get_sum_gauss_prop	Solver.h	/^inline const uint32_t Solver::get_sum_gauss_prop() const$/;"	f	class:Solver
get_sum_gauss_unit_truths	Solver.h	/^inline const uint32_t Solver::get_sum_gauss_unit_truths() const$/;"	f	class:Solver
get_unit_truths	Gaussian.h	/^inline const uint32_t Gaussian::get_unit_truths() const$/;"	f	class:Gaussian
get_unitary_learnts	SolverMisc.cpp	/^const vector<Lit> Solver::get_unitary_learnts() const$/;"	f	class:Solver
get_unitary_learnts_num	Solver.h	/^inline const uint32_t Solver::get_unitary_learnts_num() const$/;"	f	class:Solver
get_useful_confl	Gaussian.h	/^inline const uint32_t Gaussian::get_useful_confl() const$/;"	f	class:Gaussian
get_useful_prop	Gaussian.h	/^inline const uint32_t Gaussian::get_useful_prop() const$/;"	f	class:Gaussian
getchar	SolverTypes.h	/^    inline char getchar() const {$/;"	f	class:lbool
getmin	BasicHeap.h	/^    int  getmin    ()      { return removeMin(); }$/;"	f	class:BasicHeap
getmin	Heap.h	/^    uint32_t  getmin    ()      { return removeMin(); }$/;"	f	class:Heap
getsum	BoundedQueue.h	/^    int64_t getsum() const {return sumofqueue;}$/;"	f	class:bqueue
globalIndex	SCCFinder.h	/^        uint32_t globalIndex;$/;"	m	class:SCCFinder
glue	Clause.h	/^    uint32_t glue:MAX_GLUE_BITS;    \/\/\/<Clause glue -- clause activity according to GLUCOSE$/;"	m	struct:Clause
glue	Subsumer.h	/^        uint32_t glue;$/;"	m	struct:Subsumer::subsume0Happened
glueHistory	Solver.h	/^    bqueue<uint32_t>    glueHistory;  \/\/\/< Set of last decision levels in (glue of) conflict clauses. Used for dynamic restarting$/;"	m	class:Solver
goodBothSame	FailedLitSearcher.h	/^        uint32_t goodBothSame;  \/\/\/<Records num. of literals that have been propagated to the same value by both "var" and "~var"$/;"	m	class:FailedLitSearcher
greedyUnbound	SolverConf.h	/^        bool      greedyUnbound;      \/\/\/<If set, then variables will be greedily unbounded (set to l_Undef). This is EXPERIMENTAL$/;"	m	class:SolverConf
group	Clause.h	/^    uint32_t group;$/;"	m	struct:Clause
group	FailedLitSearcher.h	/^                uint32_t group;$/;"	m	class:FailedLitSearcher::BinXorToAdd
groupId	DimacsParser.h	/^        uint32_t groupId;$/;"	m	class:DimacsParser
grouping	DimacsParser.h	/^        const bool grouping;$/;"	m	class:DimacsParser
grouping	Main.h	/^        bool grouping;$/;"	m	class:Main
grow	Vec.h	/^void vec<T>::grow(uint32_t min_cap) {$/;"	f	class:vec
growTo	BoundedQueue.h	/^    void growTo(const uint32_t size) {$/;"	f	class:bqueue
growTo	BoxedVec.h	/^    void     growTo (int size)               { while (this->size() < size) push(); }$/;"	f	class:bvec
growTo	BoxedVec.h	/^    void     growTo (int size, const T& pad) { while (this->size() < size) push(pad); }$/;"	f	class:bvec
growTo	DoublePackedRow.h	/^        void growTo(const uint32_t newNumElems)$/;"	f	class:MINISAT::DoublePackedRow
growTo	Vec.h	/^void vec<T>::growTo(uint32_t size) {$/;"	f	class:vec
growTo	Vec.h	/^void vec<T>::growTo(uint32_t size, const T& pad) {$/;"	f	class:vec
handle	PartHandler.cpp	/^const bool PartHandler::handle()$/;"	f	class:PartHandler
handleClBinTouched	Subsumer.cpp	/^const bool Subsumer::handleClBinTouched()$/;"	f	class:Subsumer
handleSATSolution	Solver.cpp	/^void Solver::handleSATSolution()$/;"	f	class:Solver
handleSize1Clause	Subsumer.cpp	/^inline void Subsumer::handleSize1Clause(const Lit lit)$/;"	f	class:Subsumer
handleUNSATSolution	Solver.cpp	/^void Solver::handleUNSATSolution()$/;"	f	class:Solver
handleUpdatedClause	VarReplacer.cpp	/^const bool VarReplacer::handleUpdatedClause(Clause& c, const Lit origLit1, const Lit origLit2, const Lit origLit3)$/;"	f	class:VarReplacer
handleUpdatedClause	VarReplacer.cpp	/^const bool VarReplacer::handleUpdatedClause(XorClause& c, const Var origVar1, const Var origVar2)$/;"	f	class:VarReplacer
handle_conflict	Solver.cpp	/^llbool Solver::handle_conflict(vec<Lit>& learnt_clause, PropBy confl, uint64_t& conflictC, const bool update)$/;"	f	class:Solver
handle_matrix_confl	Gaussian.cpp	/^Gaussian::gaussian_ret Gaussian::handle_matrix_confl(PropBy& confl, const matrixset& m, const uint32_t size, const uint32_t maxlevel, const uint32_t best_row)$/;"	f	class:Gaussian
handle_matrix_prop	Gaussian.cpp	/^Gaussian::gaussian_ret Gaussian::handle_matrix_prop(matrixset& m, const uint32_t row)$/;"	f	class:Gaussian
handle_matrix_prop_and_confl	Gaussian.cpp	/^Gaussian::gaussian_ret Gaussian::handle_matrix_prop_and_confl(matrixset& m, uint32_t last_row, PropBy& confl)$/;"	f	class:Gaussian
hasPrefix	Main.cpp	/^const char* Main::hasPrefix(const char* str, const char* prefix)$/;"	f	class:Main
hash	Map.h	/^    H          hash;$/;"	m	class:Map
hash	MersenneTwister.h	/^inline MTRand::uint32 MTRand::hash( time_t t, clock_t c )$/;"	f	class:MTRand
heap	BasicHeap.h	/^    vec<int> heap;     \/\/ heap of ints$/;"	m	class:BasicHeap
heap	Heap.h	/^    vec<uint32_t> heap;     \/\/ heap of ints$/;"	m	class:Heap
heapProperty	BasicHeap.h	/^    bool heapProperty() {$/;"	f	class:BasicHeap
heapProperty	BasicHeap.h	/^    bool heapProperty(int i) {$/;"	f	class:BasicHeap
heapProperty	Heap.h	/^    bool heapProperty (uint32_t i) const {$/;"	f	class:Heap
heapProperty	Heap.h	/^    bool heapProperty() const {$/;"	f	class:Heap
hiBit	MersenneTwister.h	/^	uint32 hiBit( const uint32& u ) const { return u & 0x80000000UL; }$/;"	f	class:MTRand
hyperBinResolution	FailedLitSearcher.cpp	/^void FailedLitSearcher::hyperBinResolution(const Lit lit)$/;"	f	class:FailedLitSearcher
hyperbinProps	FailedLitSearcher.h	/^        uint64_t hyperbinProps; \/\/\/<Number of bogoprops done by the hyper-binary resolution function hyperBinResolution()$/;"	m	class:FailedLitSearcher
imax	BoxedVec.h	/^    static inline int imax(int x, int y) {$/;"	f	class:bvec
imax	Vec.h	/^    static inline uint32_t imax(int x, int y) {$/;"	f	class:vec
imin	BoxedVec.h	/^    static inline int imin(int x, int y) {$/;"	f	class:bvec
impairSigns	XorFinder.cpp	/^bool XorFinder::impairSigns(const Clause& c) const$/;"	f	class:XorFinder
impliedLit	OnlyNonLearntBins.h	/^            Lit impliedLit;$/;"	m	class:OnlyNonLearntBins::WatchedBin
improvedClauseNo	Solver.h	/^    uint64_t improvedClauseNo; \/\/\/<Num clauses improved using on-the-fly subsumption$/;"	m	class:Solver
improvedClauseSize	Solver.h	/^    uint64_t improvedClauseSize; \/\/\/<Num literals removed using on-the-fly subsumption$/;"	m	class:Solver
in	StreamBuffer.h	/^    FILE *  in;$/;"	m	class:StreamBuffer
inHeap	Heap.h	/^    bool inHeap    (uint32_t n)     const { return n < indices.size() && indices[n] != std::numeric_limits<uint32_t>::max(); }$/;"	f	class:Heap
increase	Heap.h	/^    void increase  (uint32_t n) { decrease(n); }$/;"	f	class:Heap
increase_	Heap.h	/^    void increase_ (uint32_t n) { assert(inHeap(n)); percolateDown(indices[n]); }$/;"	f	class:Heap
index	CSet.h	/^        uint32_t index; \/\/\/<The index of the clause in Subsumer::clauses$/;"	m	class:ClauseSimp
index	Map.h	/^    int32_t index  (const K& k) const { return hash(k) % cap; }$/;"	f	class:Map
index	SCCFinder.h	/^        vector<uint32_t> index;$/;"	m	class:SCCFinder
index	XSet.h	/^        uint32_t index;$/;"	m	class:XorClauseSimp
indices	Heap.h	/^    vec<uint32_t> indices;  \/\/ int -> index in heap$/;"	m	class:Heap
init	Gaussian.cpp	/^void Gaussian::init()$/;"	f	class:Gaussian
initSize	BoundedQueue.h	/^    void initSize(const uint32_t size) {growTo(size);} \/\/ Init size of bounded size queue$/;"	f	class:bqueue
init_size	BoxedVec.h	/^    static const int init_size = 2;$/;"	m	class:bvec
initialiseSolver	Solver.cpp	/^void Solver::initialiseSolver()$/;"	f	class:Solver
initialize	MersenneTwister.h	/^inline void MTRand::initialize( const uint32 seed )$/;"	f	class:MTRand
insert	BasicHeap.h	/^    void insert    (int n)                      { heap.push(n); percolateUp(heap.size()-1); }$/;"	f	class:BasicHeap
insert	Heap.h	/^    void insert(uint32_t n)$/;"	f	class:Heap
insert	Map.h	/^    void insert (const K& k, const D& d) { if (size+1 > cap \/ 2) rehash(); _insert(k, d); size++; }$/;"	f	class:Map
insert	Queue.h	/^    void insert(T x)   { elems.push(x); }$/;"	f	class:Queue
insertVarOrder	Solver.h	/^inline void Solver::insertVarOrder(Var x)$/;"	f	class:Solver
invert	Clause.h	/^    inline void invert(const bool b)$/;"	f	class:XorClause
invert_is_true	PackedRow.h	/^    inline void invert_is_true(const bool b = true)$/;"	f	class:PackedRow
inverted	FailedLitSearcher.h	/^            bool inverted;$/;"	m	class:FailedLitSearcher::TwoLongXor
investigateXor	FailedLitSearcher.h	/^        vec<uint32_t> investigateXor;$/;"	m	class:FailedLitSearcher
isBin	Subsumer.h	/^            bool isBin;$/;"	m	class:Subsumer::ClAndBin
isBinary	PropBy.h	/^        const bool isBinary() const$/;"	f	class:PropBy
isBinary	PropBy.h	/^        const bool isBinary() const$/;"	f	class:PropByFull
isBinary	Watched.h	/^        const bool isBinary() const$/;"	f	class:Watched
isClause	PropBy.h	/^        const bool isClause() const$/;"	f	class:PropBy
isClause	PropBy.h	/^        const bool isClause() const$/;"	f	class:PropByFull
isClause	Watched.h	/^        const bool isClause() const$/;"	f	class:Watched
isDef	DoublePackedRow.h	/^                inline const bool isDef() const {$/;"	f	class:MINISAT::DoublePackedRow::BitIter
isDef	DoublePackedRow.h	/^                inline const bool isDef() const {$/;"	f	class:MINISAT::DoublePackedRow::BitIterConst
isDef	SolverTypes.h	/^    inline const bool isDef() const {$/;"	f	class:lbool
isEqualFalse	FailedLitSearcher.h	/^                bool isEqualFalse;$/;"	m	class:FailedLitSearcher::BinXorToAdd
isFreed	Clause.h	/^    uint32_t isFreed:1; \/\/\/<Has this clause been marked as freed by the ClauseAllocator ?$/;"	m	struct:Clause
isLearnt	Clause.h	/^    uint32_t isLearnt:1; \/\/\/<Is the clause a learnt clause?$/;"	m	struct:Clause
isNULL	PropBy.h	/^        const bool isNULL() const$/;"	f	class:PropBy
isNULL	PropBy.h	/^        const bool isNULL() const$/;"	f	class:PropByFull
isNonLearntBinary	Watched.h	/^        const bool isNonLearntBinary() const$/;"	f	class:Watched
isRemoved	Clause.h	/^    uint32_t isRemoved:1; \/\/\/<Is this clause queued for removal because of usless binary removal?$/;"	m	struct:Clause
isTri	PropBy.h	/^        const bool isTri() const$/;"	f	class:PropBy
isTri	PropBy.h	/^        const bool isTri() const$/;"	f	class:PropByFull
isTriClause	Watched.h	/^        const bool isTriClause() const$/;"	f	class:Watched
isUndef	DoublePackedRow.h	/^                inline const bool isUndef() const {$/;"	f	class:MINISAT::DoublePackedRow::BitIter
isUndef	DoublePackedRow.h	/^                inline const bool isUndef() const {$/;"	f	class:MINISAT::DoublePackedRow::BitIterConst
isUndef	SolverTypes.h	/^    inline const bool isUndef() const {$/;"	f	class:lbool
isXor	Clause.h	/^    const bool isXor()$/;"	f	struct:Clause
isXor	XorFinder.cpp	/^bool XorFinder::isXor(const uint32_t size, const ClauseTable::iterator& begin, const ClauseTable::iterator& end, bool& impair)$/;"	f	class:XorFinder
isXorClause	Clause.h	/^    uint32_t isXorClause:1; \/\/\/< Is the clause an XOR clause?$/;"	m	struct:Clause
isXorClause	Watched.h	/^        const bool isXorClause() const$/;"	f	class:Watched
isXorEqualFalse	Clause.h	/^    uint32_t isXorEqualFalse:1;$/;"	m	struct:Clause
isZero	BitArray.h	/^    inline const bool isZero() const$/;"	f	class:BitArray
isZero	PackedRow.h	/^    inline const bool isZero() const$/;"	f	class:PackedRow
is_true	PackedRow.h	/^    inline const uint64_t& is_true() const$/;"	f	class:PackedRow
is_true_internal	PackedRow.h	/^    uint64_t& is_true_internal;$/;"	m	class:PackedRow
isvalid	BoundedQueue.h	/^    int isvalid() const {return (queuesize==maxsize);}$/;"	f	class:bqueue
it	CSet.h	/^                ClauseSimp* it;$/;"	m	class:CSet::iterator
it	CSet.h	/^                const ClauseSimp* it;$/;"	m	class:CSet::const_iterator
it	XSet.h	/^                XorClauseSimp* it;$/;"	m	class:XSet::iterator
iter_sets	Subsumer.h	/^    vec<CSet* >            iter_sets;      \/\/\/<Sets currently used in iterations.$/;"	m	class:Subsumer
iterativeReduce	GaussianConfig.h	/^    bool iterativeReduce; \/\/Don't minimise matrix work$/;"	m	class:GaussConf
iterator	CSet.h	/^                iterator(ClauseSimp* _it) :$/;"	f	class:CSet::iterator
iterator	CSet.h	/^        class iterator$/;"	c	class:CSet
iterator	PackedMatrix.h	/^        iterator(uint64_t* _mp, const uint32_t _numCols) :$/;"	f	class:PackedMatrix::iterator
iterator	PackedMatrix.h	/^    class iterator$/;"	c	class:PackedMatrix
iterator	XSet.h	/^                iterator(XorClauseSimp* _it) :$/;"	f	class:XSet::iterator
iterator	XSet.h	/^        class iterator$/;"	c	class:XSet
key	Map.h	/^    struct Pair { K key; D data; };$/;"	m	struct:Map::Pair
l_Continue	SolverTypes.h	/^const llbool l_Continue = toLbool(3);$/;"	v
l_False	SolverTypes.h	/^const lbool l_False = toLbool(-1);$/;"	v
l_Nothing	SolverTypes.h	/^const llbool l_Nothing  = toLbool(2);$/;"	v
l_True	SolverTypes.h	/^const lbool l_True  = toLbool( 1);$/;"	v
l_Undef	SolverTypes.h	/^const lbool l_Undef = toLbool( 0);$/;"	v
last	BoundedQueue.h	/^    uint32_t last;$/;"	m	class:bqueue
last	BoxedVec.h	/^    T&       last  (void)                    { return ref->data[ref->sz-1]; }$/;"	f	class:bvec
last	BoxedVec.h	/^    const T& last  (void) const              { return ref->data[ref->sz-1]; }$/;"	f	class:bvec
last	Vec.h	/^    T&       last  (void)              { return data[sz-1]; }$/;"	f	class:vec
last	Vec.h	/^    const T& last  (void) const        { return data[sz-1]; }$/;"	f	class:vec
lastDecisionLevel	Solver.h	/^    vec<Var>            lastDecisionLevel;$/;"	m	class:Solver
lastNbBin	Solver.h	/^    uint64_t lastNbBin; \/\/\/<Last time we seached for SCCs, numBins was this much$/;"	m	class:Solver
lastNumUnitaryClean	ClauseCleaner.h	/^        uint32_t lastNumUnitaryClean[6]; \/\/\/<Last time we cleaned from satisfied clauses&false literals, this many unitary clauses were known$/;"	m	class:ClauseCleaner
lastNumUnitarySat	ClauseCleaner.h	/^        uint32_t lastNumUnitarySat[6]; \/\/\/<Last time we cleaned from satisfied clauses, this many unitary clauses were known$/;"	m	class:ClauseCleaner
lastReplacedVars	VarReplacer.h	/^        uint32_t lastReplacedVars; \/\/\/<Last time performReplace() was called, "replacedVars" contained this$/;"	m	class:VarReplacer
lastSearchForBinaryXor	Solver.h	/^    uint64_t lastSearchForBinaryXor; \/\/\/<Last time we looked for binary xors, this many bogoprops(=propagations) has been done$/;"	m	class:Solver
lastSelectedRestartType	Solver.h	/^    RestartType lastSelectedRestartType; \/\/\/<The last selected restart type. Used when we are just after a full restart, and need to know how to really act$/;"	m	class:Solver
lastSyncConf	DataSync.h	/^        uint64_t lastSyncConf;$/;"	m	class:DataSync
lastTimeFoundTruths	FailedLitSearcher.h	/^        uint32_t lastTimeFoundTruths; \/\/\/<Records how many unit clauses we found last time we called search()$/;"	m	class:FailedLitSearcher
lastTimeStopped	FailedLitSearcher.h	/^        uint32_t lastTimeStopped;$/;"	m	class:FailedLitSearcher
lastTimeWentUntil	ClauseVivifier.h	/^        uint32_t lastTimeWentUntil;$/;"	m	class:ClauseVivifier
lastTrailSize	FailedLitSearcher.h	/^        uint32_t lastTrailSize;$/;"	m	class:FailedLitSearcher
last_one_in_col	Gaussian.h	/^        vector<uint16_t> last_one_in_col; \/\/last_one_in_col[COL] tells the last row+1 that has a '1' in that column. Used to reduce the burden of Gauss elim. (it only needs to look until that row)$/;"	m	class:Gaussian::matrixset
lbool	SolverTypes.h	/^    explicit lbool(char v) : value(v) { }$/;"	f	class:lbool
lbool	SolverTypes.h	/^    lbool()       : value(0) { };$/;"	f	class:lbool
lbool	SolverTypes.h	/^class lbool$/;"	c
lbool	SolverTypes.h	/^lbool::lbool(llbool b) : value(b.value) {};$/;"	f	class:lbool
lbool_to_string	Gaussian.cpp	/^const string Gaussian::lbool_to_string(const lbool toprint)$/;"	f	class:Gaussian
learnt	Clause.h	/^    const bool learnt() const$/;"	f	struct:Clause
learnt	Subsumer.h	/^            const bool learnt;$/;"	m	class:Subsumer::NewBinaryClause
learntBins	CompleteDetachReattacher.h	/^                uint32_t learntBins;$/;"	m	class:CompleteDetachReatacher::ClausesStay
learntLeadHere	SolverTypes.h	/^    bool learntLeadHere;$/;"	m	struct:BinPropData
learnt_clause_group	Solver.h	/^    uint32_t learnt_clause_group;       \/\/the group number of learnt clauses. Incremented at each added learnt clause$/;"	m	class:Solver
learnts	ClauseCleaner.h	/^        enum ClauseSetType {clauses, binaryClauses, xorclauses, learnts};$/;"	e	enum:ClauseCleaner::ClauseSetType
learnts	Solver.h	/^    vec<Clause*>        learnts;          \/\/\/< List of learnt clauses.$/;"	m	class:Solver
learntsFilename	SolverConf.h	/^        std::string learntsFilename;    \/\/\/<Dump sorted learnt clauses to this file. Only active if "needToDumpLearnts" is set to TRUE$/;"	m	class:SolverConf
learnts_literals	Solver.h	/^    uint64_t clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Solver
learntsize_factor	SolverConf.h	/^        double    learntsize_factor;  \/\/\/<The intitial limit for learnt clauses is a factor of the original clauses.                (default 1 \/ 3)$/;"	m	class:SolverConf
learntsize_inc	SolverConf.h	/^        double    learntsize_inc;     \/\/\/<The limit for learnt clauses is multiplied with this factor each restart.                 (default 1.1)$/;"	m	class:SolverConf
least_column_changed	Gaussian.h	/^        int least_column_changed; \/\/ when updating the matrix, this value contains the smallest column number that has been updated  (Gauss elim. can start from here instead of from column 0)$/;"	m	class:Gaussian::matrixset
left	BasicHeap.h	/^    static inline int left  (int i) { return i*2+1; }$/;"	f	class:BasicHeap
left	Heap.h	/^    static inline uint32_t left  (uint32_t i) { return i*2+1; }$/;"	f	class:Heap
left	MersenneTwister.h	/^	int left;          \/\/ number of values left before reload needed$/;"	m	class:MTRand
lev	SolverTypes.h	/^    uint32_t lev;$/;"	m	struct:BinPropData
lev2Ancestor	SolverTypes.h	/^    Lit lev2Ancestor;$/;"	m	struct:BinPropData
level	Solver.h	/^    vec<int32_t>        level;            \/\/\/< 'level[var]' contains the level at which the assignment was made.$/;"	m	class:Solver
libraryCNFFile	Solver.h	/^    FILE     *libraryCNFFile;           \/\/The file that all calls from the library are logged$/;"	m	class:Solver
libraryUsage	SolverConf.h	/^        bool      libraryUsage;       \/\/\/<Set to true if not used as a library. In fact, this is TRUE by default, and Main.cpp sets it to "FALSE". Disables some simplifications at the beginning of solving (mostly performStepsBeforeSolve() )$/;"	m	class:SolverConf
limit	RestartTypeChooser.h	/^        const uint32_t limit; \/\/\/<If top x contains on average this many common varables, we select MiniSat-type$/;"	m	class:RestartTypeChooser
linkInAlreadyClause	XorSubsumer.cpp	/^void XorSubsumer::linkInAlreadyClause(XorClauseSimp& c)$/;"	f	class:XorSubsumer
linkInClause	Subsumer.cpp	/^ClauseSimp Subsumer::linkInClause(Clause& cl)$/;"	f	class:Subsumer
linkInClause	XorSubsumer.cpp	/^XorClauseSimp XorSubsumer::linkInClause(XorClause& cl)$/;"	f	class:XorSubsumer
lit	Solver.h	/^            Lit lit;$/;"	m	class:Solver::LitReachData
lit1	FailedLitSearcher.h	/^                Lit lit1;$/;"	m	class:FailedLitSearcher::BinXorToAdd
lit1	Subsumer.h	/^            Lit lit1;$/;"	m	class:Subsumer::ClAndBin
lit1	Subsumer.h	/^            const Lit lit1;$/;"	m	class:Subsumer::NewBinaryClause
lit2	FailedLitSearcher.h	/^                Lit lit2;$/;"	m	class:FailedLitSearcher::BinXorToAdd
lit2	Subsumer.h	/^            Lit lit2;$/;"	m	class:Subsumer::ClAndBin
lit2	Subsumer.h	/^            const Lit lit2;$/;"	m	class:Subsumer::NewBinaryClause
litReachable	Solver.h	/^    vector<LitReachData>litReachable;$/;"	m	class:Solver
litRedundant	Solver.cpp	/^bool Solver::litRedundant(Lit p, uint32_t abstract_levels)$/;"	f	class:Solver
literals_removed	Subsumer.h	/^    uint32_t literals_removed; \/\/\/<Number of literals removed from clauses through self-subsuming resolution in this run$/;"	m	class:Subsumer
lits	DimacsParser.h	/^        vec<Lit> lits; \/\/\/<To reduce temporary creation overhead$/;"	m	class:DimacsParser
lits	PropBy.h	/^        Lit lits[3];$/;"	m	class:PropByFull
lits	Solver.h	/^            vector<Lit> lits;$/;"	m	class:Solver::TransCache
lits	XorSubsumer.h	/^        vector<Lit> lits;$/;"	m	struct:XorSubsumer::XorElimedClause
llbool	SolverTypes.h	/^    llbool(): value(0) {};$/;"	f	class:llbool
llbool	SolverTypes.h	/^    llbool(char a) :$/;"	f	class:llbool
llbool	SolverTypes.h	/^    llbool(lbool v) :$/;"	f	class:llbool
llbool	SolverTypes.h	/^class llbool$/;"	c
loBit	MersenneTwister.h	/^	uint32 loBit( const uint32& u ) const { return u & 0x00000001UL; }$/;"	f	class:MTRand
loBits	MersenneTwister.h	/^	uint32 loBits( const uint32& u ) const { return u & 0x7fffffffUL; }$/;"	f	class:MTRand
load	MersenneTwister.h	/^inline void MTRand::load( uint32 *const loadArray )$/;"	f	class:MTRand
localSubstitute	XorSubsumer.cpp	/^const bool XorSubsumer::localSubstitute()$/;"	f	class:XorSubsumer
localSubstituteUseful	XorSubsumer.h	/^    uint32_t localSubstituteUseful;$/;"	m	class:XorSubsumer
locked	Solver.h	/^inline bool Solver::locked(const Clause& c) const$/;"	f	class:Solver
logLit	Solver.h	/^static inline void logLit(FILE* f, Lit l)$/;"	f
logLits	Solver.h	/^static inline void logLits(FILE* f, const vec<Lit>& ls)$/;"	f
logger	Solver.h	/^    Logger   logger;                     \/\/ dynamic logging, statistics$/;"	m	class:Solver
lowlink	SCCFinder.h	/^        vector<uint32_t> lowlink;$/;"	m	class:SCCFinder
lt	BasicHeap.h	/^    Comp     lt;$/;"	m	class:BasicHeap
lt	Heap.h	/^    Comp     lt;$/;"	m	class:Heap
makeLearnt	Clause.h	/^    void makeLearnt(const uint32_t newGlue, const float newMiniSatAct)$/;"	f	struct:Clause
makeNonLearnt	Clause.h	/^    void makeNonLearnt()$/;"	f	struct:Clause
makeNonLearntBin	Subsumer.cpp	/^void Subsumer::makeNonLearntBin(const Lit lit1, const Lit lit2, const bool learnt)$/;"	f	class:Subsumer
match	DimacsParser.cpp	/^bool DimacsParser::match(StreamBuffer& in, const char* str)$/;"	f	class:DimacsParser
matrix	Gaussian.h	/^        PackedMatrix matrix; \/\/ The matrix, updated to reflect variable assignements$/;"	m	class:Gaussian::matrixset
matrixFinder	Solver.h	/^    MatrixFinder*       matrixFinder;$/;"	m	class:Solver
matrix_no	Gaussian.h	/^    const uint32_t matrix_no;$/;"	m	class:Gaussian
matrix_no	MatrixFinder.h	/^        uint32_t matrix_no;$/;"	m	class:MatrixFinder
matrix_sets	Gaussian.h	/^    vector<matrixset> matrix_sets; \/\/ The matrixsets for depths 'decision_from' + 0,  'decision_from' + only_nth_gaussian_save, 'decision_from' + 2*only_nth_gaussian_save, ... 'decision_from' + 'decision_until'.$/;"	m	class:Gaussian
matrixset	Gaussian.h	/^    class matrixset$/;"	c	class:Gaussian
maxDumpLearntsSize	SolverConf.h	/^        uint32_t  maxDumpLearntsSize; \/\/\/<When dumping the learnt clauses, this is the maximum clause size that should be dumped$/;"	m	class:SolverConf
maxGlue	SolverConf.h	/^        uint32_t  maxGlue;            \/\/\/< Learnt clauses (when doing dynamic restarts) with glue above this value will be removed immediately on backtracking$/;"	m	class:SolverConf
maxHyperBinProps	FailedLitSearcher.h	/^        uint64_t maxHyperBinProps;$/;"	m	class:FailedLitSearcher
maxMatrixRows	GaussianConfig.h	/^    uint32_t maxMatrixRows; \/\/The maximum matrix size -- no. of rows$/;"	m	class:GaussConf
maxNumMatrixes	GaussianConfig.h	/^    uint32_t maxNumMatrixes; \/\/Maximum number of matrixes$/;"	m	class:GaussConf
maxRestarts	SolverConf.h	/^        uint32_t  maxRestarts;$/;"	m	class:SolverConf
maxSizes	ClauseAllocator.h	/^        vec<size_t> maxSizes; \/\/\/<The number of 32-bit datapieces allocated in each stack$/;"	m	class:ClauseAllocator
max_literals	Solver.h	/^    uint64_t clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Solver
max_nr_of_solutions	Main.h	/^        uint32_t max_nr_of_solutions;$/;"	m	class:Main
maxsize	BoundedQueue.h	/^    uint32_t maxsize;$/;"	m	class:bqueue
maybeEliminate	Subsumer.cpp	/^bool Subsumer::maybeEliminate(const Var var)$/;"	f	class:Subsumer
maybeRemove	Subsumer.h	/^void maybeRemove(vec<T>& ws, const T2& elem)$/;"	f
memReadStat	time_mem.h	/^static inline int memReadStat(int field)$/;"	f
memUsed	time_mem.h	/^static inline uint64_t memUsed()$/;"	f
memUsed	time_mem.h	/^static inline uint64_t memUsed(void)$/;"	f
merge	Subsumer.cpp	/^bool Subsumer::merge(const ClAndBin& ps, const ClAndBin& qs, const Lit without_p, const Lit without_q, vec<Lit>& out_clause)$/;"	f	class:Subsumer
messed_matrix_vars_since_reversal	Gaussian.h	/^    bool messed_matrix_vars_since_reversal;$/;"	m	class:Gaussian
minMatrixRows	GaussianConfig.h	/^    uint32_t minMatrixRows; \/\/The minimum matrix size -- no. of rows$/;"	m	class:GaussConf
miniSatAct	Clause.h	/^    float miniSatAct; \/\/\/<Clause activity according to MiniSat$/;"	m	struct:Clause
minimiseLeartFurther	Solver.cpp	/^void Solver::minimiseLeartFurther(vec<Lit>& cl, const uint32_t glue)$/;"	f	class:Solver
mixBits	MersenneTwister.h	/^	uint32 mixBits( const uint32& u, const uint32& v ) const$/;"	f	class:MTRand
model	Solver.h	/^    vec<lbool> model;             \/\/\/<If problem is satisfiable, this vector contains the model (if any).$/;"	m	class:Solver
modelValue	Solver.h	/^inline lbool    Solver::modelValue    (const Lit p) const$/;"	f	class:Solver
moreRecurMinLDo	Solver.h	/^    uint64_t moreRecurMinLDo; \/\/\/<Decided to carry out transitive on-the-fly self-subsuming resolution on this many clauses$/;"	m	class:Solver
moveBinClauses	PartHandler.cpp	/^void PartHandler::moveBinClauses(Solver& newSolver, const uint32_t part, PartFinder& partFinder)$/;"	f	class:PartHandler
moveClauses	PartHandler.cpp	/^void PartHandler::moveClauses(vec<Clause*>& cs, Solver& newSolver, const uint32_t part, PartFinder& partFinder)$/;"	f	class:PartHandler
moveClauses	PartHandler.cpp	/^void PartHandler::moveClauses(vec<XorClause*>& cs, Solver& newSolver, const uint32_t part, PartFinder& partFinder)$/;"	f	class:PartHandler
moveLearntClauses	PartHandler.cpp	/^void PartHandler::moveLearntClauses(vec<Clause*>& cs, Solver& newSolver, const uint32_t part, PartFinder& partFinder)$/;"	f	class:PartHandler
moveTo	BoxedVec.h	/^    void moveTo(altvec<T>& dest) { dest.clear(true); dest.ref = ref; ref = NULL; }$/;"	f	class:bvec
moveTo	Vec.h	/^    void moveTo(vec<T>& dest) { dest.clear(true); dest.data = data; dest.sz = sz; dest.cap = cap; data = NULL; sz = 0; cap = 0; }$/;"	f	class:vec
moveVariablesBetweenSolvers	PartHandler.cpp	/^void PartHandler::moveVariablesBetweenSolvers(Solver& newSolver, vector<Var>& vars, const uint32_t part, const PartFinder& partFinder)$/;"	f	class:PartHandler
mp	BitArray.h	/^    uint64_t* mp;$/;"	m	class:BitArray
mp	DoublePackedRow.h	/^        unsigned char *mp;$/;"	m	class:MINISAT::DoublePackedRow
mp	PackedMatrix.h	/^        uint64_t* mp;$/;"	m	class:PackedMatrix::iterator
mp	PackedMatrix.h	/^    uint64_t* mp;$/;"	m	class:PackedMatrix
mp	PackedRow.h	/^    uint64_t* __restrict const mp;$/;"	m	class:PackedRow
mtrand	Solver.h	/^    MTRand              mtrand;           \/\/\/< random number generator$/;"	m	class:Solver
multiLevelProp	Solver.h	/^    bool     multiLevelProp;$/;"	m	class:Solver
multiThreadSolve	Main.cpp	/^const int Main::multiThreadSolve()$/;"	f	class:Main
myComp	Subsumer.h	/^    struct myComp {$/;"	s	class:Subsumer
myCopy	Vec.h	/^void vec<T>::myCopy(const vec<T>& other) {$/;"	f	class:vec
myImpliesSet	FailedLitSearcher.h	/^        vec<Var> myImpliesSet; \/\/\/<variables set in myimplies$/;"	m	class:FailedLitSearcher
mySize	Clause.h	/^    uint32_t mySize:19; \/\/\/<The current size of the clause$/;"	m	struct:Clause
mysorter	MatrixFinder.h	/^        struct mysorter$/;"	s	class:MatrixFinder
mysorter	PartFinder.h	/^        struct mysorter$/;"	s	class:PartFinder
nAssigns	Solver.h	/^inline uint32_t      Solver::nAssigns      ()      const$/;"	f	class:Solver
nClauses	Solver.h	/^inline uint32_t      Solver::nClauses      ()      const$/;"	f	class:Solver
nElems	CSet.h	/^        uint32_t nElems(void) const { return which.size() - free.size(); }$/;"	f	class:CSet
nElems	XSet.h	/^        uint32_t nElems(void) const { return which.size() - free.size(); }$/;"	f	class:XSet
nLearnts	Solver.h	/^inline uint32_t      Solver::nLearnts      ()      const$/;"	f	class:Solver
nLiterals	Solver.h	/^inline uint32_t      Solver::nLiterals      ()      const$/;"	f	class:Solver
nVars	Solver.cpp	/^uint32_t      Solver::nVars         ()      const$/;"	f	class:Solver
nbClBeforeRed	Solver.h	/^    uint32_t  nbClBeforeRed;        \/\/\/< Number of learnt clauses before learnt-clause cleaning$/;"	m	class:Solver
nbClOverMaxGlue	Solver.h	/^    uint64_t nbClOverMaxGlue; \/\/\/<Number or clauses over maximum glue defined in maxGlue$/;"	m	class:Solver
nbCompensateSubsumer	Solver.h	/^    uint32_t  nbCompensateSubsumer; \/\/\/< Number of learnt clauses that subsumed normal clauses last time subs. was executed (used to delay learnt clause-cleaning)$/;"	m	class:Solver
nbGlue2	Solver.h	/^    uint64_t nbGlue2; \/\/\/<Num learnt clauses that had a glue of 2 when created$/;"	m	class:Solver
nbReduceDB	Solver.h	/^    uint64_t nbReduceDB; \/\/\/<Number of times learnt clause have been cleaned$/;"	m	class:Solver
needLibraryCNFFile	SolverMisc.cpp	/^void Solver::needLibraryCNFFile(const std::string& fileName)$/;"	f	class:Solver
needProofGraph	Solver.h	/^inline void     Solver::needProofGraph()$/;"	f	class:Solver
needStats	Solver.h	/^inline void     Solver::needStats()$/;"	f	class:Solver
needToDumpLearnts	SolverConf.h	/^        bool      needToDumpLearnts;  \/\/\/<If set to TRUE, learnt clauses will be dumped to the file speified by "learntsFilename"$/;"	m	class:SolverConf
needToDumpOrig	SolverConf.h	/^        bool      needToDumpOrig;     \/\/\/<If set to TRUE, a simplified version of the original clause-set will be dumped to the file speified by "origFilename". The solution to this file should perfectly satisfy the problem$/;"	m	class:SolverConf
needToInterrupt	Solver.h	/^    bool      needToInterrupt;    \/\/\/<Used internally mostly. If set to TRUE, we will interrupt cleanly ASAP. The important thing is "cleanly", since we need to wait until a point when all datastructures are in a sane state (i.e. not in the middle of some algorithm)$/;"	m	class:Solver
needToVisit	FailedLitSearcher.h	/^        BitArray needToVisit;$/;"	m	class:FailedLitSearcher
needsReplace	VarReplacer.h	/^inline const bool VarReplacer::needsReplace()$/;"	f	class:VarReplacer
newBinClauses	DataSync.h	/^        vector<std::pair<Lit, Lit> > newBinClauses;$/;"	m	class:DataSync
newBinXor	FailedLitSearcher.h	/^        uint32_t newBinXor;$/;"	m	class:FailedLitSearcher
newDecisionLevel	Solver.h	/^inline void     Solver::newDecisionLevel()$/;"	f	class:Solver
newOffset	ClauseAllocator.h	/^            uint32_t newOffset; \/\/\/<The new offset where the clause now resides$/;"	m	struct:ClauseAllocator::NewPointerAndOffset
newPointer	ClauseAllocator.h	/^            Clause* newPointer; \/\/\/<The new place$/;"	m	struct:ClauseAllocator::NewPointerAndOffset
newVar	DataSync.cpp	/^void DataSync::newVar()$/;"	f	class:DataSync
newVar	PartHandler.h	/^inline void PartHandler::newVar()$/;"	f	class:PartHandler
newVar	Solver.cpp	/^Var Solver::newVar(bool dvar)$/;"	f	class:Solver
newVar	Subsumer.h	/^inline void Subsumer::newVar()$/;"	f	class:Subsumer
newVar	VarReplacer.cpp	/^void VarReplacer::newVar()$/;"	f	class:VarReplacer
newVar	XorSubsumer.h	/^inline void XorSubsumer::newVar()$/;"	f	class:XorSubsumer
new_decision	Solver.cpp	/^llbool Solver::new_decision(const uint64_t nof_conflicts, const uint64_t nof_conflicts_fullrestart, const uint64_t conflictC)$/;"	f	class:Solver
nextSize	BoxedVec.h	/^    static int   nextSize (int current) { return (current * 3 + 1) >> 1; }$/;"	f	class:bvec
noMatrixFind	GaussianConfig.h	/^    bool noMatrixFind; \/\/Put all xor-s into one matrix, don't find matrixes$/;"	m	class:GaussConf
nonLearntBins	CompleteDetachReattacher.h	/^                uint32_t nonLearntBins;$/;"	m	class:CompleteDetachReatacher::ClausesStay
normClauseIsAttached	SolverDebug.cpp	/^const bool Solver::normClauseIsAttached(const Clause& c) const$/;"	f	class:Solver
nothing	Gaussian.h	/^    enum gaussian_ret {conflict, unit_conflict, propagation, unit_propagation, nothing};$/;"	e	enum:Gaussian::gaussian_ret
nothing_to_propagate	Gaussian.cpp	/^const bool Gaussian::nothing_to_propagate(matrixset& m) const$/;"	f	class:Gaussian
nprimes	Map.h	/^static const int nprimes          = 25;$/;"	v
numBins	Solver.h	/^    uint32_t            numBins;$/;"	m	class:Solver
numCalls	ClauseVivifier.h	/^        uint32_t numCalls;$/;"	m	class:ClauseVivifier
numCalls	FailedLitSearcher.h	/^        uint32_t numCalls; \/\/\/<Number of times search() has been called$/;"	m	class:FailedLitSearcher
numCalls	Subsumer.h	/^    uint32_t numCalls;         \/\/\/<Number of times simplifyBySubsumption() has been called$/;"	m	class:Subsumer
numCleanedLearnts	Solver.h	/^    uint64_t  numCleanedLearnts;    \/\/\/< Number of times learnt clauses have been removed through simplify() up until now$/;"	m	class:Solver
numCols	PackedMatrix.h	/^        const uint32_t numCols;$/;"	m	class:PackedMatrix::iterator
numCols	PackedMatrix.h	/^    uint32_t numCols;$/;"	m	class:PackedMatrix
numElems	DoublePackedRow.h	/^        Var numElems;$/;"	m	class:MINISAT::DoublePackedRow
numElimed	Subsumer.h	/^    uint32_t numElimed;                    \/\/\/<Total number of variables eliminated$/;"	m	class:Subsumer
numElimed	XorSubsumer.h	/^    uint32_t numElimed;$/;"	m	class:XorSubsumer
numFailed	FailedLitSearcher.h	/^        uint32_t numFailed;     \/\/\/<Records num. of failed literals during search()$/;"	m	class:FailedLitSearcher
numInCache	Solver.h	/^            uint32_t numInCache;$/;"	m	class:Solver::LitReachData
numLearntClauses	DimacsParser.h	/^        uint32_t numLearntClauses; \/\/\/<Number of learnt non-xor clauses added$/;"	m	class:DimacsParser
numMaxBlockToVisit	Subsumer.h	/^    int64_t numMaxBlockToVisit;           \/\/\/<Max. number variable-blocking clauses to visit to do this run$/;"	m	class:Subsumer
numMaxBlockVars	Subsumer.h	/^    uint32_t numMaxBlockVars;             \/\/\/<Max. number variable-blocking tries to do this run$/;"	m	class:Subsumer
numMaxElim	Subsumer.h	/^    int64_t numMaxElim;                  \/\/\/<Max. number of variable elimination tries to do this run$/;"	m	class:Subsumer
numMaxElimVars	Subsumer.h	/^    uint32_t numMaxElimVars;$/;"	m	class:Subsumer
numMaxSubsume0	Subsumer.h	/^    int64_t numMaxSubsume0;              \/\/\/<Max. number backward-subsumption tries to do this run$/;"	m	class:Subsumer
numMaxSubsume1	Subsumer.h	/^    int64_t numMaxSubsume1;              \/\/\/<Max. number self-subsuming resolution tries to do this run$/;"	m	class:Subsumer
numNewBin	Solver.h	/^    uint64_t numNewBin; \/\/\/<new binary clauses that have been found through some form of resolution (shrinking, conflicts, etc.)$/;"	m	class:Solver
numNonLearntBins	Subsumer.cpp	/^const uint32_t Subsumer::numNonLearntBins(const Lit lit) const$/;"	f	class:Subsumer
numNormClauses	DimacsParser.h	/^        uint32_t numNormClauses; \/\/\/<Number of non-learnt, non-xor claues added$/;"	m	class:DimacsParser
numPropsMultiplier	FailedLitSearcher.h	/^        double numPropsMultiplier; \/\/\/<If last time we called search() all went fine, then this is incremented, so we do more searching this time$/;"	m	class:FailedLitSearcher
numRows	PackedMatrix.h	/^    uint32_t numRows;$/;"	m	class:PackedMatrix
numShrinkedClause	Solver.h	/^    uint64_t numShrinkedClause; \/\/\/<Num clauses improved using on-the-fly self-subsuming resolution$/;"	m	class:Solver
numShrinkedClauseLits	Solver.h	/^    uint64_t numShrinkedClauseLits; \/\/\/<Num literals removed by on-the-fly self-subsuming resolution$/;"	m	class:Solver
numThreads	Main.h	/^        int numThreads;$/;"	m	class:Main
numVarsElimed	Subsumer.h	/^    uint32_t numVarsElimed;               \/\/\/<Number of variables elimed in this run$/;"	m	class:Subsumer
numXorClauses	DimacsParser.h	/^        uint32_t numXorClauses; \/\/\/<Number of non-learnt xor clauses added$/;"	m	class:DimacsParser
num_cols	Gaussian.h	/^        uint32_t num_cols; \/\/ number of active columns in the matrix. The columns at the end that have all be zeroed are no longer active$/;"	m	class:Gaussian::matrixset
num_rows	Gaussian.h	/^        uint16_t num_rows; \/\/ number of active rows in the matrix. Unactive rows are rows that contain only zeros (and if they are conflicting, then the conflict has been treated)$/;"	m	class:Gaussian::matrixset
numblockedClauseRemoved	Subsumer.h	/^    uint32_t numblockedClauseRemoved;$/;"	m	class:Subsumer
occur	FailedLitSearcher.h	/^        vector<vector<uint32_t> > occur; \/\/\/<Occurence list for XORs. Indexed by variables$/;"	m	class:FailedLitSearcher
occur	Subsumer.h	/^    vec<vec<ClauseSimp> >  occur;          \/\/\/<occur[index(lit)]' is a list of constraints containing 'lit'.$/;"	m	class:Subsumer
occur	XorSubsumer.h	/^    vec<vec<XorClauseSimp> >  occur;          \/\/ 'occur[index(lit)]' is a list of constraints containing 'lit'.$/;"	m	class:XorSubsumer
occurnum	Subsumer.h	/^            uint32_t occurnum;$/;"	m	class:Subsumer::VarOcc
offset	DoublePackedRow.h	/^                const uint32_t offset;$/;"	m	class:MINISAT::DoublePackedRow::BitIter
offset	DoublePackedRow.h	/^                const uint32_t offset;$/;"	m	class:MINISAT::DoublePackedRow::BitIterConst
ok	Solver.h	/^    bool                ok;               \/\/\/< If FALSE, the constraints are already unsatisfiable. No part of the solver state may be used!$/;"	m	class:Solver
okay	Solver.h	/^inline bool     Solver::okay          ()      const$/;"	f	class:Solver
ol_seenNeg	Subsumer.h	/^    vec<char> ol_seenNeg;$/;"	m	class:Subsumer
ol_seenPos	Subsumer.h	/^    vec<char> ol_seenPos;$/;"	m	class:Subsumer
oldPolarity	Solver.h	/^    vector<bool> oldPolarity;   \/\/ The polarity before the last setting. Good for unsetting polairties that have been changed since the last conflict$/;"	m	class:Solver
oneHopAway	UselessBinRemover.h	/^        vec<Lit> oneHopAway; \/\/\/<Lits that are one hop away from selected lit (sometimes called origLit)$/;"	m	class:UselessBinRemover
oneThreadSolve	Main.cpp	/^const int Main::oneThreadSolve()$/;"	f	class:Main
only_nth_gauss_save	GaussianConfig.h	/^    uint32_t only_nth_gauss_save;  \/\/save only every n-th gauss matrix$/;"	m	class:GaussConf
openOutputFile	Main.cpp	/^FILE* Main::openOutputFile()$/;"	f	class:Main
operator !=	CSet.h	/^                const bool operator!=(const const_iterator& iter) const$/;"	f	class:CSet::const_iterator
operator !=	CSet.h	/^                const bool operator!=(const iterator& iter) const$/;"	f	class:CSet::iterator
operator !=	DoublePackedRow.h	/^                inline const bool operator!=(lbool b) const {$/;"	f	class:MINISAT::DoublePackedRow::BitIter
operator !=	DoublePackedRow.h	/^                inline const bool operator!=(lbool b) const {$/;"	f	class:MINISAT::DoublePackedRow::BitIterConst
operator !=	PackedMatrix.h	/^        const bool operator!=(const iterator& it) const$/;"	f	class:PackedMatrix::iterator
operator !=	PackedRow.cpp	/^bool PackedRow::operator !=(const PackedRow& b) const$/;"	f	class:PackedRow
operator !=	SolverTypes.h	/^    bool operator!= (const Lit& p) const {$/;"	f	class:Lit
operator !=	SolverTypes.h	/^    inline const bool operator!=(const llbool& v) const {$/;"	f	class:llbool
operator !=	SolverTypes.h	/^    inline const bool operator!=(lbool b) const {$/;"	f	class:lbool
operator !=	XSet.h	/^                const bool operator!=(const iterator& iter) const$/;"	f	class:XSet::iterator
operator &=	BitArray.h	/^    BitArray& operator&=(const BitArray& b)$/;"	f	class:BitArray
operator ()	ClauseVivifier.h	/^            const bool operator () (const Clause* x, const Clause* y)$/;"	f	struct:ClauseVivifier::sortBySize
operator ()	FailedLitSearcher.h	/^            const bool operator () (const Lit x, const Lit y) const$/;"	f	struct:FailedLitSearcher::LitOrder2
operator ()	Map.h	/^template<class K> struct DeepEqual { bool     operator()(const K* k1, const K* k2) const { return *k1 == *k2; } };$/;"	f	struct:DeepEqual
operator ()	Map.h	/^template<class K> struct DeepHash  { uint32_t operator()(const K* k)               const { return hash(*k);  } };$/;"	f	struct:DeepHash
operator ()	Map.h	/^template<class K> struct Equal { bool     operator()(const K& k1, const K& k2) const { return k1 == k2; } };$/;"	f	struct:Equal
operator ()	Map.h	/^template<class K> struct Hash  { uint32_t operator()(const K& k)               const { return hash(k);  } };$/;"	f	struct:Hash
operator ()	MatrixFinder.h	/^            bool operator () (const pair<uint32_t, uint32_t>& left, const pair<uint32_t, uint32_t>& right)$/;"	f	struct:MatrixFinder::mysorter
operator ()	MersenneTwister.h	/^	double operator()() { return rand(); }  \/\/ same as rand()$/;"	f	class:MTRand
operator ()	PartFinder.h	/^            bool operator () (const pair<uint32_t, uint32_t>& left, const pair<uint32_t, uint32_t>& right)$/;"	f	struct:PartFinder::mysorter
operator ()	PartHandler.h	/^            bool operator()(const std::pair<int,int> &left, const std::pair<int,int> &right) {$/;"	f	struct:PartHandler::sort_pred
operator ()	Solver.cpp	/^bool  reduceDB_ltGlucose::operator () (const Clause* x, const Clause* y) {$/;"	f	class:reduceDB_ltGlucose
operator ()	Solver.cpp	/^bool  reduceDB_ltMiniSat::operator () (const Clause* x, const Clause* y) {$/;"	f	class:reduceDB_ltMiniSat
operator ()	Solver.h	/^        bool operator () (Var x, Var y) const {$/;"	f	struct:Solver::VarOrderLt
operator ()	Solver.h	/^        bool operator()(Var v) const {$/;"	f	struct:Solver::VarFilter
operator ()	Subsumer.h	/^        bool operator () (const std::pair<int, Var>& x, const std::pair<int, Var>& y) {$/;"	f	struct:Subsumer::myComp
operator ()	Subsumer.h	/^        const bool operator () (const Clause* x, const Clause* y)$/;"	f	struct:Subsumer::sortBySize
operator ()	Subsumer.h	/^        const bool operator() (const VarOcc& l1, const VarOcc& l2) const {$/;"	f	struct:Subsumer::MyComp
operator ()	Subsumer.h	/^        const bool operator()(const Watched& first, const Watched& second)$/;"	f	struct:Subsumer::BinSorter
operator ()	Subsumer.h	/^        const bool operator()(const Watched& first, const Watched& second)$/;"	f	struct:Subsumer::BinSorter2
operator ()	Watched.h	/^inline bool  WatchedSorter::operator () (const Watched& x, const Watched& y)$/;"	f	class:WatchedSorter
operator ()	XorFinder.h	/^            bool operator()(const pair<Clause*, uint32_t>& c11, const pair<Clause*, uint32_t>& c22) const$/;"	f	struct:XorFinder::clause_sorter_secondary
operator ()	XorFinder.h	/^            bool operator()(const pair<Clause*, uint32_t>& c11, const pair<Clause*, uint32_t>& c22)$/;"	f	struct:XorFinder::clause_sorter_primary
operator *	CSet.h	/^                ClauseSimp& operator*() {$/;"	f	class:CSet::iterator
operator *	CSet.h	/^                const ClauseSimp& operator*() {$/;"	f	class:CSet::const_iterator
operator *	PackedMatrix.h	/^        PackedRow operator*()$/;"	f	class:PackedMatrix::iterator
operator *	StreamBuffer.h	/^    int  operator *  () {$/;"	f	class:StreamBuffer
operator *	XSet.h	/^                XorClauseSimp& operator*() {$/;"	f	class:XSet::iterator
operator +	PackedMatrix.h	/^        iterator operator+(const uint32_t num) const$/;"	f	class:PackedMatrix::iterator
operator ++	CSet.h	/^                void operator++()$/;"	f	class:CSet::const_iterator
operator ++	CSet.h	/^                void operator++()$/;"	f	class:CSet::iterator
operator ++	PackedMatrix.h	/^        iterator& operator++()$/;"	f	class:PackedMatrix::iterator
operator ++	StreamBuffer.h	/^    void operator ++ () {$/;"	f	class:StreamBuffer
operator ++	XSet.h	/^                void operator++()$/;"	f	class:XSet::iterator
operator +=	CompleteDetachReattacher.h	/^                ClausesStay& operator+=(const ClausesStay& other) {$/;"	f	class:CompleteDetachReatacher::ClausesStay
operator +=	PackedMatrix.h	/^        void operator+=(const uint32_t num)$/;"	f	class:PackedMatrix::iterator
operator -	PackedMatrix.h	/^        const uint32_t operator-(const iterator& b) const$/;"	f	class:PackedMatrix::iterator
operator ->	CSet.h	/^                ClauseSimp*& operator->() {$/;"	f	class:CSet::iterator
operator ->	CSet.h	/^                const ClauseSimp*& operator->() {$/;"	f	class:CSet::const_iterator
operator ->	XSet.h	/^                XorClauseSimp*& operator->() {$/;"	f	class:XSet::iterator
operator <	FailedLitSearcher.h	/^            const bool operator<(const TwoLongXor& other) const$/;"	f	class:FailedLitSearcher::TwoLongXor
operator <	SolverTypes.h	/^    bool operator <  (const Lit& p) const {$/;"	f	class:Lit
operator <<	Clause.h	/^inline std::ostream& operator<<(std::ostream& cout, const Clause& cl)$/;"	f
operator <<	Clause.h	/^inline std::ostream& operator<<(std::ostream& cout, const XorClause& cl)$/;"	f
operator <<	MersenneTwister.h	/^inline std::ostream& operator<<( std::ostream& os, const MTRand& mtrand )$/;"	f
operator <<	PackedRow.cpp	/^std::ostream& operator << (std::ostream& os, const PackedRow& m)$/;"	f
operator <<	PropBy.h	/^inline std::ostream& operator<<(std::ostream& cout, const PropByFull& propByFull)$/;"	f
operator <<	PropBy.h	/^inline std::ostream& operator<<(std::ostream& os, const PropBy& pb)$/;"	f
operator <<	SolverTypes.h	/^inline std::ostream& operator<<(std::ostream& cout, const Lit& lit)$/;"	f
operator <<	SolverTypes.h	/^inline std::ostream& operator<<(std::ostream& cout, const lbool val)$/;"	f
operator <<	SolverTypes.h	/^inline std::ostream& operator<<(std::ostream& cout, const vec<Lit>& lits)$/;"	f
operator <<	SolverTypes.h	/^inline std::ostream& operator<<(std::ostream& os, const llbool val)$/;"	f
operator =	BitArray.h	/^    BitArray& operator=(const BitArray& b)$/;"	f	class:BitArray
operator =	BoxedVec.h	/^    altvec<T>&  operator = (altvec<T>& other) { assert(0); }$/;"	f	class:bvec
operator =	DoublePackedRow.h	/^                inline void operator=(const lbool toSet)$/;"	f	class:MINISAT::DoublePackedRow::BitIter
operator =	Heap.h	/^    void operator=(const Heap<Comp>& other)$/;"	f	class:Heap
operator =	Map.h	/^    Map<K,D,H,E>&  operator = (Map<K,D,H,E>& other) { assert(0); }$/;"	f	class:Map
operator =	PackedMatrix.h	/^    PackedMatrix& operator=(const PackedMatrix& b)$/;"	f	class:PackedMatrix
operator =	PackedRow.h	/^    PackedRow& operator=(const PackedRow& b)$/;"	f	class:PackedRow
operator =	Vec.h	/^    vec<T>&  operator = (vec<T>& other) { assert(0); return *this; }$/;"	f	class:vec
operator ==	DoublePackedRow.h	/^                inline const bool operator==(lbool b) const {$/;"	f	class:MINISAT::DoublePackedRow::BitIter
operator ==	DoublePackedRow.h	/^                inline const bool operator==(lbool b) const {$/;"	f	class:MINISAT::DoublePackedRow::BitIterConst
operator ==	FailedLitSearcher.h	/^            const bool operator==(const TwoLongXor& other) const$/;"	f	class:FailedLitSearcher::TwoLongXor
operator ==	PackedMatrix.h	/^        const bool operator==(const iterator& it) const$/;"	f	class:PackedMatrix::iterator
operator ==	PackedRow.cpp	/^bool PackedRow::operator ==(const PackedRow& b) const$/;"	f	class:PackedRow
operator ==	SolverTypes.h	/^    bool operator==(const Lit& p) const {$/;"	f	class:Lit
operator ==	SolverTypes.h	/^    inline const bool operator==(const llbool& v) const {$/;"	f	class:llbool
operator ==	SolverTypes.h	/^    inline const bool operator==(lbool b) const {$/;"	f	class:lbool
operator >>	MersenneTwister.h	/^inline std::istream& operator>>( std::istream& is, MTRand& mtrand )$/;"	f
operator T*	BoxedVec.h	/^    operator T*       (void)           { return ref->data; }     \/\/ (unsafe but convenient)$/;"	f	class:bvec
operator []	BasicHeap.h	/^    int  operator[](int index)            const { return heap[index+1]; }$/;"	f	class:BasicHeap
operator []	BitArray.h	/^    inline const bool operator[](const uint32_t& i) const$/;"	f	class:BitArray
operator []	BoxedVec.h	/^    T&       operator [] (int index)        { return ref->data[index]; }$/;"	f	class:bvec
operator []	BoxedVec.h	/^    const T& operator [] (int index) const  { return ref->data[index]; }$/;"	f	class:bvec
operator []	Clause.h	/^    Lit& operator [] (uint32_t i)$/;"	f	struct:Clause
operator []	Clause.h	/^    const Lit& operator [] (uint32_t i) const$/;"	f	struct:Clause
operator []	DoublePackedRow.h	/^        inline BitIter operator[](const uint32_t at)$/;"	f	class:MINISAT::DoublePackedRow
operator []	DoublePackedRow.h	/^        inline const BitIterConst operator[](const uint32_t at) const$/;"	f	class:MINISAT::DoublePackedRow
operator []	Heap.h	/^    uint32_t  operator[](uint32_t index) const { assert(index < heap.size()); return heap[index]; }$/;"	f	class:Heap
operator []	PackedRow.h	/^    inline const bool operator[](const uint32_t& i) const$/;"	f	class:PackedRow
operator []	PropBy.h	/^        const Lit operator[](const uint32_t i) const$/;"	f	class:PropByFull
operator []	Queue.h	/^    const T& operator [] (int index) const  { return elems[first + index]; }$/;"	f	class:Queue
operator []	Vec.h	/^    T&       operator [] (uint32_t index)        { return data[index]; }$/;"	f	class:vec
operator []	Vec.h	/^    const T& operator [] (uint32_t index) const  { return data[index]; }$/;"	f	class:vec
operator ^	DoublePackedRow.h	/^                const lbool operator^(const bool b) const {$/;"	f	class:MINISAT::DoublePackedRow::BitIter
operator ^	DoublePackedRow.h	/^                const lbool operator^(const bool b) const {$/;"	f	class:MINISAT::DoublePackedRow::BitIterConst
operator ^	SolverTypes.h	/^    Lit  operator^(const bool b) const {$/;"	f	class:Lit
operator ^	SolverTypes.h	/^    lbool operator^(const bool b) const {$/;"	f	class:lbool
operator ^=	PackedRow.h	/^    PackedRow& operator^=(const PackedRow& b)$/;"	f	class:PackedRow
operator ^=	SolverTypes.h	/^    Lit& operator^=(const bool b) {$/;"	f	class:Lit
operator const T*	BoxedVec.h	/^    operator const T* (void) const     { return ref->data; }$/;"	f	class:bvec
operator lbool	DoublePackedRow.h	/^                inline operator lbool() const$/;"	f	class:MINISAT::DoublePackedRow::BitIter
operator lbool	DoublePackedRow.h	/^                inline operator lbool() const$/;"	f	class:MINISAT::DoublePackedRow::BitIterConst
operator ~	SolverTypes.h	/^    Lit  operator~() const {$/;"	f	class:Lit
orderCols	GaussianConfig.h	/^    bool orderCols; \/\/Order columns according to activity$/;"	m	class:GaussConf
orderVarsForElim	Subsumer.cpp	/^void Subsumer::orderVarsForElim(vec<Var>& order)$/;"	f	class:Subsumer
order_heap	Solver.h	/^    Heap<VarOrderLt>    order_heap;       \/\/\/< A priority queue of variables ordered with respect to the variable activity. All variables here MUST be decision variables. If you changed the decision variables, you MUST filter this$/;"	m	class:Solver
origClauseSizes	ClauseAllocator.h	/^        vec<vec<uint32_t> > origClauseSizes;$/;"	m	class:ClauseAllocator
origFilename	SolverConf.h	/^        std::string origFilename;       \/\/\/<Dump simplified original problem CNF to this file. Only active if "needToDumpOrig" is set to TRUE$/;"	m	class:SolverConf
origNClauses	XorSubsumer.h	/^    uint32_t origNClauses;$/;"	m	class:XorSubsumer
origProps	FailedLitSearcher.h	/^        uint64_t origProps;     \/\/\/<Records num. of bogoprops at the start-up of search()$/;"	m	class:FailedLitSearcher
origSeed	SolverConf.h	/^        uint32_t origSeed;$/;"	m	class:SolverConf
origTrailSize	FailedLitSearcher.h	/^        uint32_t origTrailSize; \/\/\/<Records num. of 0-depth assignments at the start-up of search()$/;"	m	class:FailedLitSearcher
pNext	MersenneTwister.h	/^	uint32 *pNext;     \/\/ next value to get from state$/;"	m	class:MTRand
parent	BasicHeap.h	/^    static inline int parent(int i) { return (i-1) >> 1; }$/;"	f	class:BasicHeap
parent	Heap.h	/^    static inline uint32_t parent(uint32_t i) { return (i-1) >> 1; }$/;"	f	class:Heap
parseClauseParameters	DimacsParser.cpp	/^void DimacsParser::parseClauseParameters(StreamBuffer& in, bool& learnt, uint32_t& glue, float& miniSatAct)$/;"	f	class:DimacsParser
parseCommandLine	Main.cpp	/^void Main::parseCommandLine()$/;"	f	class:Main
parseComments	DimacsParser.cpp	/^void DimacsParser::parseComments(StreamBuffer& in, const std::string str)$/;"	f	class:DimacsParser
parseFloat	DimacsParser.cpp	/^float DimacsParser::parseFloat(StreamBuffer& in)$/;"	f	class:DimacsParser
parseInAllFiles	Main.cpp	/^void Main::parseInAllFiles(Solver& solver)$/;"	f	class:Main
parseInt	DimacsParser.cpp	/^int DimacsParser::parseInt(StreamBuffer& in, uint32_t& lenParsed)$/;"	f	class:DimacsParser
parseString	DimacsParser.cpp	/^void DimacsParser::parseString(StreamBuffer& in, std::string& str)$/;"	f	class:DimacsParser
parse_DIMACS	DimacsParser.cpp	/^void DimacsParser::parse_DIMACS(T input_stream)$/;"	f	class:DimacsParser
parse_DIMACS_main	DimacsParser.cpp	/^void DimacsParser::parse_DIMACS_main(StreamBuffer& in)$/;"	f	class:DimacsParser
partHandler	Solver.h	/^    PartHandler*        partHandler;$/;"	m	class:Solver
part_no	PartFinder.h	/^        uint32_t part_no;$/;"	m	class:PartFinder
peek	BoundedQueue.h	/^    const T peek() const { assert(queuesize>0); return elems[last]; }$/;"	f	class:bqueue
peek	Map.h	/^    bool peek   (const K& k, D& d) {$/;"	f	class:Map
peek	Queue.h	/^    T    peek  () const { return elems[first]; }$/;"	f	class:Queue
percolateDown	BasicHeap.h	/^    inline void percolateDown(int i)$/;"	f	class:BasicHeap
percolateDown	Heap.h	/^    inline void percolateDown(uint32_t i)$/;"	f	class:Heap
percolateUp	BasicHeap.h	/^    inline void percolateUp(int i)$/;"	f	class:BasicHeap
percolateUp	Heap.h	/^    inline void percolateUp(uint32_t i)$/;"	f	class:Heap
performReplace	VarReplacer.h	/^inline const bool VarReplacer::performReplace(const bool always)$/;"	f	class:VarReplacer
performReplaceInternal	VarReplacer.cpp	/^const bool VarReplacer::performReplaceInternal()$/;"	f	class:VarReplacer
performStepsBeforeSolve	Solver.cpp	/^void Solver::performStepsBeforeSolve()$/;"	f	class:Solver
permDiff	Solver.h	/^    vec<uint64_t>       permDiff;  \/\/\/<permDiff[var] is used to count the number of different decision level variables in learnt clause (filled with data from MYFLAG )$/;"	m	class:Solver
pickBranchLit	Solver.cpp	/^Lit Solver::pickBranchLit()$/;"	f	class:Solver
plainPrint	Clause.h	/^    void plainPrint(FILE* to = stdout) const$/;"	f	class:XorClause
plainPrint	Clause.h	/^    void plainPrint(FILE* to = stdout) const$/;"	f	struct:Clause
plainPrint	XorSubsumer.h	/^        void plainPrint(FILE* to = stdout) const$/;"	f	struct:XorSubsumer::XorElimedClause
polarity	Solver.h	/^    vector<bool> polarity;      \/\/ The preferred polarity of each variable.$/;"	m	class:Solver
polarity_auto	SolverTypes.h	/^enum { polarity_true = 0, polarity_false = 1, polarity_rnd = 3, polarity_auto = 4};$/;"	e	enum:__anon4
polarity_false	SolverTypes.h	/^enum { polarity_true = 0, polarity_false = 1, polarity_rnd = 3, polarity_auto = 4};$/;"	e	enum:__anon4
polarity_mode	SolverConf.h	/^        int       polarity_mode;      \/\/\/<Controls which polarity the decision heuristic chooses. Auto means Jeroslow-Wang          (default: polarity_auto)$/;"	m	class:SolverConf
polarity_rnd	SolverTypes.h	/^enum { polarity_true = 0, polarity_false = 1, polarity_rnd = 3, polarity_auto = 4};$/;"	e	enum:__anon4
polarity_true	SolverTypes.h	/^enum { polarity_true = 0, polarity_false = 1, polarity_rnd = 3, polarity_auto = 4};$/;"	e	enum:__anon4
pop	BoundedQueue.h	/^    void pop() {sumofqueue-=elems[last]; queuesize--; if ((++last) == maxsize) last = 0;}$/;"	f	class:bqueue
pop	BoxedVec.h	/^    void     pop    (void)             { assert(ref != NULL && ref->sz > 0); int last = --ref->sz; ref->data[last].~T(); }$/;"	f	class:bvec
pop	Clause.h	/^    void pop()$/;"	f	struct:Clause
pop	Queue.h	/^    void pop   () { first++; }$/;"	f	class:Queue
pop	Vec.h	/^    void     pop    (void)             { sz--, data[sz].~T(); }$/;"	f	class:vec
popcnt	PackedRow.cpp	/^uint32_t PackedRow::popcnt() const$/;"	f	class:PackedRow
popcnt	PackedRow.cpp	/^uint32_t PackedRow::popcnt(const uint32_t from) const$/;"	f	class:PackedRow
popcnt_is_one	PackedRow.h	/^    bool popcnt_is_one() const$/;"	f	class:PackedRow
popcnt_is_one	PackedRow.h	/^    bool popcnt_is_one(uint32_t from) const$/;"	f	class:PackedRow
pos	StreamBuffer.h	/^    int     pos;$/;"	m	class:StreamBuffer
primes	Map.h	/^static const int primes [nprimes] = { 31, 73, 151, 313, 643, 1291, 2593, 5233, 10501, 21013, 42073, 84181, 168451, 337219, 674701, 1349473, 2699299, 5398891, 10798093, 21596719, 43193641, 86387383, 172775299, 345550609, 691101253 };$/;"	v
print	Clause.h	/^    void print(FILE* to = stdout) const$/;"	f	class:XorClause
print	Clause.h	/^    void print(FILE* to = stdout) const$/;"	f	struct:Clause
print	SolverTypes.h	/^    inline void print(FILE* outfile = stdout) const$/;"	f	class:Lit
printAllClauses	SolverDebug.cpp	/^void Solver::printAllClauses()$/;"	f	class:Solver
printClause	SolverTypes.h	/^inline void printClause(FILE* outFile, const std::vector<Lit>& clause)$/;"	f
printClause	SolverTypes.h	/^inline void printClause(FILE* outFile, const vec<Lit>& clause)$/;"	f
printEndSearchStat	SolverMisc.cpp	/^void Solver::printEndSearchStat()$/;"	f	class:Solver
printFull	SolverTypes.h	/^    inline void printFull(FILE* outfile = stdout) const$/;"	f	class:Lit
printHeader	DimacsParser.cpp	/^void DimacsParser::printHeader(StreamBuffer& in)$/;"	f	class:DimacsParser
printLit	SolverMisc.cpp	/^void Solver::printLit(const Lit l) const$/;"	f	class:Solver
printRestartStat	SolverMisc.cpp	/^void Solver::printRestartStat(const char* type)$/;"	f	class:Solver
printResult	Main.h	/^        bool printResult;$/;"	m	class:Main
printResultFunc	Main.cpp	/^void Main::printResultFunc(const Solver& S, const lbool ret, FILE* res)$/;"	f	class:Main
printResults	FailedLitSearcher.cpp	/^void FailedLitSearcher::printResults(const double myTime) const$/;"	f	class:FailedLitSearcher
printStatHeader	SolverMisc.cpp	/^void Solver::printStatHeader() const$/;"	f	class:Solver
printStats	SolverMisc.cpp	/^void Solver::printStats()$/;"	f	class:Solver
printStatsLine	SolverMisc.cpp	/^void Solver::printStatsLine(std::string left, T value, T2 value2, std::string extra)$/;"	f	class:Solver
printStatsLine	SolverMisc.cpp	/^void Solver::printStatsLine(std::string left, T value, std::string extra)$/;"	f	class:Solver
printStrangeBinLit	SolverMisc.cpp	/^void Solver::printStrangeBinLit(const Lit lit) const$/;"	f	class:Solver
printUsage	Main.cpp	/^void Main::printUsage(char** argv)$/;"	f	class:Main
printVersionInfo	Main.cpp	/^void Main::printVersionInfo(const uint32_t verbosity)$/;"	f	class:Main
print_gauss_sum_stats	SolverMisc.cpp	/^void Solver::print_gauss_sum_stats()$/;"	f	class:Solver
print_last_one_in_cols	Gaussian.cpp	/^void Gaussian::print_last_one_in_cols(matrixset& m) const$/;"	f	class:Gaussian
print_matrix	Gaussian.cpp	/^void Gaussian::print_matrix(matrixset& m) const$/;"	f	class:Gaussian
print_matrix_row	Gaussian.cpp	/^void Gaussian::print_matrix_row(const T& row) const$/;"	f	class:Gaussian
print_matrix_row_with_assigns	Gaussian.cpp	/^void Gaussian::print_matrix_row_with_assigns(const T& row) const$/;"	f	class:Gaussian
print_matrix_stats	Gaussian.cpp	/^void Gaussian::print_matrix_stats() const$/;"	f	class:Gaussian
print_stats	Gaussian.cpp	/^void Gaussian::print_stats() const$/;"	f	class:Gaussian
propBinaryClause	Solver.cpp	/^inline const bool Solver::propBinaryClause(Watched* &i, Watched* &j, Watched *end, const Lit p, PropBy& confl)$/;"	f	class:Solver
propNormalClause	Solver.cpp	/^inline const bool Solver::propNormalClause(Watched* &i, Watched* &j, Watched *end, const Lit p, PropBy& confl, const bool update)$/;"	f	class:Solver
propTriClause	Solver.cpp	/^inline const bool Solver::propTriClause(Watched* &i, Watched* &j, Watched *end, const Lit p, PropBy& confl)$/;"	f	class:Solver
propValue	FailedLitSearcher.h	/^        BitArray propValue; \/\/\/<The value (0 or 1) of the lits propagated set in "propagated"$/;"	m	class:FailedLitSearcher
propXorClause	Solver.cpp	/^inline const bool Solver::propXorClause(Watched* &i, Watched* &j, Watched *end, const Lit p, PropBy& confl)$/;"	f	class:Solver
propagatable_rows	Gaussian.h	/^    vec<uint32_t> propagatable_rows; \/\/used to store which rows were deemed propagatable during elimination$/;"	m	class:Gaussian
propagate	OnlyNonLearntBins.cpp	/^const bool OnlyNonLearntBins::propagate()$/;"	f	class:OnlyNonLearntBins
propagate	Solver.cpp	/^PropBy Solver::propagate(const bool update)$/;"	f	class:Solver
propagateBin	Solver.cpp	/^PropBy Solver::propagateBin(vec<Lit>& uselessBin)$/;"	f	class:Solver
propagateBinExcept	Solver.cpp	/^const bool Solver::propagateBinExcept(const Lit exceptLit)$/;"	f	class:Solver
propagateBinOneLevel	Solver.cpp	/^const bool Solver::propagateBinOneLevel()$/;"	f	class:Solver
propagateNonLearntBin	Solver.cpp	/^PropBy Solver::propagateNonLearntBin()$/;"	f	class:Solver
propagated	FailedLitSearcher.h	/^        BitArray propagated; \/\/\/<These lits have been propagated by propagating the lit picked$/;"	m	class:FailedLitSearcher
propagatedVars	FailedLitSearcher.h	/^        vec<Var> propagatedVars;$/;"	m	class:FailedLitSearcher
propagation	Gaussian.h	/^    enum gaussian_ret {conflict, unit_conflict, propagation, unit_propagation, nothing};$/;"	e	enum:Gaussian::gaussian_ret
propagations	Solver.h	/^    uint64_t propagations;$/;"	m	class:Solver
push	BoundedQueue.h	/^    void push(const T x) {$/;"	f	class:bqueue
push	BoxedVec.h	/^    void     push   () {$/;"	f	class:bvec
push	BoxedVec.h	/^    void     push   (const T& elem) {$/;"	f	class:bvec
push	DoublePackedRow.h	/^        inline void push(const lbool val)$/;"	f	class:MINISAT::DoublePackedRow
push	Vec.h	/^    void     push  (const T& elem)$/;"	f	class:vec
push	Vec.h	/^    void     push  (void)$/;"	f	class:vec
push_	Vec.h	/^    void     push_ (const T& elem)     { assert(sz < cap); data[sz++] = elem; }$/;"	f	class:vec
qhead	Solver.h	/^    uint32_t            qhead;            \/\/\/< Head of queue (as index into the trail)$/;"	m	class:Solver
queuesize	BoundedQueue.h	/^    uint32_t queuesize; \/\/ Number of current elements (must be < maxsize !)$/;"	m	class:bqueue
rand	MersenneTwister.h	/^inline double MTRand::rand( const double& n )$/;"	f	class:MTRand
rand	MersenneTwister.h	/^inline double MTRand::rand()$/;"	f	class:MTRand
rand53	MersenneTwister.h	/^inline double MTRand::rand53()$/;"	f	class:MTRand
randDblExc	MersenneTwister.h	/^inline double MTRand::randDblExc( const double& n )$/;"	f	class:MTRand
randDblExc	MersenneTwister.h	/^inline double MTRand::randDblExc()$/;"	f	class:MTRand
randExc	MersenneTwister.h	/^inline double MTRand::randExc( const double& n )$/;"	f	class:MTRand
randExc	MersenneTwister.h	/^inline double MTRand::randExc()$/;"	f	class:MTRand
randInt	MersenneTwister.h	/^inline MTRand::uint32 MTRand::randInt( const uint32& n )$/;"	f	class:MTRand
randInt	MersenneTwister.h	/^inline MTRand::uint32 MTRand::randInt()$/;"	f	class:MTRand
randNorm	MersenneTwister.h	/^inline double MTRand::randNorm( const double& mean, const double& variance )$/;"	f	class:MTRand
random_var_freq	SolverConf.h	/^        double    random_var_freq;    \/\/\/<The frequency with which the decision heuristic tries to choose a random variable.        (default 0.02) NOTE: This is really strange. If the number of variables set is large, then the random chance is in fact _far_ lower than this value. This is because the algorithm tries to set one variable randomly, but if that variable is already set, then it _silently_ fails, and moves on (doing non-random flip)!$/;"	m	class:SolverConf
readClause	DimacsParser.cpp	/^void DimacsParser::readClause(StreamBuffer& in, vec<Lit>& lits)$/;"	f	class:DimacsParser
readFullClause	DimacsParser.cpp	/^void DimacsParser::readFullClause(StreamBuffer& in)$/;"	f	class:DimacsParser
readInAFile	Main.cpp	/^void Main::readInAFile(const std::string& filename, Solver& solver)$/;"	f	class:Main
readInStandardInput	Main.cpp	/^void Main::readInStandardInput(Solver& solver)$/;"	f	class:Main
readdRemovedClauses	PartHandler.cpp	/^void PartHandler::readdRemovedClauses()$/;"	f	class:PartHandler
reason	Solver.h	/^    vec<PropBy>         reason;           \/\/\/< 'reason[var]' is the clause that implied the variables current value, or 'NULL' if none.$/;"	m	class:Solver
reattachNonBins	CompleteDetachReattacher.cpp	/^const bool CompleteDetachReatacher::reattachNonBins()$/;"	f	class:CompleteDetachReatacher
recurDepth	SCCFinder.h	/^        uint32_t recurDepth;$/;"	m	class:SCCFinder
recvBinData	DataSync.h	/^        uint32_t recvBinData;$/;"	m	class:DataSync
recvUnitData	DataSync.h	/^        uint32_t recvUnitData;$/;"	m	class:DataSync
reduceDB	Solver.cpp	/^void Solver::reduceDB()$/;"	f	class:Solver
reduceDB_ltGlucose	Solver.h	/^struct reduceDB_ltGlucose$/;"	s
reduceDB_ltMiniSat	Solver.h	/^struct reduceDB_ltMiniSat$/;"	s
ref	BoxedVec.h	/^    Vec_t* ref;$/;"	m	class:bvec
registerIteration	Subsumer.h	/^    void registerIteration  (CSet& iter_set) { iter_sets.push(&iter_set); }$/;"	f	class:Subsumer
rehash	Map.h	/^    void    rehash () {$/;"	f	class:Map
release	Vec.h	/^    T*       release  (void)           { T* ret = data; data = NULL; sz = 0; cap = 0; return ret; }$/;"	f	class:vec
release_assert	Solver.h	54;"	d
reload	MersenneTwister.h	/^inline void MTRand::reload()$/;"	f	class:MTRand
remove	Alg.h	/^static inline void remove(V& ts, const T& t)$/;"	f
remove	Map.h	/^    void remove (const K& k) {$/;"	f	class:Map
removeAll	Alg.h	/^static inline const uint32_t removeAll(V& ts, const Var t)$/;"	f
removeAndCleanAll	ClauseCleaner.h	/^inline void ClauseCleaner::removeAndCleanAll(const bool nolimit)$/;"	f	class:ClauseCleaner
removeAssignedVarsFromEliminated	Subsumer.cpp	/^void Subsumer::removeAssignedVarsFromEliminated()$/;"	f	class:Subsumer
removeAssignedVarsFromEliminated	XorSubsumer.cpp	/^void XorSubsumer::removeAssignedVarsFromEliminated()$/;"	f	class:XorSubsumer
removeBin	UselessBinRemover.cpp	/^void UselessBinRemover::removeBin(const Lit lit1, const Lit lit2)$/;"	f	class:UselessBinRemover
removeClause	Solver.h	/^inline void Solver::removeClause(T& c)$/;"	f	class:Solver
removeClauses	Subsumer.cpp	/^void Subsumer::removeClauses(vec<ClAndBin>& posAll, vec<ClAndBin>& negAll, const Var var)$/;"	f	class:Subsumer
removeClausesHelper	Subsumer.cpp	/^void Subsumer::removeClausesHelper(vec<ClAndBin>& todo, const Var var, std::pair<uint32_t, uint32_t>& removed)$/;"	f	class:Subsumer
removeDependent	XorSubsumer.cpp	/^const bool XorSubsumer::removeDependent()$/;"	f	class:XorSubsumer
removeMin	BasicHeap.h	/^    int  removeMin() {$/;"	f	class:BasicHeap
removeMin	Heap.h	/^    uint32_t  removeMin()$/;"	f	class:Heap
removeSatisfiedBins	ClauseCleaner.cpp	/^void ClauseCleaner::removeSatisfiedBins(const uint32_t limit)$/;"	f	class:ClauseCleaner
removeThese	BitArray.h	/^    BitArray& removeThese(const BitArray& b)$/;"	f	class:BitArray
removeThese	BitArray.h	/^    BitArray& removeThese(const T& rem)$/;"	f	class:BitArray
removeUselessBinaries	UselessBinRemover.cpp	/^const bool UselessBinRemover::removeUselessBinaries(const Lit lit)$/;"	f	class:UselessBinRemover
removeUslessBinFull	UselessBinRemover.cpp	/^const bool UselessBinRemover::removeUslessBinFull()$/;"	f	class:UselessBinRemover
removeVarFromXors	FailedLitSearcher.cpp	/^inline void FailedLitSearcher::removeVarFromXors(const Var var)$/;"	f	class:FailedLitSearcher
removeW	Alg.h	/^static inline void removeW(V& ts, const T& t)$/;"	f
removeWBin	Alg.h	/^static inline void removeWBin(vec<Watched> &ws, const Lit impliedLit, const bool learnt)$/;"	f
removeWBinAll	Alg.h	/^static inline const std::pair<uint32_t, uint32_t>  removeWBinAll(vec<Watched> &ws, const Lit impliedLit)$/;"	f
removeWCl	Alg.h	/^static inline void removeWCl(vec<Watched> &ws, const ClauseOffset c)$/;"	f
removeWTri	Alg.h	/^static inline void removeWTri(vec<Watched> &ws, const Lit lit1, const Lit lit2)$/;"	f
removeWXCl	Alg.h	/^static inline void removeWXCl(vec<Watched> &ws, const ClauseOffset c)$/;"	f
removeWrong	Subsumer.cpp	/^void Subsumer::removeWrong(vec<Clause*>& cs)$/;"	f	class:Subsumer
removeWrong	XorSubsumer.cpp	/^void XorSubsumer::removeWrong(vec<Clause*>& cs)$/;"	f	class:XorSubsumer
removeWrongBins	XorSubsumer.cpp	/^void XorSubsumer::removeWrongBins()$/;"	f	class:XorSubsumer
removeWrongBinsAndAllTris	Subsumer.cpp	/^void Subsumer::removeWrongBinsAndAllTris()$/;"	f	class:Subsumer
removeable_cols	Gaussian.h	/^        uint32_t removeable_cols; \/\/ the number of columns that have been zeroed out (i.e. assigned)$/;"	m	class:Gaussian::matrixset
removedUselessLearnt	FailedLitSearcher.h	/^        uint32_t removedUselessLearnt;$/;"	m	class:FailedLitSearcher
removedUselessNonLearnt	FailedLitSearcher.h	/^        uint32_t removedUselessNonLearnt;$/;"	m	class:FailedLitSearcher
replace	VarReplacer.cpp	/^const bool VarReplacer::replace(T& ps, const bool xorEqualFalse, const uint32_t group)$/;"	f	class:VarReplacer
replaceBins	VarReplacer.cpp	/^const bool VarReplacer::replaceBins()$/;"	f	class:VarReplacer
replaceTable	SCCFinder.h	/^        const vector<Lit>& replaceTable;$/;"	m	class:SCCFinder
replace_set	VarReplacer.cpp	/^const bool VarReplacer::replace_set(vec<Clause*>& cs)$/;"	f	class:VarReplacer
replace_set	VarReplacer.cpp	/^const bool VarReplacer::replace_set(vec<XorClause*>& cs)$/;"	f	class:VarReplacer
replacedLits	VarReplacer.h	/^        uint32_t replacedLits; \/\/\/<Num literals replaced during var-replacement$/;"	m	class:VarReplacer
replacedVars	VarReplacer.h	/^        uint32_t replacedVars; \/\/\/<Num vars replaced during var-replacement$/;"	m	class:VarReplacer
replacingVar	VarReplacer.h	/^inline const bool VarReplacer::replacingVar(const Var var) const$/;"	f	class:VarReplacer
reserve	CSet.h	/^        void reserve(uint32_t size) { where.reserve(size);}$/;"	f	class:CSet
reserve	Vec.h	/^    void     reserve(uint32_t res)     { if (cap < res) {cap = res; data = (T*)realloc(data, cap * sizeof(T));}}$/;"	f	class:vec
reserve	XSet.h	/^        void reserve(uint32_t size) { where.reserve(size);}$/;"	f	class:XSet
reset	RestartTypeChooser.h	/^inline void RestartTypeChooser::reset()$/;"	f	class:RestartTypeChooser
reset_stats	Gaussian.cpp	/^void Gaussian::reset_stats()$/;"	f	class:Gaussian
resize	BitArray.h	/^    void resize(uint32_t _size, const bool fill)$/;"	f	class:BitArray
resize	PackedMatrix.h	/^    void resize(const uint32_t num_rows, uint32_t num_cols)$/;"	f	class:PackedMatrix
resizeNumRows	PackedMatrix.h	/^    void resizeNumRows(const uint32_t num_rows)$/;"	f	class:PackedMatrix
restartType	Solver.h	/^    RestartType restartType;             \/\/\/<Used internally to determine which restart strategy is currently in use$/;"	m	class:Solver
restartTypeChooser	Solver.h	/^    RestartTypeChooser* restartTypeChooser;$/;"	m	class:Solver
restart_first	SolverConf.h	/^        int       restart_first;      \/\/\/<The initial restart limit.                                                                (default 100)$/;"	m	class:SolverConf
restart_inc	SolverConf.h	/^        double    restart_inc;        \/\/\/<The factor with which the restart limit is multiplied in each restart.                    (default 1.5)$/;"	m	class:SolverConf
restore	StateSaver.cpp	/^void StateSaver::restore()$/;"	f	class:StateSaver
restrictPickBranch	SolverConf.h	/^        Var       restrictPickBranch; \/\/\/<Pick variables to branch on preferentally from the highest [0, restrictedPickBranch]. If set to 0, preferentiality is turned off (i.e. picked randomly between [0, all])$/;"	m	class:SolverConf
reverseTable	MatrixFinder.h	/^        map<uint32_t, vector<Var> > reverseTable; \/\/matrix -> vars$/;"	m	class:MatrixFinder
reverseTable	PartFinder.h	/^        map<uint32_t, vector<Var> > reverseTable; \/\/part -> vars$/;"	m	class:PartFinder
reverseTable	VarReplacer.h	/^        map<Var, vector<Var> > reverseTable; \/\/\/<mapping of variable to set of variables it replaces$/;"	m	class:VarReplacer
right	BasicHeap.h	/^    static inline int right (int i) { return (i+1)*2; }$/;"	f	class:BasicHeap
right	Heap.h	/^    static inline uint32_t right (uint32_t i) { return (i+1)*2; }$/;"	f	class:Heap
rnd_decisions	Solver.h	/^    uint64_t rnd_decisions; \/\/\/<Numer of random decisions made$/;"	m	class:Solver
s	Solver.h	/^        const Solver& s;$/;"	m	struct:Solver::VarFilter
sCCFinder	Solver.h	/^    SCCFinder*          sCCFinder;$/;"	m	class:Solver
sameIns	RestartTypeChooser.h	/^        vector<Var> sameIns;$/;"	m	class:RestartTypeChooser
satisfied	ClauseCleaner.cpp	/^bool ClauseCleaner::satisfied(const Clause& c) const$/;"	f	class:ClauseCleaner
satisfied	ClauseCleaner.cpp	/^bool ClauseCleaner::satisfied(const XorClause& c) const$/;"	f	class:ClauseCleaner
satisfied	ClauseCleaner.cpp	/^const bool ClauseCleaner::satisfied(const Watched& watched, Lit lit)$/;"	f	class:ClauseCleaner
save	MersenneTwister.h	/^inline void MTRand::save( uint32* saveArray ) const$/;"	f	class:MTRand
saveOTFData	Solver.cpp	/^void Solver::saveOTFData()$/;"	f	class:Solver
savedState	PartHandler.h	/^        vec<lbool> savedState;$/;"	m	class:PartHandler
scan	PackedRow.h	/^    inline unsigned long int scan(const unsigned long int var) const$/;"	f	class:PackedRow
search	FailedLitSearcher.cpp	/^const bool FailedLitSearcher::search()$/;"	f	class:FailedLitSearcher
search	Solver.cpp	/^lbool Solver::search(const uint64_t nof_conflicts, const uint64_t nof_conflicts_fullrestart, const bool update)$/;"	f	class:Solver
seed	MersenneTwister.h	/^inline void MTRand::seed( const uint32 oneSeed )$/;"	f	class:MTRand
seed	MersenneTwister.h	/^inline void MTRand::seed( uint32 *const bigSeed, const uint32 seedLength )$/;"	f	class:MTRand
seed	MersenneTwister.h	/^inline void MTRand::seed()$/;"	f	class:MTRand
seen	DataSync.h	/^        vec<char> seen;$/;"	m	class:DataSync
seen	Solver.h	/^    vector<bool>        seen; \/\/\/<Used in multiple places. Contains 2 * numVars() elements, all zeroed out$/;"	m	class:Solver
seen2	Solver.h	/^    vector<bool>        seen2;            \/\/\/<To reduce temoprary data creation overhead. Used in minimiseLeartFurther(). contains 2 * numVars() elements, all zeroed out$/;"	m	class:Solver
seen_tmp	Subsumer.h	/^    vec<char>              seen_tmp;       \/\/\/<Used in various places to help perform algorithms$/;"	m	class:Subsumer
seen_tmp	XorSubsumer.h	/^    vec<char>                 seen_tmp;       \/\/ (used in various places)$/;"	m	class:XorSubsumer
select_columnorder	Gaussian.cpp	/^uint32_t Gaussian::select_columnorder(vector<uint16_t>& var_to_col, matrixset& origMat)$/;"	f	class:Gaussian
sentBinData	DataSync.h	/^        uint32_t sentBinData;$/;"	m	class:DataSync
sentUnitData	DataSync.h	/^        uint32_t sentUnitData;$/;"	m	class:DataSync
set	PackedRow.h	/^    void set(const T& v, const vector<uint16_t>& var_to_col, const uint32_t matrix_size)$/;"	f	class:PackedRow
setAllThatPointsHereTo	VarReplacer.cpp	/^void VarReplacer::setAllThatPointsHereTo(const Var var, const Lit lit)$/;"	f	class:VarReplacer
setBit	BitArray.h	/^    inline void setBit(const uint32_t i)$/;"	f	class:BitArray
setBit	PackedRow.h	/^    inline void setBit(const uint32_t i)$/;"	f	class:PackedRow
setBlockedLit	Watched.h	/^        void setBlockedLit(const Lit lit)$/;"	f	class:Watched
setBounds	Heap.h	/^    void setBounds (uint32_t n) { }$/;"	f	class:Heap
setDecisionVar	Solver.h	/^inline void     Solver::setDecisionVar(Var v, bool b)$/;"	f	class:Solver
setDefaultRestartType	Solver.cpp	/^inline void Solver::setDefaultRestartType()$/;"	f	class:Solver
setDoublePrecision	Main.cpp	/^void Main::setDoublePrecision(const uint32_t verbosity)$/;"	f	class:Main
setFreed	Clause.h	/^    void setFreed()$/;"	f	struct:Clause
setGlue	Clause.h	/^    void setGlue(const uint32_t newGlue)$/;"	f	struct:Clause
setGroup	Clause.h	/^    void setGroup(const uint32_t _group)$/;"	f	struct:Clause
setLearnt	Watched.h	/^        void setLearnt(const bool learnt)$/;"	f	class:Watched
setLimits	Subsumer.cpp	/^void Subsumer::setLimits()$/;"	f	class:Subsumer
setMatrixes	MatrixFinder.cpp	/^const uint32_t MatrixFinder::setMatrixes()$/;"	f	class:MatrixFinder
setMiniSatAct	Clause.h	/^    void setMiniSatAct(const float newMiniSatAct)$/;"	f	struct:Clause
setNormClause	Watched.h	/^        void setNormClause()$/;"	f	class:Watched
setNormOffset	Watched.h	/^        void setNormOffset(const ClauseOffset offset)$/;"	f	class:Watched
setOne	BitArray.h	/^    inline void setOne()$/;"	f	class:BitArray
setOtherLit	Watched.h	/^        void setOtherLit(const Lit lit)$/;"	f	class:Watched
setParts	PartFinder.cpp	/^const uint32_t PartFinder::setParts()$/;"	f	class:PartFinder
setPolarity	Solver.h	/^inline void     Solver::setPolarity   (Var v, bool b)$/;"	f	class:Solver
setRemoved	Clause.h	/^    void setRemoved()$/;"	f	struct:Clause
setStrenghtened	Clause.h	/^    void setStrenghtened()$/;"	f	struct:Clause
setVariableName	Solver.h	/^inline void     Solver::setVariableName(const Var var, const char* name)$/;"	f	class:Solver
setXorOffset	Watched.h	/^        void setXorOffset(const ClauseOffset offset)$/;"	f	class:Watched
setZero	BitArray.h	/^    inline void setZero()$/;"	f	class:BitArray
setZero	PackedRow.h	/^    inline void setZero()$/;"	f	class:PackedRow
set_disabled	Gaussian.h	/^inline void Gaussian::set_disabled(const bool toset)$/;"	f	class:Gaussian
set_matrixset_to_cur	Gaussian.cpp	/^inline void Gaussian::set_matrixset_to_cur()$/;"	f	class:Gaussian
shareBinData	DataSync.cpp	/^const bool DataSync::shareBinData()$/;"	f	class:DataSync
shareUnitData	DataSync.cpp	/^const bool DataSync::shareUnitData()$/;"	f	class:DataSync
sharedData	DataSync.h	/^        SharedData* sharedData;$/;"	m	class:DataSync
sharedData	Main.h	/^        SharedData sharedData;$/;"	m	class:Main
should_check_gauss	Gaussian.h	/^inline bool Gaussian::should_check_gauss(const uint32_t decisionlevel, const uint32_t starts) const$/;"	f	class:Gaussian
should_init	Gaussian.h	/^inline bool Gaussian::should_init() const$/;"	f	class:Gaussian
shrink	BoxedVec.h	/^    void     shrink (int nelems)             { for (int i = 0; i < nelems; i++) pop(); }$/;"	f	class:bvec
shrink	Clause.h	/^    void shrink (const uint32_t i)$/;"	f	struct:Clause
shrink	Vec.h	/^    void     shrink (uint32_t nelems)  { assert(nelems <= sz); for (uint32_t i = 0; i != nelems; i++) sz--, data[sz].~T(); }$/;"	f	class:vec
shrink_	BoxedVec.h	/^    void     shrink_(int nelems)             { for (int i = 0; i < nelems; i++) pop(); }$/;"	f	class:bvec
shrink_	Vec.h	/^    void     shrink_(uint32_t nelems)  { assert(nelems <= sz); sz -= nelems; }$/;"	f	class:vec
sign	SolverTypes.h	/^    bool sign() const {$/;"	f	class:Lit
signalNewBinClause	DataSync.cpp	/^void DataSync::signalNewBinClause(Lit lit1, Lit lit2)$/;"	f	class:DataSync
signalNewBinClause	DataSync.cpp	/^void DataSync::signalNewBinClause(T& ps)$/;"	f	class:DataSync
simpBurstSConf	SolverConf.h	/^        uint32_t simpBurstSConf;$/;"	m	class:SolverConf
simpDB_assigns	Solver.h	/^    uint32_t    simpDB_assigns;   \/\/\/< Number of top-level assignments since last execution of 'simplify()'.$/;"	m	class:Solver
simpDB_props	Solver.h	/^    int64_t     simpDB_props;     \/\/\/< Remaining number of propagations that must be made before next execution of 'simplify()'.$/;"	m	class:Solver
simpStartMMult	SolverConf.h	/^        double simpStartMMult;$/;"	m	class:SolverConf
simpStartMult	SolverConf.h	/^        double simpStartMult;$/;"	m	class:SolverConf
simplify	Solver.cpp	/^const bool Solver::simplify()$/;"	f	class:Solver
simplifyBySubsumption	Subsumer.cpp	/^const bool Subsumer::simplifyBySubsumption(const bool _alsoLearnt)$/;"	f	class:Subsumer
simplifyBySubsumption	XorSubsumer.cpp	/^const bool XorSubsumer::simplifyBySubsumption()$/;"	f	class:XorSubsumer
simplifyProblem	Solver.cpp	/^const lbool Solver::simplifyProblem(const uint32_t numConfls)$/;"	f	class:Solver
simplifying	Solver.h	/^    bool        simplifying;      \/\/\/<We are currently doing burst search$/;"	m	class:Solver
singleThreadSolve	Main.cpp	/^const int Main::singleThreadSolve()$/;"	f	class:Main
size	BasicHeap.h	/^    int  size      ()                     const { return heap.size(); }$/;"	f	class:BasicHeap
size	BitArray.h	/^    uint32_t size;$/;"	m	class:BitArray
size	BoundedQueue.h	/^    int  size(void)    { return queuesize; }$/;"	f	class:bqueue
size	BoxedVec.h	/^    int      size   (void) const       { return ref != NULL ? ref->sz : 0; }$/;"	f	class:bvec
size	Clause.h	/^    const uint32_t size() const$/;"	f	struct:Clause
size	DoublePackedRow.h	/^        uint32_t size() const$/;"	f	class:MINISAT::DoublePackedRow
size	Heap.h	/^    uint32_t  size      ()          const { return heap.size(); }$/;"	f	class:Heap
size	Map.h	/^    int        size;$/;"	m	class:Map
size	PackedRow.h	/^    const uint32_t size;$/;"	m	class:PackedRow
size	PropBy.h	/^        const uint32_t size() const$/;"	f	class:PropByFull
size	Queue.h	/^    int  size(void)    { return elems.size() - first; }$/;"	f	class:Queue
size	StreamBuffer.h	/^    int     size;$/;"	m	class:StreamBuffer
size	Vec.h	/^    uint32_t size   (void) const       { return sz; }$/;"	f	class:vec
size	XSet.h	/^        uint32_t size(void) const { return which.size(); }$/;"	f	class:XSet
sizes	ClauseAllocator.h	/^        vec<size_t> sizes; \/\/\/<The number of 32-bit datapieces currently used in each stack$/;"	m	class:ClauseAllocator
skipLine	DimacsParser.cpp	/^void DimacsParser::skipLine(StreamBuffer& in)$/;"	f	class:DimacsParser
skipWhitespace	DimacsParser.cpp	/^void DimacsParser::skipWhitespace(StreamBuffer& in)$/;"	f	class:DimacsParser
solve	Solver.cpp	/^lbool Solver::solve(const vec<Lit>& assumps)$/;"	f	class:Solver
solve	Solver.h	/^inline lbool     Solver::solve         ()$/;"	f	class:Solver
solver	ClauseCleaner.h	/^        Solver& solver;$/;"	m	class:ClauseCleaner
solver	ClauseVivifier.h	/^        Solver& solver;$/;"	m	class:ClauseVivifier
solver	CompleteDetachReattacher.h	/^        Solver& solver;$/;"	m	class:CompleteDetachReatacher
solver	DataSync.h	/^        Solver& solver;$/;"	m	class:DataSync
solver	DimacsParser.h	/^        Solver *solver;$/;"	m	class:DimacsParser
solver	FailedLitSearcher.h	/^        Solver& solver; \/\/\/<The solver we are updating&working with$/;"	m	class:FailedLitSearcher
solver	Gaussian.h	/^    Solver& solver;$/;"	m	class:Gaussian
solver	MatrixFinder.h	/^        Solver& solver;$/;"	m	class:MatrixFinder
solver	OnlyNonLearntBins.h	/^        Solver& solver;$/;"	m	class:OnlyNonLearntBins
solver	PartFinder.h	/^        Solver& solver;$/;"	m	class:PartFinder
solver	PartHandler.h	/^        Solver& solver; \/\/\/<The base solver$/;"	m	class:PartHandler
solver	RestartTypeChooser.h	/^        const Solver& solver;$/;"	m	class:RestartTypeChooser
solver	SCCFinder.h	/^        Solver& solver;$/;"	m	class:SCCFinder
solver	StateSaver.h	/^        Solver& solver;$/;"	m	class:StateSaver
solver	Subsumer.h	/^    Solver& solver;                        \/\/\/<The solver this simplifier is connected to$/;"	m	class:Subsumer
solver	UselessBinRemover.h	/^        Solver& solver; \/\/\/<The solver class e want to remove useless binary clauses from$/;"	m	class:UselessBinRemover
solver	VarReplacer.h	/^        Solver& solver; \/\/\/<The solver we are working with$/;"	m	class:VarReplacer
solver	XorFinder.h	/^        Solver& solver;$/;"	m	class:XorFinder
solver	XorSubsumer.h	/^    Solver&                   solver;         \/\/ The Solver$/;"	m	class:XorSubsumer
solversToInterrupt	Main.cpp	/^std::map<uint32_t, Solver*> solversToInterrupt;$/;"	v
sortBySize	ClauseVivifier.h	/^        struct sortBySize$/;"	s	class:ClauseVivifier
sortBySize	Subsumer.h	/^    struct sortBySize$/;"	s	class:Subsumer
sortWatched	SolverMisc.cpp	/^void Solver::sortWatched()$/;"	f	class:Solver
sort_pred	PartHandler.h	/^        struct sort_pred {$/;"	s	class:PartHandler
space	SolverMisc.cpp	/^static const int space = 10;$/;"	v	file:
stack	SCCFinder.h	/^        std::stack<uint32_t> stack;$/;"	m	class:SCCFinder
stackIndicator	SCCFinder.h	/^        vec<char> stackIndicator;$/;"	m	class:SCCFinder
starts	Solver.h	/^    uint64_t starts; \/\/\/<Num restarts$/;"	m	class:Solver
state	MersenneTwister.h	/^	uint32 state[N];   \/\/ internal state$/;"	m	class:MTRand
staticStarts	Solver.h	/^    uint64_t staticStarts; \/\/\/<Num static restarts: note that after full restart, we do a couple of static restarts always$/;"	m	class:Solver
static_restart	SolverTypes.h	/^enum RestartType {dynamic_restart, static_restart, auto_restart};$/;"	e	enum:RestartType
stdDeviation	RestartTypeChooser.cpp	/^const double RestartTypeChooser::stdDeviation(vector<uint32_t>& measure) const$/;"	f	class:RestartTypeChooser
strenghten	Subsumer.cpp	/^void Subsumer::strenghten(ClauseSimp& c, const Lit toRemoveLit)$/;"	f	class:Subsumer
strenghtened	Clause.h	/^    uint32_t strenghtened:1; \/\/\/<Has the clause been strenghtened since last SatELite-like work?$/;"	m	struct:Clause
strengthen	Clause.h	/^    inline void strengthen(const Lit p)$/;"	f	struct:Clause
stringify	DimacsParser.cpp	/^std::string DimacsParser::stringify(uint32_t x)$/;"	f	class:DimacsParser
subsNonExistentFinish	Subsumer.h	/^    bool subsNonExistentFinish;$/;"	m	class:Subsumer
subsWNonExistBins	Subsumer.cpp	/^const bool Subsumer::subsWNonExistBins(const Lit& lit, OnlyNonLearntBins* onlyNonLearntBins)$/;"	f	class:Subsumer
subsWNonExistBinsFull	Subsumer.cpp	/^const bool Subsumer::subsWNonExistBinsFull()$/;"	f	class:Subsumer
subsWNonExitsBinsFullFull	Subsumer.cpp	/^const bool Subsumer::subsWNonExitsBinsFullFull()$/;"	f	class:Subsumer
subset	Solver.cpp	/^bool subset(const T1& A, const T2& B, vector<bool>& seen)$/;"	f
subset	Subsumer.h	/^bool Subsumer::subset(const uint32_t aSize, const T2& B)$/;"	f	class:Subsumer
subset	XorSubsumer.h	/^bool XorSubsumer::subset(const T1& A, const T2& B)$/;"	f	class:XorSubsumer
subset1	Subsumer.h	/^const Lit Subsumer::subset1(const T1& A, const T2& B)$/;"	f	class:Subsumer
subsetAbst	Subsumer.h	/^inline bool Subsumer::subsetAbst(const uint32_t A, const uint32_t B)$/;"	f	class:Subsumer
subsetAbst	XorSubsumer.h	/^inline bool XorSubsumer::subsetAbst(uint32_t A, uint32_t B)$/;"	f	class:XorSubsumer
subsume0	Subsumer.cpp	/^void Subsumer::subsume0(Clause& ps)$/;"	f	class:Subsumer
subsume0	XorSubsumer.cpp	/^void XorSubsumer::subsume0(XorClauseSimp ps)$/;"	f	class:XorSubsumer
subsume0AndSubsume1	Subsumer.cpp	/^const bool Subsumer::subsume0AndSubsume1()$/;"	f	class:Subsumer
subsume0BIN	Subsumer.cpp	/^void Subsumer::subsume0BIN(const Lit lit1, const vec<char>& lits, const uint32_t abst)$/;"	f	class:Subsumer
subsume0Happened	Subsumer.h	/^    struct subsume0Happened {$/;"	s	class:Subsumer
subsume0Orig	Subsumer.cpp	/^Subsumer::subsume0Happened Subsumer::subsume0Orig(const T& ps, uint32_t abs)$/;"	f	class:Subsumer
subsume1	Subsumer.cpp	/^const bool Subsumer::subsume1(vec<Lit>& ps, const bool wasLearnt)$/;"	f	class:Subsumer
subsume1	Subsumer.cpp	/^void Subsumer::subsume1(Clause& ps)$/;"	f	class:Subsumer
subsumeBinsWithBins	Subsumer.cpp	/^void Subsumer::subsumeBinsWithBins()$/;"	f	class:Subsumer
subsumeWithBinaries	Subsumer.cpp	/^const bool Subsumer::subsumeWithBinaries()$/;"	f	class:Subsumer
subsumedNonLearnt	Subsumer.h	/^        bool subsumedNonLearnt;$/;"	m	struct:Subsumer::subsume0Happened
subsumer	Solver.h	/^    Subsumer*           subsumer;$/;"	m	class:Solver
sumOfAllElems	BoundedQueue.h	/^    int64_t  sumOfAllElems;$/;"	m	class:bqueue
sum_gauss_called	Solver.h	/^    uint32_t sum_gauss_called;$/;"	m	class:Solver
sum_gauss_confl	Solver.h	/^    uint32_t sum_gauss_confl;$/;"	m	class:Solver
sum_gauss_prop	Solver.h	/^    uint32_t sum_gauss_prop;$/;"	m	class:Solver
sum_gauss_unit_truths	Solver.h	/^    uint32_t sum_gauss_unit_truths;$/;"	m	class:Solver
sumofqueue	BoundedQueue.h	/^    int64_t  sumofqueue;$/;"	m	class:bqueue
swapBoth	PackedRow.h	/^    void swapBoth(PackedRow b)$/;"	f	class:PackedRow
syncBinFromOthers	DataSync.cpp	/^const bool DataSync::syncBinFromOthers(const Lit lit, const vector<Lit>& bins, uint32_t& finished, vec<Watched>& ws)$/;"	f	class:DataSync
syncBinToOthers	DataSync.cpp	/^void DataSync::syncBinToOthers()$/;"	f	class:DataSync
syncData	DataSync.cpp	/^const bool DataSync::syncData()$/;"	f	class:DataSync
syncFinish	DataSync.h	/^        vec<uint32_t> syncFinish;$/;"	m	class:DataSync
sz	BoxedVec.h	/^        int sz;$/;"	m	struct:bvec::Vec_t
sz	Vec.h	/^    uint32_t sz;$/;"	m	class:vec
table	Map.h	/^    vec<Pair>* table;$/;"	m	class:Map
table	MatrixFinder.h	/^        vector<Var> table; \/\/var -> matrix$/;"	m	class:MatrixFinder
table	PartFinder.h	/^        vector<uint32_t> table; \/\/var -> part$/;"	m	class:PartFinder
table	VarReplacer.h	/^        vector<Lit> table; \/\/\/<Stores which variables have been replaced by which literals. Index by: table[VAR]$/;"	m	class:VarReplacer
table	XorFinder.h	/^        ClauseTable table;$/;"	m	class:XorFinder
takeMaxOfStats	Clause.h	/^    void takeMaxOfStats(Clause& other)$/;"	f	struct:Clause
tallyVotes	Solver.cpp	/^void Solver::tallyVotes(const vec<Clause*>& cs, vec<double>& votes) const$/;"	f	class:Solver
tallyVotes	Solver.cpp	/^void Solver::tallyVotes(const vec<XorClause*>& cs, vec<double>& votes) const$/;"	f	class:Solver
tallyVotesBin	Solver.cpp	/^void Solver::tallyVotesBin(vec<double>& votes) const$/;"	f	class:Solver
tarjan	SCCFinder.cpp	/^void SCCFinder::tarjan(const uint32_t vertex)$/;"	f	class:SCCFinder
testAllClauseAttach	Solver.h	/^inline void Solver::testAllClauseAttach() const$/;"	f	class:Solver
testAllClauseAttach	SolverDebug.cpp	/^void Solver::testAllClauseAttach() const$/;"	f	class:Solver
tmp	SCCFinder.h	/^        vec<uint32_t> tmp;$/;"	m	class:SCCFinder
tmpPs	FailedLitSearcher.h	/^        vec<Lit> tmpPs;$/;"	m	class:FailedLitSearcher
tmp_clause	Gaussian.h	/^    vec<Lit> tmp_clause;$/;"	m	class:Gaussian
toClearDontRemoveAcestor	FailedLitSearcher.h	/^        vec<Var> toClearDontRemoveAcestor;$/;"	m	class:FailedLitSearcher
toDeleteSet	UselessBinRemover.h	/^        vec<char> toDeleteSet;$/;"	m	class:UselessBinRemover
toInt	SolverTypes.h	/^    const uint32_t& toInt() const { \/\/ Guarantees small, positive integers suitable for array indexing.$/;"	f	class:Lit
toLbool	SolverTypes.h	/^inline lbool toLbool(const char   v)$/;"	f
toLeaveInPlace	XorFinder.h	/^        vector<bool> toLeaveInPlace;$/;"	m	class:XorFinder
toLit	SolverTypes.h	/^    static Lit toLit(uint32_t data)$/;"	f	class:Lit
toRecursiveProp	Solver.h	/^    std::stack<Lit>     toRecursiveProp;  \/\/\/<To reduce temoprary data creation overhead. Used in minimiseLeartFurther()$/;"	m	class:Solver
toRemove	XorFinder.h	/^        vector<bool> toRemove;$/;"	m	class:XorFinder
toReplaceBefore	FailedLitSearcher.h	/^        uint32_t toReplaceBefore;$/;"	m	class:FailedLitSearcher
toVisit	Subsumer.h	/^    vec<Lit> toVisit;      \/\/\/<Literals that we have visited from a given literal during subsumption w\/ non-existent binaries (list)$/;"	m	class:Subsumer
toVisitAll	Subsumer.h	/^    vec<char> toVisitAll;  \/\/\/<Literals that we have visited from a given literal during subsumption w\/ non-existent binaries (contains '1' for literal.toInt() that we visited)$/;"	m	class:Subsumer
topX	RestartTypeChooser.h	/^        const uint32_t topX; \/\/\/<The how many is the top X? 100 is default$/;"	m	class:RestartTypeChooser
tot_literals	Solver.h	/^    uint64_t clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Solver
totalNumElems	BoundedQueue.h	/^    uint64_t totalNumElems;$/;"	m	class:bqueue
totalSimplifyTime	Solver.h	/^    double      totalSimplifyTime;$/;"	m	class:Solver
totalTime	FailedLitSearcher.h	/^        double totalTime;$/;"	m	class:FailedLitSearcher
totalTime	SCCFinder.h	/^        double totalTime;$/;"	m	class:SCCFinder
totalTime	Subsumer.h	/^    double totalTime;                      \/\/\/<Total time spent in this class$/;"	m	class:Subsumer
totalTime	XorSubsumer.h	/^    double totalTime;$/;"	m	class:XorSubsumer
touch	Subsumer.h	/^inline void Subsumer::touch(const Lit p, const bool learnt)$/;"	f	class:Subsumer
touch	Subsumer.h	/^inline void Subsumer::touch(const Var x)$/;"	f	class:Subsumer
touchBlockedVar	Subsumer.h	/^inline void Subsumer::touchBlockedVar(const Var x)$/;"	f	class:Subsumer
touchChangeVars	Subsumer.h	/^inline void Subsumer::touchChangeVars(const Lit p)$/;"	f	class:Subsumer
touchedBlockedVars	Subsumer.h	/^    priority_queue<VarOcc, vector<VarOcc>, MyComp> touchedBlockedVars;$/;"	m	class:Subsumer
touchedBlockedVarsBool	Subsumer.h	/^    vec<char> touchedBlockedVarsBool;$/;"	m	class:Subsumer
touchedVars	Subsumer.h	/^    vec<char>              touchedVars;        \/\/\/<Is set to true when a variable is part of a removed clause. Also true initially (upon variable creation).$/;"	m	class:Subsumer
touchedVarsList	Subsumer.h	/^    vec<Var>               touchedVarsList;   \/\/\/<A list of the true elements in 'touched'.$/;"	m	class:Subsumer
trail	Solver.h	/^    vec<Lit>            trail;            \/\/\/< Assignment stack; stores all assigments made in the order they were made.$/;"	m	class:Solver
trail_lim	Solver.h	/^    vec<uint32_t>       trail_lim;        \/\/\/< Separator indices for different decision levels in 'trail'.$/;"	m	class:Solver
transMinimAndUpdateCache	Solver.cpp	/^void Solver::transMinimAndUpdateCache(const Lit lit, uint32_t& moreRecurProp)$/;"	f	class:Solver
transOTFCache	Solver.h	/^    vector<TransCache>  transOTFCache;$/;"	m	class:Solver
tris	CompleteDetachReattacher.h	/^                uint32_t tris;$/;"	m	class:CompleteDetachReatacher::ClausesStay
tryBoth	FailedLitSearcher.cpp	/^const bool FailedLitSearcher::tryBoth(const Lit lit1, const Lit lit2)$/;"	f	class:FailedLitSearcher
tryOneSetting	Subsumer.cpp	/^const bool Subsumer::tryOneSetting(const Lit lit)$/;"	f	class:Subsumer
twist	MersenneTwister.h	/^	uint32 twist( const uint32& m, const uint32& s0, const uint32& s1 ) const$/;"	f	class:MTRand
twoFileNamesPresent	Main.h	/^        bool twoFileNamesPresent;$/;"	m	class:Main
twoLongXors	FailedLitSearcher.h	/^        std::set<TwoLongXor> twoLongXors;$/;"	m	class:FailedLitSearcher
type	PropBy.h	/^        uint32_t type;$/;"	m	class:PropByFull
uint32	MersenneTwister.h	/^	typedef unsigned long uint32;  \/\/ unsigned integer type, at least 32 bits$/;"	t	class:MTRand
unEliminate	Subsumer.cpp	/^const bool Subsumer::unEliminate(const Var var)$/;"	f	class:Subsumer
unEliminate	XorSubsumer.cpp	/^const bool XorSubsumer::unEliminate(const Var var)$/;"	f	class:XorSubsumer
unPropagatedBin	FailedLitSearcher.h	/^        BitArray unPropagatedBin;$/;"	m	class:FailedLitSearcher
unWindGlue	Solver.h	/^    vec<Clause*>        unWindGlue;$/;"	m	class:Solver
unassigned_col	Gaussian.cpp	/^static const uint16_t unassigned_col = std::numeric_limits<uint16_t>::max();$/;"	v	file:
unassigned_var	Gaussian.cpp	/^static const Var unassigned_var = std::numeric_limits<Var>::max();$/;"	v	file:
uncheckedEnqueue	Solver.cpp	/^void Solver::uncheckedEnqueue(const Lit p, const PropBy& from)$/;"	f	class:Solver
uncheckedEnqueueLight	Solver.h	/^inline void Solver::uncheckedEnqueueLight(const Lit p)$/;"	f	class:Solver
uncheckedEnqueueLight2	Solver.h	/^inline void Solver::uncheckedEnqueueLight2(const Lit p, const uint32_t binSubLevel, const Lit lev2Ancestor, const bool learntLeadHere)$/;"	f	class:Solver
unit_conflict	Gaussian.h	/^    enum gaussian_ret {conflict, unit_conflict, propagation, unit_propagation, nothing};$/;"	e	enum:Gaussian::gaussian_ret
unit_propagation	Gaussian.h	/^    enum gaussian_ret {conflict, unit_conflict, propagation, unit_propagation, nothing};$/;"	e	enum:Gaussian::gaussian_ret
unit_truths	Gaussian.h	/^    uint32_t unit_truths; \/\/how many unitary (i.e. decisionLevel 0) truths have been found$/;"	m	class:Gaussian
unlinkClause	Subsumer.cpp	/^void Subsumer::unlinkClause(ClauseSimp c, const Var elim)$/;"	f	class:Subsumer
unlinkClause	XorSubsumer.cpp	/^void XorSubsumer::unlinkClause(XorClauseSimp c, const Var elim)$/;"	f	class:XorSubsumer
unlinkModifiedClause	XorSubsumer.cpp	/^void XorSubsumer::unlinkModifiedClause(vec<Lit>& origClause, XorClauseSimp c)$/;"	f	class:XorSubsumer
unlinkModifiedClauseNoDetachNoNULL	XorSubsumer.cpp	/^void XorSubsumer::unlinkModifiedClauseNoDetachNoNULL(vec<Lit>& origClause, XorClauseSimp c)$/;"	f	class:XorSubsumer
unregisterIteration	Subsumer.h	/^    void unregisterIteration(CSet& iter_set) { remove(iter_sets, &iter_set); }$/;"	f	class:Subsumer
unsetStrenghtened	Clause.h	/^    void unsetStrenghtened()$/;"	f	struct:Clause
unsign	SolverTypes.h	/^    Lit  unsign() const {$/;"	f	class:Lit
untilEnd	DimacsParser.cpp	/^std::string DimacsParser::untilEnd(StreamBuffer& in)$/;"	f	class:DimacsParser
update	Heap.h	/^    void update (uint32_t n)$/;"	f	class:Heap
updateAllOffsetsAndPointers	ClauseAllocator.cpp	/^void ClauseAllocator::updateAllOffsetsAndPointers(Solver* solver)$/;"	f	class:ClauseAllocator
updateOffsets	ClauseAllocator.cpp	/^void ClauseAllocator::updateOffsets(vec<vec<Watched> >& watches)$/;"	f	class:ClauseAllocator
updatePointers	ClauseAllocator.cpp	/^void ClauseAllocator::updatePointers(vec<T*>& toUpdate)$/;"	f	class:ClauseAllocator
updatePointers	ClauseAllocator.cpp	/^void ClauseAllocator::updatePointers(vector<Clause*>& toUpdate)$/;"	f	class:ClauseAllocator
updatePointers	ClauseAllocator.cpp	/^void ClauseAllocator::updatePointers(vector<XorClause*>& toUpdate)$/;"	f	class:ClauseAllocator
updatePointers	ClauseAllocator.cpp	/^void ClauseAllocator::updatePointers(vector<pair<Clause*, uint32_t> >& toUpdate)$/;"	f	class:ClauseAllocator
updateTransCache	Solver.h	/^    uint64_t updateTransCache; \/\/\/<Number of times the transitive OTF-reduction cache has been updated$/;"	m	class:Solver
update_last_one_in_col	Gaussian.cpp	/^inline void Gaussian::update_last_one_in_col(matrixset& m)$/;"	f	class:Gaussian
update_matrix_by_col_all	Gaussian.cpp	/^void Gaussian::update_matrix_by_col_all(matrixset& m)$/;"	f	class:Gaussian
update_matrix_col	Gaussian.cpp	/^void Gaussian::update_matrix_col(matrixset& m, const Var var, const uint32_t col)$/;"	f	class:Gaussian
useful_confl	Gaussian.h	/^    uint32_t useful_confl; \/\/how many times Gauss gave conflict as a result$/;"	m	class:Gaussian
useful_prop	Gaussian.h	/^    uint32_t useful_prop; \/\/how many times Gauss gave propagation as a result$/;"	m	class:Gaussian
uselessBin	FailedLitSearcher.h	/^        vec<Lit> uselessBin;$/;"	m	class:FailedLitSearcher
val	DoublePackedRow.h	/^                const unsigned char& val;$/;"	m	class:MINISAT::DoublePackedRow::BitIterConst
val	DoublePackedRow.h	/^                unsigned char& val;$/;"	m	class:MINISAT::DoublePackedRow::BitIter
value	SharedData.h	/^        vec<lbool> value;$/;"	m	class:SharedData
value	Solver.h	/^inline lbool    Solver::value         (const Lit p) const$/;"	f	class:Solver
value	Solver.h	/^inline lbool    Solver::value         (const Var x) const$/;"	f	class:Solver
value	SolverTypes.h	/^    char     value;$/;"	m	class:lbool
value	SolverTypes.h	/^    char value;$/;"	m	class:llbool
var	FailedLitSearcher.h	/^            Var var[2];$/;"	m	class:FailedLitSearcher::TwoLongXor
var	SolverTypes.h	/^    Var  var() const {$/;"	f	class:Lit
var	Subsumer.h	/^            Var var;$/;"	m	class:Subsumer::VarOcc
varBumpActivity	Solver.h	/^inline void Solver::varBumpActivity(Var v)$/;"	f	class:Solver
varDecayActivity	Solver.h	/^inline void Solver::varDecayActivity()$/;"	f	class:Solver
varElimed1	SCCFinder.h	/^        const vec<char>& varElimed1;$/;"	m	class:SCCFinder
varElimed2	SCCFinder.h	/^        const vec<char>& varElimed2;$/;"	m	class:SCCFinder
varHasBeenReplaced	VarReplacer.h	/^inline const bool VarReplacer::varHasBeenReplaced(const Var var) const$/;"	f	class:VarReplacer
varReplacer	Solver.h	/^    VarReplacer*        varReplacer;$/;"	m	class:Solver
var_Undef	SolverTypes.h	35;"	d
var_elimed	Subsumer.h	/^    vec<char> var_elimed;                  \/\/\/<Contains TRUE if var has been eliminated$/;"	m	class:Subsumer
var_elimed	XorSubsumer.h	/^    vec<char> var_elimed;$/;"	m	class:XorSubsumer
var_inc	Solver.h	/^    uint32_t            var_inc;          \/\/\/< Amount to bump next variable with.$/;"	m	class:Solver
var_is_in	Gaussian.h	/^    BitArray var_is_in; \/\/variable is part of the the matrix. var_is_in's size is _minimal_ so you should check whether var_is_in.getSize() < var before issuing var_is_in[var]$/;"	m	class:Gaussian
var_is_set	Gaussian.h	/^        BitArray var_is_set;$/;"	m	class:Gaussian::matrixset
vec	Vec.h	/^    vec(T* array, uint32_t size)     : data(array), sz(size), cap(size) { }      \/\/ (takes ownership of array -- will be deallocated with 'free()')$/;"	f	class:vec
vec	Vec.h	/^    vec(const vec<T>& other)         : data(NULL) , sz(0)   , cap(0)    { myCopy(other); }$/;"	f	class:vec
vec	Vec.h	/^    vec(uint32_t size)               : data(NULL) , sz(0)   , cap(0)    { growTo(size); }$/;"	f	class:vec
vec	Vec.h	/^    vec(uint32_t size, const T& pad) : data(NULL) , sz(0)   , cap(0)    { growTo(size, pad); }$/;"	f	class:vec
vec	Vec.h	/^    vec(void)                        : data(NULL) , sz(0)   , cap(0)    { }$/;"	f	class:vec
vec	Vec.h	/^class vec {$/;"	c
verbosity	SolverConf.h	/^        int       verbosity;          \/\/\/<Verbosity level. 0=silent, 1=some progress report, 2=lots of report, 3 = all report       (default 2)$/;"	m	class:SolverConf
verifyBinClauses	SolverDebug.cpp	/^const bool Solver::verifyBinClauses() const$/;"	f	class:Solver
verifyClauses	SolverDebug.cpp	/^const bool Solver::verifyClauses(const vec<Clause*>& cs) const$/;"	f	class:Solver
verifyIntegrity	Subsumer.cpp	/^const bool Subsumer::verifyIntegrity()$/;"	f	class:Subsumer
verifyModel	SolverDebug.cpp	/^const bool Solver::verifyModel() const$/;"	f	class:Solver
verifyXorClauses	SolverDebug.cpp	/^const bool Solver::verifyXorClauses() const$/;"	f	class:Solver
vivifyClauses	ClauseVivifier.cpp	/^const bool ClauseVivifier::vivifyClauses()$/;"	f	class:ClauseVivifier
vivifyClauses2	ClauseVivifier.cpp	/^const bool ClauseVivifier::vivifyClauses2(vec<Clause*>& clauses)$/;"	f	class:ClauseVivifier
watches	Solver.h	/^    vec<vec<Watched> >  watches;          \/\/\/< 'watches[lit]' is a list of constraints watching 'lit' (will go there if literal becomes true).$/;"	m	class:Solver
where	CSet.h	/^    vec<uint32_t>       where;  \/\/\/<Map clause ID to position in 'which'.$/;"	m	class:CSet
where	XSet.h	/^    vec<uint32_t>       where;  \/\/ Map clause ID to position in 'which'.$/;"	m	class:XSet
which	CSet.h	/^    vec<ClauseSimp>     which;  \/\/\/< List of clauses (for fast iteration). May contain 'Clause_NULL'.$/;"	m	class:CSet
which	XSet.h	/^    vec<XorClauseSimp> which;  \/\/ List of clauses (for fast iteration). May contain 'Clause_NULL'.$/;"	m	class:XSet
wrong	UselessBinRemover.h	/^        vec<Lit> wrong;$/;"	m	class:UselessBinRemover
x	SolverTypes.h	/^    uint32_t     x;$/;"	m	class:Lit
xorBoth	PackedRow.h	/^    void xorBoth(const PackedRow& b)$/;"	f	class:PackedRow
xorClauseIsAttached	SolverDebug.cpp	/^const bool Solver::xorClauseIsAttached(const XorClause& c) const$/;"	f	class:Solver
xorClauseSizes	FailedLitSearcher.h	/^        vec<uint32_t> xorClauseSizes;$/;"	m	class:FailedLitSearcher
xorClauseTouched	FailedLitSearcher.h	/^        BitArray xorClauseTouched;$/;"	m	class:FailedLitSearcher
xorClausesRemoved	PartHandler.h	/^        vec<XorClause*> xorClausesRemoved;$/;"	m	class:PartHandler
xorEqualFalse	Clause.h	/^    inline const bool xorEqualFalse() const$/;"	f	class:XorClause
xorEqualFalse	XorSubsumer.h	/^        bool xorEqualFalse;$/;"	m	struct:XorSubsumer::XorElimedClause
xorSubsumer	Solver.h	/^    XorSubsumer*        xorSubsumer;$/;"	m	class:Solver
xorTwoClauses	XorSubsumer.cpp	/^void XorSubsumer::xorTwoClauses(const T& c1, const T& c2, vec<Lit>& xored)$/;"	f	class:XorSubsumer
xorclauses	ClauseCleaner.h	/^        enum ClauseSetType {clauses, binaryClauses, xorclauses, learnts};$/;"	e	enum:ClauseCleaner::ClauseSetType
xorclauses	Gaussian.h	/^    vector<XorClause*> xorclauses;$/;"	m	class:Gaussian
xorclauses	Solver.h	/^    vec<XorClause*>     xorclauses;       \/\/\/< List of problem xor-clauses. Will be freed$/;"	m	class:Solver
~BitArray	BitArray.h	/^    ~BitArray()$/;"	f	class:BitArray
~ClauseAllocator	ClauseAllocator.cpp	/^ClauseAllocator::~ClauseAllocator()$/;"	f	class:ClauseAllocator
~Gaussian	Gaussian.cpp	/^Gaussian::~Gaussian()$/;"	f	class:Gaussian
~Map	Map.h	/^    ~Map () { delete [] table; }$/;"	f	class:Map
~PackedMatrix	PackedMatrix.h	/^    ~PackedMatrix()$/;"	f	class:PackedMatrix
~Solver	Solver.cpp	/^Solver::~Solver()$/;"	f	class:Solver
~VarReplacer	VarReplacer.cpp	/^VarReplacer::~VarReplacer()$/;"	f	class:VarReplacer
~altvec	BoxedVec.h	/^   ~altvec(void) { clear(true); }$/;"	f	class:bvec
~vec	Vec.h	/^   ~vec(void)                                                      { clear(true); }$/;"	f	class:vec
