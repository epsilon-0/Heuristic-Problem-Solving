#include <cassert>
#include "truthTable.h"

const unsigned TruthTable32::TMasks[5][2] = {
   { 0x55555555, 0xAAAAAAAA },
   { 0x33333333, 0xCCCCCCCC },
   { 0x0F0F0F0F, 0xF0F0F0F0 },
   { 0x00FF00FF, 0xFF00FF00 },
   { 0x0000FFFF, 0xFFFF0000 }
};

const unsigned TruthTable32::VMasks[6] = {
   0x1, 0x3, 0xF, 0xFF, 0xFFFF, 0xFFFFFFFF
};

const unsigned char TruthTable32::Permute5Var[120][5] = {
{0,1,2,3,4},{1,0,2,3,4},{0,2,1,3,4},{1,2,0,3,4},{2,0,1,3,4},{2,1,0,3,4},
{0,1,3,2,4},{1,0,3,2,4},{0,2,3,1,4},{1,2,3,0,4},{2,0,3,1,4},{2,1,3,0,4},
{0,3,1,2,4},{1,3,0,2,4},{0,3,2,1,4},{1,3,2,0,4},{2,3,0,1,4},{2,3,1,0,4},
{3,0,1,2,4},{3,1,0,2,4},{3,0,2,1,4},{3,1,2,0,4},{3,2,0,1,4},{3,2,1,0,4},
{0,1,2,4,3},{1,0,2,4,3},{0,2,1,4,3},{1,2,0,4,3},{2,0,1,4,3},{2,1,0,4,3},
{0,1,3,4,2},{1,0,3,4,2},{0,2,3,4,1},{1,2,3,4,0},{2,0,3,4,1},{2,1,3,4,0},
{0,3,1,4,2},{1,3,0,4,2},{0,3,2,4,1},{1,3,2,4,0},{2,3,0,4,1},{2,3,1,4,0},
{3,0,1,4,2},{3,1,0,4,2},{3,0,2,4,1},{3,1,2,4,0},{3,2,0,4,1},{3,2,1,4,0},
{0,1,4,2,3},{1,0,4,2,3},{0,2,4,1,3},{1,2,4,0,3},{2,0,4,1,3},{2,1,4,0,3},
{0,1,4,3,2},{1,0,4,3,2},{0,2,4,3,1},{1,2,4,3,0},{2,0,4,3,1},{2,1,4,3,0},
{0,3,4,1,2},{1,3,4,0,2},{0,3,4,2,1},{1,3,4,2,0},{2,3,4,0,1},{2,3,4,1,0},
{3,0,4,1,2},{3,1,4,0,2},{3,0,4,2,1},{3,1,4,2,0},{3,2,4,0,1},{3,2,4,1,0},
{0,4,1,2,3},{1,4,0,2,3},{0,4,2,1,3},{1,4,2,0,3},{2,4,0,1,3},{2,4,1,0,3},
{0,4,1,3,2},{1,4,0,3,2},{0,4,2,3,1},{1,4,2,3,0},{2,4,0,3,1},{2,4,1,3,0},
{0,4,3,1,2},{1,4,3,0,2},{0,4,3,2,1},{1,4,3,2,0},{2,4,3,0,1},{2,4,3,1,0},
{3,4,0,1,2},{3,4,1,0,2},{3,4,0,2,1},{3,4,1,2,0},{3,4,2,0,1},{3,4,2,1,0},
{4,0,1,2,3},{4,1,0,2,3},{4,0,2,1,3},{4,1,2,0,3},{4,2,0,1,3},{4,2,1,0,3},
{4,0,1,3,2},{4,1,0,3,2},{4,0,2,3,1},{4,1,2,3,0},{4,2,0,3,1},{4,2,1,3,0},
{4,0,3,1,2},{4,1,3,0,2},{4,0,3,2,1},{4,1,3,2,0},{4,2,3,0,1},{4,2,3,1,0},
{4,3,0,1,2},{4,3,1,0,2},{4,3,0,2,1},{4,3,1,2,0},{4,3,2,0,1},{4,3,2,1,0} 
};

const unsigned TruthTable32::Stretch3Var[256][4] = {
{0x0,0x0,0x0,0x0},
{0x3,0x5,0x11,0x101},
{0xc,0xa,0x22,0x202},
{0xf,0xf,0x33,0x303},
{0x30,0x50,0x44,0x404},
{0x33,0x55,0x55,0x505},
{0x3c,0x5a,0x66,0x606},
{0x3f,0x5f,0x77,0x707},
{0xc0,0xa0,0x88,0x808},
{0xc3,0xa5,0x99,0x909},
{0xcc,0xaa,0xaa,0xa0a},
{0xcf,0xaf,0xbb,0xb0b},
{0xf0,0xf0,0xcc,0xc0c},
{0xf3,0xf5,0xdd,0xd0d},
{0xfc,0xfa,0xee,0xe0e},
{0xff,0xff,0xff,0xf0f},
{0x300,0x500,0x1100,0x1010},
{0x303,0x505,0x1111,0x1111},
{0x30c,0x50a,0x1122,0x1212},
{0x30f,0x50f,0x1133,0x1313},
{0x330,0x550,0x1144,0x1414},
{0x333,0x555,0x1155,0x1515},
{0x33c,0x55a,0x1166,0x1616},
{0x33f,0x55f,0x1177,0x1717},
{0x3c0,0x5a0,0x1188,0x1818},
{0x3c3,0x5a5,0x1199,0x1919},
{0x3cc,0x5aa,0x11aa,0x1a1a},
{0x3cf,0x5af,0x11bb,0x1b1b},
{0x3f0,0x5f0,0x11cc,0x1c1c},
{0x3f3,0x5f5,0x11dd,0x1d1d},
{0x3fc,0x5fa,0x11ee,0x1e1e},
{0x3ff,0x5ff,0x11ff,0x1f1f},
{0xc00,0xa00,0x2200,0x2020},
{0xc03,0xa05,0x2211,0x2121},
{0xc0c,0xa0a,0x2222,0x2222},
{0xc0f,0xa0f,0x2233,0x2323},
{0xc30,0xa50,0x2244,0x2424},
{0xc33,0xa55,0x2255,0x2525},
{0xc3c,0xa5a,0x2266,0x2626},
{0xc3f,0xa5f,0x2277,0x2727},
{0xcc0,0xaa0,0x2288,0x2828},
{0xcc3,0xaa5,0x2299,0x2929},
{0xccc,0xaaa,0x22aa,0x2a2a},
{0xccf,0xaaf,0x22bb,0x2b2b},
{0xcf0,0xaf0,0x22cc,0x2c2c},
{0xcf3,0xaf5,0x22dd,0x2d2d},
{0xcfc,0xafa,0x22ee,0x2e2e},
{0xcff,0xaff,0x22ff,0x2f2f},
{0xf00,0xf00,0x3300,0x3030},
{0xf03,0xf05,0x3311,0x3131},
{0xf0c,0xf0a,0x3322,0x3232},
{0xf0f,0xf0f,0x3333,0x3333},
{0xf30,0xf50,0x3344,0x3434},
{0xf33,0xf55,0x3355,0x3535},
{0xf3c,0xf5a,0x3366,0x3636},
{0xf3f,0xf5f,0x3377,0x3737},
{0xfc0,0xfa0,0x3388,0x3838},
{0xfc3,0xfa5,0x3399,0x3939},
{0xfcc,0xfaa,0x33aa,0x3a3a},
{0xfcf,0xfaf,0x33bb,0x3b3b},
{0xff0,0xff0,0x33cc,0x3c3c},
{0xff3,0xff5,0x33dd,0x3d3d},
{0xffc,0xffa,0x33ee,0x3e3e},
{0xfff,0xfff,0x33ff,0x3f3f},
{0x3000,0x5000,0x4400,0x4040},
{0x3003,0x5005,0x4411,0x4141},
{0x300c,0x500a,0x4422,0x4242},
{0x300f,0x500f,0x4433,0x4343},
{0x3030,0x5050,0x4444,0x4444},
{0x3033,0x5055,0x4455,0x4545},
{0x303c,0x505a,0x4466,0x4646},
{0x303f,0x505f,0x4477,0x4747},
{0x30c0,0x50a0,0x4488,0x4848},
{0x30c3,0x50a5,0x4499,0x4949},
{0x30cc,0x50aa,0x44aa,0x4a4a},
{0x30cf,0x50af,0x44bb,0x4b4b},
{0x30f0,0x50f0,0x44cc,0x4c4c},
{0x30f3,0x50f5,0x44dd,0x4d4d},
{0x30fc,0x50fa,0x44ee,0x4e4e},
{0x30ff,0x50ff,0x44ff,0x4f4f},
{0x3300,0x5500,0x5500,0x5050},
{0x3303,0x5505,0x5511,0x5151},
{0x330c,0x550a,0x5522,0x5252},
{0x330f,0x550f,0x5533,0x5353},
{0x3330,0x5550,0x5544,0x5454},
{0x3333,0x5555,0x5555,0x5555},
{0x333c,0x555a,0x5566,0x5656},
{0x333f,0x555f,0x5577,0x5757},
{0x33c0,0x55a0,0x5588,0x5858},
{0x33c3,0x55a5,0x5599,0x5959},
{0x33cc,0x55aa,0x55aa,0x5a5a},
{0x33cf,0x55af,0x55bb,0x5b5b},
{0x33f0,0x55f0,0x55cc,0x5c5c},
{0x33f3,0x55f5,0x55dd,0x5d5d},
{0x33fc,0x55fa,0x55ee,0x5e5e},
{0x33ff,0x55ff,0x55ff,0x5f5f},
{0x3c00,0x5a00,0x6600,0x6060},
{0x3c03,0x5a05,0x6611,0x6161},
{0x3c0c,0x5a0a,0x6622,0x6262},
{0x3c0f,0x5a0f,0x6633,0x6363},
{0x3c30,0x5a50,0x6644,0x6464},
{0x3c33,0x5a55,0x6655,0x6565},
{0x3c3c,0x5a5a,0x6666,0x6666},
{0x3c3f,0x5a5f,0x6677,0x6767},
{0x3cc0,0x5aa0,0x6688,0x6868},
{0x3cc3,0x5aa5,0x6699,0x6969},
{0x3ccc,0x5aaa,0x66aa,0x6a6a},
{0x3ccf,0x5aaf,0x66bb,0x6b6b},
{0x3cf0,0x5af0,0x66cc,0x6c6c},
{0x3cf3,0x5af5,0x66dd,0x6d6d},
{0x3cfc,0x5afa,0x66ee,0x6e6e},
{0x3cff,0x5aff,0x66ff,0x6f6f},
{0x3f00,0x5f00,0x7700,0x7070},
{0x3f03,0x5f05,0x7711,0x7171},
{0x3f0c,0x5f0a,0x7722,0x7272},
{0x3f0f,0x5f0f,0x7733,0x7373},
{0x3f30,0x5f50,0x7744,0x7474},
{0x3f33,0x5f55,0x7755,0x7575},
{0x3f3c,0x5f5a,0x7766,0x7676},
{0x3f3f,0x5f5f,0x7777,0x7777},
{0x3fc0,0x5fa0,0x7788,0x7878},
{0x3fc3,0x5fa5,0x7799,0x7979},
{0x3fcc,0x5faa,0x77aa,0x7a7a},
{0x3fcf,0x5faf,0x77bb,0x7b7b},
{0x3ff0,0x5ff0,0x77cc,0x7c7c},
{0x3ff3,0x5ff5,0x77dd,0x7d7d},
{0x3ffc,0x5ffa,0x77ee,0x7e7e},
{0x3fff,0x5fff,0x77ff,0x7f7f},
{0xc000,0xa000,0x8800,0x8080},
{0xc003,0xa005,0x8811,0x8181},
{0xc00c,0xa00a,0x8822,0x8282},
{0xc00f,0xa00f,0x8833,0x8383},
{0xc030,0xa050,0x8844,0x8484},
{0xc033,0xa055,0x8855,0x8585},
{0xc03c,0xa05a,0x8866,0x8686},
{0xc03f,0xa05f,0x8877,0x8787},
{0xc0c0,0xa0a0,0x8888,0x8888},
{0xc0c3,0xa0a5,0x8899,0x8989},
{0xc0cc,0xa0aa,0x88aa,0x8a8a},
{0xc0cf,0xa0af,0x88bb,0x8b8b},
{0xc0f0,0xa0f0,0x88cc,0x8c8c},
{0xc0f3,0xa0f5,0x88dd,0x8d8d},
{0xc0fc,0xa0fa,0x88ee,0x8e8e},
{0xc0ff,0xa0ff,0x88ff,0x8f8f},
{0xc300,0xa500,0x9900,0x9090},
{0xc303,0xa505,0x9911,0x9191},
{0xc30c,0xa50a,0x9922,0x9292},
{0xc30f,0xa50f,0x9933,0x9393},
{0xc330,0xa550,0x9944,0x9494},
{0xc333,0xa555,0x9955,0x9595},
{0xc33c,0xa55a,0x9966,0x9696},
{0xc33f,0xa55f,0x9977,0x9797},
{0xc3c0,0xa5a0,0x9988,0x9898},
{0xc3c3,0xa5a5,0x9999,0x9999},
{0xc3cc,0xa5aa,0x99aa,0x9a9a},
{0xc3cf,0xa5af,0x99bb,0x9b9b},
{0xc3f0,0xa5f0,0x99cc,0x9c9c},
{0xc3f3,0xa5f5,0x99dd,0x9d9d},
{0xc3fc,0xa5fa,0x99ee,0x9e9e},
{0xc3ff,0xa5ff,0x99ff,0x9f9f},
{0xcc00,0xaa00,0xaa00,0xa0a0},
{0xcc03,0xaa05,0xaa11,0xa1a1},
{0xcc0c,0xaa0a,0xaa22,0xa2a2},
{0xcc0f,0xaa0f,0xaa33,0xa3a3},
{0xcc30,0xaa50,0xaa44,0xa4a4},
{0xcc33,0xaa55,0xaa55,0xa5a5},
{0xcc3c,0xaa5a,0xaa66,0xa6a6},
{0xcc3f,0xaa5f,0xaa77,0xa7a7},
{0xccc0,0xaaa0,0xaa88,0xa8a8},
{0xccc3,0xaaa5,0xaa99,0xa9a9},
{0xcccc,0xaaaa,0xaaaa,0xaaaa},
{0xcccf,0xaaaf,0xaabb,0xabab},
{0xccf0,0xaaf0,0xaacc,0xacac},
{0xccf3,0xaaf5,0xaadd,0xadad},
{0xccfc,0xaafa,0xaaee,0xaeae},
{0xccff,0xaaff,0xaaff,0xafaf},
{0xcf00,0xaf00,0xbb00,0xb0b0},
{0xcf03,0xaf05,0xbb11,0xb1b1},
{0xcf0c,0xaf0a,0xbb22,0xb2b2},
{0xcf0f,0xaf0f,0xbb33,0xb3b3},
{0xcf30,0xaf50,0xbb44,0xb4b4},
{0xcf33,0xaf55,0xbb55,0xb5b5},
{0xcf3c,0xaf5a,0xbb66,0xb6b6},
{0xcf3f,0xaf5f,0xbb77,0xb7b7},
{0xcfc0,0xafa0,0xbb88,0xb8b8},
{0xcfc3,0xafa5,0xbb99,0xb9b9},
{0xcfcc,0xafaa,0xbbaa,0xbaba},
{0xcfcf,0xafaf,0xbbbb,0xbbbb},
{0xcff0,0xaff0,0xbbcc,0xbcbc},
{0xcff3,0xaff5,0xbbdd,0xbdbd},
{0xcffc,0xaffa,0xbbee,0xbebe},
{0xcfff,0xafff,0xbbff,0xbfbf},
{0xf000,0xf000,0xcc00,0xc0c0},
{0xf003,0xf005,0xcc11,0xc1c1},
{0xf00c,0xf00a,0xcc22,0xc2c2},
{0xf00f,0xf00f,0xcc33,0xc3c3},
{0xf030,0xf050,0xcc44,0xc4c4},
{0xf033,0xf055,0xcc55,0xc5c5},
{0xf03c,0xf05a,0xcc66,0xc6c6},
{0xf03f,0xf05f,0xcc77,0xc7c7},
{0xf0c0,0xf0a0,0xcc88,0xc8c8},
{0xf0c3,0xf0a5,0xcc99,0xc9c9},
{0xf0cc,0xf0aa,0xccaa,0xcaca},
{0xf0cf,0xf0af,0xccbb,0xcbcb},
{0xf0f0,0xf0f0,0xcccc,0xcccc},
{0xf0f3,0xf0f5,0xccdd,0xcdcd},
{0xf0fc,0xf0fa,0xccee,0xcece},
{0xf0ff,0xf0ff,0xccff,0xcfcf},
{0xf300,0xf500,0xdd00,0xd0d0},
{0xf303,0xf505,0xdd11,0xd1d1},
{0xf30c,0xf50a,0xdd22,0xd2d2},
{0xf30f,0xf50f,0xdd33,0xd3d3},
{0xf330,0xf550,0xdd44,0xd4d4},
{0xf333,0xf555,0xdd55,0xd5d5},
{0xf33c,0xf55a,0xdd66,0xd6d6},
{0xf33f,0xf55f,0xdd77,0xd7d7},
{0xf3c0,0xf5a0,0xdd88,0xd8d8},
{0xf3c3,0xf5a5,0xdd99,0xd9d9},
{0xf3cc,0xf5aa,0xddaa,0xdada},
{0xf3cf,0xf5af,0xddbb,0xdbdb},
{0xf3f0,0xf5f0,0xddcc,0xdcdc},
{0xf3f3,0xf5f5,0xdddd,0xdddd},
{0xf3fc,0xf5fa,0xddee,0xdede},
{0xf3ff,0xf5ff,0xddff,0xdfdf},
{0xfc00,0xfa00,0xee00,0xe0e0},
{0xfc03,0xfa05,0xee11,0xe1e1},
{0xfc0c,0xfa0a,0xee22,0xe2e2},
{0xfc0f,0xfa0f,0xee33,0xe3e3},
{0xfc30,0xfa50,0xee44,0xe4e4},
{0xfc33,0xfa55,0xee55,0xe5e5},
{0xfc3c,0xfa5a,0xee66,0xe6e6},
{0xfc3f,0xfa5f,0xee77,0xe7e7},
{0xfcc0,0xfaa0,0xee88,0xe8e8},
{0xfcc3,0xfaa5,0xee99,0xe9e9},
{0xfccc,0xfaaa,0xeeaa,0xeaea},
{0xfccf,0xfaaf,0xeebb,0xebeb},
{0xfcf0,0xfaf0,0xeecc,0xecec},
{0xfcf3,0xfaf5,0xeedd,0xeded},
{0xfcfc,0xfafa,0xeeee,0xeeee},
{0xfcff,0xfaff,0xeeff,0xefef},
{0xff00,0xff00,0xff00,0xf0f0},
{0xff03,0xff05,0xff11,0xf1f1},
{0xff0c,0xff0a,0xff22,0xf2f2},
{0xff0f,0xff0f,0xff33,0xf3f3},
{0xff30,0xff50,0xff44,0xf4f4},
{0xff33,0xff55,0xff55,0xf5f5},
{0xff3c,0xff5a,0xff66,0xf6f6},
{0xff3f,0xff5f,0xff77,0xf7f7},
{0xffc0,0xffa0,0xff88,0xf8f8},
{0xffc3,0xffa5,0xff99,0xf9f9},
{0xffcc,0xffaa,0xffaa,0xfafa},
{0xffcf,0xffaf,0xffbb,0xfbfb},
{0xfff0,0xfff0,0xffcc,0xfcfc},
{0xfff3,0xfff5,0xffdd,0xfdfd},
{0xfffc,0xfffa,0xffee,0xfefe},
{0xffff,0xffff,0xffff,0xffff}
};

TruthTable32::TruthTable32( unsigned varNum, unsigned table )
{
   assert( varNum <= 5 );
   _varNum = varNum;
   _table = table;
}

TruthTable32::~TruthTable32()
{
}

void
TruthTable32::clear()
{
   _varNum = 0;
   _table = 0;
}

void
TruthTable32::changeVarPhase( unsigned v )
{
   assert( v < _varNum );
   const unsigned shift = 1 << v;

   _table = ( ( _table & TMasks[v][0] ) << shift ) |
            ( ( _table & TMasks[v][1] ) >> shift );
}

void
TruthTable32::cofactor0( unsigned v )
{
   assert( v < _varNum );
   const unsigned shift = 1 << v;
   
   _table &= TMasks[v][0];
   _table |= ( _table << shift );
}

void
TruthTable32::cofactor1( unsigned v )
{
   assert( v < _varNum );
   const unsigned shift = 1 << v;

   _table &= TMasks[v][1];
   _table |= ( _table >> shift );
}

unsigned
TruthTable32::getTable() const
{
   return _table;
}

unsigned
TruthTable32::getVarNum() const
{
   return _varNum;
}

void
TruthTable32::pushVar()
{
   assert( _varNum < 5 );
   const unsigned shift =  1 << _varNum;
   _table |=  _table << shift;
   ++_varNum;
}

void
TruthTable32::setElementary( unsigned v )
{
   assert( v < _varNum );
   _table = TMasks[v][1] & VMasks[_varNum];
}

void
TruthTable32::setVarNum( unsigned num )
{
   assert( num < 6 );
   _varNum = num;
}

void
TruthTable32::setTable( unsigned table )
{
   _table = table;
}

bool
TruthTable32::isContradiction() const
{
   return ( _table == 0 );
}

bool
TruthTable32::isTautology() const
{
   return ( _table == VMasks[_varNum] );
}
   
void
TruthTable32::shrink( unsigned varNum, unsigned vpos )
{
   assert( _varNum >= varNum );
   if( _varNum == 0 )
      return;
   unsigned i, j, vptr = _varNum - 1;
   for( i = 0; i < varNum; vpos = vpos >> 1 )
      if( vpos & 1 )
      {
         for( j = i; j < vptr; j++ )
            swapAdjacentVar( j );
         if( --vptr < varNum ) break;
      }
      else ++i;
   _varNum = varNum;
   _table &= VMasks[varNum];
}

void
TruthTable32::stretch( unsigned varNum, unsigned vpos )
{
   assert( _varNum <= varNum );
   unsigned i, j, vptr = _varNum;
   
   while( _varNum < varNum ) pushVar();
   for( i = 0; i < varNum; i++, vpos = vpos >> 1 )
      if( vpos & 1 )
      {
         for( j = vptr; j > i; j-- )
            swapAdjacentVar( j - 1 );
         if( ++vptr == varNum ) return;
      }
}

void
TruthTable32::swapAdjacentVar( unsigned v )
{
   assert( v + 1 < _varNum );
   static const unsigned PMasks[4][3] = {
      { 0x99999999, 0x22222222, 0x44444444 },
      { 0xC3C3C3C3, 0x0C0C0C0C, 0x30303030 },
      { 0xF00FF00F, 0x00F000F0, 0x0F000F00 },
      { 0xFF0000FF, 0x0000FF00, 0x00FF0000 }
   };
   const unsigned shift = 1 << v;

   _table = ( _table & PMasks[v][0] ) | 
            ( ( _table & PMasks[v][1] ) << shift ) |
            ( ( _table & PMasks[v][2] ) >> shift );
}

TruthTable32
TruthTable32::operator ~ () const
{
   return TruthTable32( _varNum, (~_table) & VMasks[_varNum] );
}

TruthTable32
TruthTable32::operator | ( const TruthTable32 &b ) const
{
   return TruthTable32( _varNum, _table | b._table );
}

TruthTable32
TruthTable32::operator & ( const TruthTable32 &b ) const
{
   return TruthTable32( _varNum, _table & b._table );
}

void
TruthTable32::operator &= ( const TruthTable32 &b )
{
   _table &= b._table;
}

bool
TruthTable32::operator == ( const TruthTable32 &b ) const
{
   return ( _table == b._table );
}

bool
TruthTable32::operator != ( const TruthTable32 &b ) const
{
   return ( _table != b._table );
}

void
TruthTable32::changePhase( unsigned phase )
{
   for( unsigned i = 0; phase != 0 && i < _varNum; phase>>=1, ++i )
      if( phase & 1 )
         changeVarPhase( i );
   if( phase & 1 )
      _table = (~_table) & VMasks[_varNum];
}  

void
TruthTable32::permute( unsigned permutation, bool reverse )
{
   if( _varNum <= 1 ) return;
   const unsigned msize = 1 << _varNum;
   unsigned i, v, result = 0;
   vector<unsigned> minterms( msize );

   for( i = 0; i < msize; ++i )
   {
      minterms[i] = 0;
      for( v = 0; v < _varNum; ++v )
         if( i & ( 1 << v ) )
               minterms[i] |= ( 1 << getPermuteIndex( permutation, v ) );
   } 
   if( reverse )
   {
      for( i = 0; i < msize; i++ )
         if( _table & ( 1 << minterms[i] ) )
            result |= ( 1 << i );
   }
   else
   {
      for( i = 0; i < msize; i++ )
         if( _table & ( 1 << i ) )
            result |= ( 1 << minterms[i] );
   }
   _table = result;
}

void
TruthTable32::changePhasePermute( unsigned phase, unsigned permutation, bool reverse )
{
   if( reverse )
   {
      permute( permutation, reverse );
      changePhase( phase );
   }
   else
   {
      changePhase( phase );
      permute( permutation, reverse );
   }
}

void
TruthTable32::changePhasePermute( vector<unsigned> &inputs, unsigned phase,
                                  unsigned permutation, bool reverse )
{
   const unsigned varNum = inputs.size();
   unsigned i;
   vector<unsigned> orgInputs = inputs;
   if( reverse )
      for( i = 0; i < varNum; i++, phase >>= 1 )
         inputs[i] = orgInputs[getPermuteIndex( permutation, i )] ^ (phase & 1);
   else
      for( i = 0; i < varNum; i++, phase >>= 1 )
         inputs[getPermuteIndex( permutation, i )] = orgInputs[i] ^ (phase & 1);
}
                                  
void
TruthTable32::changePhase4( unsigned phase )
{
   assert( _varNum == 4 );
   unsigned i;
   for( i = 0; phase != 0 && i < 4; phase >>= 1, i++ )
      if( phase & 1 )
         changeVarPhase( i );
   if( phase & 1 )
      _table = (~_table) & VMasks[_varNum];
}

void
TruthTable32::permute4( unsigned permutation, bool reverse )
{
   assert( _varNum == 4 );
   unsigned i, v, result = 0;
   unsigned minterm[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
   for( i = 0; i < 16; i++ )
      for( v = 0; v < 4; v++ )
         if( i & ( 1 << v ) )
            minterm[i] |= ( 1 << Permute5Var[permutation][v] );
   if( reverse )
   {
      for( i = 0; i < 16; i++ )
         if( _table & ( 1 << minterm[i] ) )
            result |= ( 1 << i );
   }
   else
   {
      for( i = 0; i < 16; i++ )
         if( _table & ( 1 << i ) )
            result |= ( 1 << minterm[i] );
   }
   _table = result;
}

void
TruthTable32::changePhasePermute4( unsigned phase, unsigned permutation, bool reverse )
{
   assert( _varNum == 4 );
   if( reverse )
   {
      permute4( permutation, reverse );
      changePhase4( phase );
   }
   else
   {
      changePhase4( phase );
      permute4( permutation, reverse );
   }
}

void
TruthTable32::generatePermute( unsigned varNum )
{
   vector< vector<unsigned char> > oldPermute, newPermute;
   
   newPermute.resize( 1 );
   newPermute[0].push_back( 0 );
   for( unsigned i = 2; i <= varNum; ++i )
   {
      oldPermute.clear();
      oldPermute.swap( newPermute );
      const unsigned psize = oldPermute.size();
      newPermute.resize( psize * i );
      for( unsigned j = 0; j < i; ++j )
         for( unsigned k = 0; k < psize; ++k )
         {
            vector<unsigned char> &vec = newPermute[j*psize + k];
            vec = oldPermute[k];
            vec.insert( vec.begin() + i - 1 - j, i - 1 );
         }
   }
   // print
   unsigned charNum = 0;
   for( unsigned i = 0; i < newPermute.size(); ++i )
   {
      if( charNum > 60 )
      {
         cout << endl;
         charNum = 0;
      }
      for( unsigned j = 0; j < newPermute[i].size(); ++j )
      {
         if( j == 0 ) cout << "{";
         else cout << ",";
         cout << static_cast<unsigned>( newPermute[i][j] );
         charNum += 2;
      }
      cout << "},";
      charNum += 2;
   }
   cout << endl;
   /*
   unsigned i, j, k;
   unsigned inputs[5];
   
   for( i = 0; i < 5; ++i )
   {
      inputs[0] = i;
      for( j = 0, k = 1; j < 5; ++j )
         if( j != i ) inputs[k++] = j;
      for( j = 0; j < 24; ++j )
      {
         cout << "{" << inputs[0];
         for( k = 0; k < 4; ++k )
            cout << "," << inputs[Permute4Var[j][k]+1];
         cout << "}, ";
      }
      cout << endl;
   }*/
}

void
TruthTable32::generateStretch( const unsigned varNum )
{
   assert( varNum < 5 );
   for( unsigned i = 0; i <= VMasks[varNum]; ++i )
   {
      for( unsigned j = 1; j <= ( 1U << varNum ); j<<=1 )
      {
         TruthTable32 table( varNum, i );
         table.stretch( varNum + 1, j );
         if( j == 1 ) cout << "{";
         else cout << ",";
         cout << "0x" << table;
      }
      cout << "}," << endl;
   }
}

unsigned
TruthTable32::getPermuteIndex( unsigned permutation, unsigned var )
{
   return Permute5Var[permutation][var];
   
   /*if( varNum <= 1 ) return 0;
   if( varNum == 2 )
   {
      assert( permutation < 2 );
      return Permute2Var[permutation][var];
   }
   if( varNum == 3 )
   {
      assert( permutation < 6 );
      return Permute3Var[permutation][var];
   }
   if( varNum == 4 )
   {
      assert( permutation < 24 );
      return Permute4Var[permutation][var];
   }
   assert( varNum == 5 );
   assert( permutation < 120 );
   return Permute5Var[permutation][var];*/
}

unsigned
TruthTable32::getStretch( unsigned table, unsigned insertIndex )
{
   assert( table <= VMasks[3] && insertIndex < 4 );
   return Stretch3Var[table][insertIndex];
}

ostream &
operator << ( ostream &os, const TruthTable32 &a )
{
   ios_base::fmtflags ff = os.flags( ios::hex );
   os << a._table;
   os.flags( ff ); 
   return os;
}
