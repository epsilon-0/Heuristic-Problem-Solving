#ifndef DINITZ_
#define DINITZ_

#include <vector>

class Dinitz {

 private:
  
  int INF;
  vector<int> Q, fin, pro, dist, next, to;
  vector<double> cap, flow;
  int src, snk, nNode, nEdge;
  
 public:
  
  Dinitz(int _src, int _snk, int _n){
    int maxn = 2*_n;
    INF = 0x7fffffff;
    Q.resize(maxn);
    fin.resize(maxn,-1);
    pro.resize(maxn);
    dist.resize(maxn);
    src = _src, snk = _snk, nNode = _n, nEdge = 0;
  }
  
  void add(int u, int v, int c) {
    to.push_back(v); cap.push_back(c); flow.push_back(0); next.push_back(fin[u]); fin[u] = nEdge++;
    //    to.push_back(u); cap.push_back(c); flow.push_back(0); next.push_back(fin[v]); fin[v] = nEdge++; // uncommment for undirected graph
  }
  
  bool bfs() {
    int st, en, i, u, v;
    for(int pos = 0; pos < dist.size(); pos++) dist[pos] = -1;
    dist[src] = st = en = 0;
    Q[en++] = src;
    while(st < en) {
      u = Q[st++];
      for(i=fin[u]; i>=0; i=next[i]) {
	v = to[i];
	if(flow[i] < cap[i] && dist[v]==-1) {
	  dist[v] = dist[u]+1;
	  Q[en++] = v;
	}
      }
    }
    return dist[snk]!=-1;
  }
  
  double dfs(int u, double fl) {
    if(u==snk) return fl;
    double df;
    for(int &e=pro[u], v; e>=0; e=next[e]) {
      v = to[e];
      if(flow[e] < cap[e] && dist[v]==dist[u]+1) {
	df = dfs(v, min(cap[e]-flow[e], fl));
	if(df>0) {
	  flow[e] += df;
	  flow[e^1] -= df;
	  return df;
	}
      }
    }
    return 0;
  }
  
  double dinitz() {
    double ret = 0;
    double df;
    while(bfs()) {
      for(int i=1; i<=nNode; i++) pro[i] = fin[i];
      while(true) {
	df = dfs(src, INF);
	if(df>0) ret += df;
	else break;
      }
    }
    return ret;
  }

  vector<bool> getMinCut(){
    vector<bool> mincut(nNode,false);
    bfs();
    for(int i = 0; i < nNode; i++){
      mincut[i] = (dist[i]!=-1);
    }
    return mincut;
  }
};

#endif
