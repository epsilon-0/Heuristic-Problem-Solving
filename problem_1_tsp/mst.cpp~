#include<iostream>
#include<algorithm>
#include<cmath>
#include<vector>
#include<cstdio>

using namespace std;

const int MAXC=1001;

// UNION FIND DATA STRUCTURE

int rnk[MAXC],parent[MAXC],treecnt[MAXC];

int init(){
  for(int i=0;i<MAXC;i++){
    rnk[i]=0;parent[i]=i,treecnt[i]=1;
  }
  return 0;
}

int find(int node){
  int ancestor=node;
  int child=node;
  int temp=node;
  while(parent[ancestor]!=ancestor){
    ancestor=parent[ancestor];
  }
  while(parent[child]!=ancestor){
    temp=parent[child];
    parent[node]=ancestor;
    child=temp;
  }
  return ancestor;
}

int funion(int x,int y){
  int fx=find(x);
  int fy=find(y);
  if(fx!=fy){
    if(rnk[fy]>rnk[fx]){
      swap(fx,fy);
    }
    if(rnk[fx]==rnk[fy]){
      rnk[fx]++;
    }
    parent[fy]=fx;
  }
  return 0;
}

// UNION FIND FINISH

int id[MAXC];

double nodes[MAXC][2];

double dist[MAXC][MAXC];

double mdistance(int i,int j){
  return sqrt(pow(nodes[i][0]-nodes[j][0],2)+pow(nodes[i][1]-nodes[j][1],2));
}

bool operator< (pair<int,int> e1,pair<int,int> e2){
  return (dist[e1.first][e1.second]<dist[e2.first][e2.second]);
}


vector<pair<int,int> > edges;

int main(){

  int d;double x,y;
  int n=0;
  while(scanf("%d %lf %lf",&d,&x,&y)!=EOF){
    id[n]=d;
    nodes[n][0]=x;nodes[n][1]=y;
    n++;
  }
  for(int i=0;i<n;i++){
    for(int j=0;j<n;j++){
      dist[i][j]=mdistance(i,j);
      dist[j][i]=dist[j][i];
      edges.push_back(make_pair(i,j));
    }
  }

  sort(edges.begin(),edges.end());
  init();

  vector<pair<int,int> > tree;
  tree.clear();
  int xx,yy;
  for(int i=0;i<edges.size();i++){
    xx=edges[i].first;yy=edges[i].second;
    if(find(xx)!=find(yy)){
      tree.push_back(edges[i]);
      funion(xx,yy);
    }
  }
}
