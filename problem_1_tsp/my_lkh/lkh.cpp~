#include <cstdio>
#include <iostream>
#include <vector>
#include <algorithm>
#include <cstring>
#include <string>
#include <cmath>
#include <queue>
#include <set>
#include <cassert>

using namespace std;

#define REP(i,a,b) for(int i = int(a); i < int (b); i++)
#define mset(cont, val) memset(cont, val, sizeof(cont))
#define mcpy(cont, orig) memcpy(cont, orig, sizeof(cont))
#define edge pair<int, int>
#define MAXV 1001

int num_vert = 0;  // stores number of vertices in our graph

int id[MAXV] = {0};  // maps the ids to nice formats

double coord[MAXV][2] = {0};  // store coordinates of the points

int curr_tour[MAXV] = {0}, opt_tour[MAXV] = {0}; // we store the tour in the format tour[i] lists the vertex after i

bool broken[MAXV][MAXV] = {false}, joined[MAXV][MAXV] = {false};

double dist[MAXV][MAXV] = {0}; // we store the distances between vertices in this matrix

int init(){
  REP(i, 0, num_vert){
    curr_tour[i] = (i+1) % num_vert;
  }
  REP(i, 0, num_vert){
    REP(j, 0, num_vert){
      dist[i][j] = sqrt( pow(coord[i][0] - coord[j][0], 2) + pow(coord[i][1] - coord[j][i], 2) );
      dist[j][i] = dist[i][j];
    }
  }
  return 1;
}


// at the end tour[start] remains unchanged
// need to handle that
int tour_reverse(int start,int endd, int tour[] ){   // reverse the direction of the tour in the segment starting from start ending at endd
  if(start==endd){
    return 0; // we will not reverse the whole permutation
  }
  int curr = tour[start], next = tour[tour[start]], temp;
  while(curr!=endd){
    temp = tour[next];
    tour[next] = curr;
    curr = next;
    next = temp;
  }
  return 1;
}

bool is_tour(int tour[]){
  int cnt = 1, start = tour[0];
  while(start != 0){
    start = tour[start];
    cnt++;
  }
  if(cnt == num_vert){
    return true;
  }
  return false;
}

// we need to check if the chosen edges satisfy 4 c,d,e
bool satisfies4cde(edge yi, edge xi, double gain ){
  bool ans = true;

  // we should check that they are not the same edge
  if((yi.first == xi.first && yi.second == xi.second) ||
     (yi.second == xi.first && yi.first == xi.second)){
      ans=false;
     }

  // c states that yi should not have been previously broken and 
  if(broken[yi.first][yi.second] || broken[yi.second][yi.first] ||
     joined[xi.first][xi.second] || joined[xi.second][xi.first]){ // xi should not have been previously joined
    ans=false;
  }

  // d states that the total gain after removing xi and joining yi should be positive
  if(gain + dist[xi.first][xi.second] - dist[yi.first][yi.second] <= 0){
    ans=false;
  }

  // e indicates that the choice of yi should allow some xi+1 to be broken such that condition a is satisfied
  int temp_tour[MAXV];
  mcpy(temp_tour, curr_tour);
  
  edge xi_p;  // this is xi+1
  xi_p.first = yi.second;
  REP(i,0,num_vert){
    if(temp_tour[i] == xi.first){
      xi_p.second = i;
      break;
    }
  }
  
  // change temp_tour and check that it still remains a tour

  // 

  return ans;
}

int optimize(int vert){   // we will try to find sequential move which are optimum locally
  double g_star = 0, gi_star = 0, gi = 0, g = 0;  // g_star has the max gain so far
  edge xi, yi, xi_p;  // xi is the current edge that we are going to break, yi is the edge that we join and xi_p is the next edge which we get by choosing yi
  xi.first = vert; xi.second = curr_tour[vert];
  int ti, ti1, curr_vert = vert, next_vert, poss_vert;
  mset(joined, false);
  mset(broken, false);

  while(true){   // we only break if some conditions are unsatisfied
    // xi is already chosen at the start of the loop

    // we have to choose yi such that it starts at the end point of xi
    yi.first=xi.second;
    REP(i, 0, num_vert){
      yi.second = i;

      // now for this yi we need to check if it satisfies 4 c, d, e
      if(!satisfies4cde(xi, yi, g)){
        yi.second = -1;
        continue;
      }
      break;
    }
    
    // we aren't able to find any yi satisfying the conditions
    if(yi.second==-1){
      break;
    }
    // when we are out of that loop we are guaranteed to find a yi which is compatible with the xi
    // hence we have chosen xi, yi
    broken[xi.first][xi.second] = true;   // we add them to the broken and joined sets respectively,
    broken[xi.second][xi.first] = true;

    joined[yi.first][yi.second] = true;
    joined[yi.second][yi.first] = true;

    // because yi is chosen xi+1 is fixed, we need to find it
    xi_p.first = yi.second;
    REP(i,0,num_vert){
      if(curr_tour[i] == xi.first){
        xi_p.second = i;
        break;
      }
    }

    // we calculate the gain when we add yi and remove xi
    gi = dist[xi.first][xi.second] - dist[yi.first][yi.second];
    g += gi;

    // we will calculate the gain we have if we terminate at this point
    gi_star = dist[xi.first][xi.second] - dist[xi.first][vert];   // and increase g_star if needed and store the OPTIMAL tour as of yet
    if(g_star < g + gi_star){
      g_star = g + gi_star;
      mcpy(opt_tour,curr_tour);
      opt_tour[vert] = xi.second;
      assert(is_tour(opt_tour));
    }

    // we join yi and reverse the corresponding part of the list

    tour_reverse(xi_p.second, curr_tour[xi.second], curr_tour);

    curr_tour[yi.first] = yi.second;

    xi = xi_p;

  }
}

double tour_length(int tour[]){
  double lgt = 0;
  REP(i, 0, num_vert){
    lgt += dist[i][tour[i]];
  }
}

int main(){
  num_vert=0;

  int ids; double x, y;

  while(scanf("%d %lf %lf", &ids, &x, &y)!=EOF){
    id[num_vert] = ids;
    coord[num_vert][0] = x;
    coord[num_vert][1] = y;
    num_vert++;
  }

  init();

  optimize(0);
}

















