#! @PERL@ -w
# @configure_input@
#
# expt.pl
# Run experiments.
# Different but similar to lkdoit.  Alas...
#


use FileHandle;

@variations = (".deg",".no_d");
@permutations = ();
@preprocess = ();
@instances = ();
$algprefix = "tsp.";
$bindir = "../src/";
$scriptdir = "../script/";
$inputdir = "../data";
$outputdir = "../expt/";
$lkargs = "-S dsort -v 50 --maxdepth 50 -c nn 20";

# Find out which experiment script to run.  Default is "expt"
$script_name = "expt";
#print "# = $#ARGV\n";
#print "\@ARGV = ", @ARGV,"\n";
#print "$ARGV[0] = ", $ARGV[0],"\n";
#exit 0;
if ( $#ARGV >= 0 ) { $script_name = $ARGV[0]; }

# Open an output log, based on the input script name.
open(EXPTLOG,">>$script_name.log");
autoflush EXPTLOG 1;

# Read in the script.
#$script_preprocess = 
#		 "sed -e 's/#.*//' $script_name"	# Remove comments
#		."| sed -e 's/[ ]*\$//'"			# Remove trailing spaces
#		."| grep -v '^\$' |";				# Remove empty lines
#print "script preproces\n\t$script_preprocess\n";
open(SCRIPT, "<$script_name")
	|| die "Can't find file $script_name";

#print "opened script\n";

SCRIPTLINE: while ($line=<SCRIPT>) {
	print EXPTLOG $line;
	$line =~ s/#.*//;	# Remove comments.
	$line =~ s/\s*$//;	# Remove trailing whitespace
	next SCRIPTLINE if $line =~ m/^$/;  # Empty lines are skipped.
	if ( $line=~ m/^\s*instance\s+(.*)/) {
		push(@instances,$1);
	} elsif ($line=~ m/\s*preprocess\s+(.*)/) {
		push(@preprocess,$1);
	} elsif ($line=~ m/\s*permutations\s+(.*)/) {
		@permutations=split(/\s*:\s*/,$1);
	} elsif ($line=~ m/\s*variations\s+(.*)/) {
		@variations=split(/\s*:\s*/,$1);
	} elsif ($line=~ m/\s*bindir\s+(.*)/) {
		$bindir=$1;
	} elsif ($line=~ m/\s*algprefix\s+(.*)/) {
		$algprefix=$1;
	} elsif ($line=~ m/\s*scriptdir\s+(.*)/) {
		$scriptdir=$1;
	} elsif ($line=~ m/\s*inputdir\s+(.*)/) {
		$inputdir=$1;
	} elsif ($line=~ m/\s*outputdir\s+(.*)/) {
		$outputdir=$1;
	} elsif ($line=~ m/\s*lkargs\s+(.*)/) {
		$lkargs=$1;
	} else {
		die "expt: line not understood: $line";
	}
}

# Remove trailing slashes
$bindir   =~s+\/*$++; 
$inputdir =~s+\/*$++; 
$outputdir=~s+\/*$++; 
$scriptdir=~s+\/*$++; 


#print "$bindir\n$inputdir\n$outputdir\n$scriptdir\n";
#print "$lkargs\n";
#exit 0;

foreach $perm (@permutations) {
	foreach $instance (@instances) {
		my($file,$n,$ioption,@ns)=
			split(/\s*:\s*/,$instance);
		foreach $pre (@preprocess) {
			# Form the preprocess command line, substuting $perm for $p 
			# in the string.
#print EXPTLOG "preprocess line is $pre\n";
			$pre =~ s/%p/$perm/g;
			my($pre_line,$pre_early_suffix,$pre_late_suffix)=split(/\s*:\s*/,$pre);

			# Form the arguments to lk.
			$rep = $n > 1000 ? "-r two-level" : "-r array";
			$args = "$lkargs $rep "; #lower bounds

			foreach $iters (@ns) {
#print "pre pre iters $iters\n";
				$iters =~ s/N/$n/g;
#print "pre iters $iters\n";
				$iters = int(0.5+eval($iters));
#print "post iters $iters\n";
				print "expt: $file $args -i $iters\n";
				foreach $var (@variations) {
					if ( -e "stop" ) { die "expt: stopped";}
	$outname="out.$algprefix$file.$pre_early_suffix.i$iters.$pre_late_suffix.$perm$var";
					$sys_str = 
						 "cat $inputdir/$file.tsp "
						." | $pre_line "
						." | @PERL@ $scriptdir/tspreorder.pl -s $perm"
						." | $bindir/lk$var $args -i $iters $ioption"
						." | gzip -c >$outputdir/$outname.gz\n";
					system("date >>$outputdir/$script_name.log");
					print EXPTLOG $sys_str;
					system($sys_str);
				}
			}
		}
	}
}
