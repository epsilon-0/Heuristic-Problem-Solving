head	1.1;
access;
symbols
	zero-four-zero:1.1;
locks
	neto:1.1;
comment	@# @;


1.1
date	98.05.08.22.46.36;	author neto;	state Exp;
branches;
next	;


desc
@Convert ATT and GEO problems to matrix form.
(GEO is broken for now).
@


1.1
log
@Initial revision
@
text
@#! /local/bin/perl -w
# Generated automatically from att2upper.pl.in by configure.
# vi:ts=4 sw=4:

# att2upper.pl
# Convert TSPLIB ATT instances to upper row-wise distance matrix format.

# This file is in the public domain, and comes with no warranty.
# David Neto, November 22, 1997.

# $Id$
# $Log$

use strict;
my($progname) 		= "att2upper.pl";
my($pkgname) 		= "lk";
my($pkgversion) 	= "0.3.1";
my($version_banner)	="$progname ($pkgname) $pkgversion";

my($float_expr)="(-?\\d+\\.?\[0-9\]*(?:\[eE\]\[+-\]\\d+)?|\\.\[0-9\]+(?:\[eE\]\[+-\]\\d+)?)";
my($line);  #Input line
my(@@comments)=();
my(@@buf)=(); # lines buffered for output, pending opening of output stream.
my($n); # Number of vertices
my($type)=0;
my(%type_map)=("EUC_2D",1,"CEIL_2D",2,"ATT",3,"GEO",4,"EXPLICIT",5);
my($type_string);

# 1-based array of coordinates
my(@@coordx)=();
my(@@coordy)=();

my($usage) = <<EOT;
$version_banner
Convert TSPLIB instances into DIMACS matching format
$progname [options]
  -h --help       : Print this help and exit successfully
     --version    : Print version info and exit successfully
EOT

# Parse the command line options
while ($#ARGV >= 0 && $ARGV[0] =~ m/^-/) {
    my($option) = $_ = shift(@@ARGV);
    if (m/^-h$/ || m/^--help$/) { print $usage; exit; }
    if (m/^--version$/) { print "$version_banner\n"; exit; }
    die "$progname: Unknown option $option\n$usage";
}




############################################
# Form the output.

HEADER: while($line=<>) {
	$_ = $line;
	if (m/^\s*NAME\s*:/) {
		push(@@buf,$line);
	} elsif (m/^\s*COMMENT\s*:/) {
		chop $line;
		push(@@buf,$line." | att2upper.pl\n");
	} elsif (m/^\s*TYPE\s*:\s*(.*)/) {
		$1 =~ m/^TSP/ || die "I know TSPLIB files of type TSP, not $1";
		push(@@buf,$line);
	} elsif (m/^(\s*EDGE_WEIGHT_TYPE\s*:\s*)([^\s]*)\s*/) {
		#print STDERR "edge weight type .$2.\n";
		$type_string = $2;
		$type = $type_map{$type_string};
		$type > 0
			|| die "TSP is of type $type_string, not ATT, CEIL_2D, EUC_2D, or GEO.  Not converted.\n";
	} elsif (m/^\s*DIMENSION\s*:\s*(.*)/) {
		push(@@buf,$line);
		#print STDERR "dimension .$1.\n";
		$n=0+$1;
	} elsif (m/^\s*NODE_COORD_SECTION\s*/) {
		$type==1 || $type==2 || $type==3 || $type==4
			|| die "Can't have NODE_COORD_SECTION in $type_string";
		last HEADER;
	} elsif (m/^\s*DISPLAY_DATA_TYPE\s*/) {
		;
	} else { die "Unrecognized line: $line"; }
}

push(@@buf, "EDGE_WEIGHT_TYPE: EXPLICIT\n");
push(@@buf, "EDGE_WEIGHT_FORMAT: UPPER_ROW\n");
push(@@buf, "EDGE_WEIGHT_SECTION\n");
print @@buf;

SWITCH: {
	&two_d, 	last SWITCH if ($type==1 || $type==2 || $type==3);
	&geo, 		last SWITCH if $type==4;
	&explicit, 	last SWITCH if $type==5;
	die "Unkown TSPLIB type";
}

print "EOF\n";
exit 0;

sub two_d {
	# Read the coordinates and store them into @@coordx and @@coordy.
	my($i)=0;
	my($j)=0;
	while (($i<$n) && ($line=<>) ) {
		if ( $line=~ m/^\s*(\d+)\s+$float_expr\s+$float_expr/o ) {
			my($k)=0+$1;
			$coordx[$k] = 0+$2;
			$coordy[$k] = 0+$3;
			$i++;
		}
	}
	$i==$n || die "Not enough vertices on input";

	# Now write out the matrix.
	for ( $i=1;$i<$n;$i++) {
		my($d);
		for ( $j=$i+1;$j<=$n;$j++) {
			my($dx)=$coordx[$i]-$coordx[$j];
			my($dy)=$coordy[$i]-$coordy[$j];
			my($sumsq)=$dx*$dx+$dy*$dy;
			ROUND: {
				$d=int(0.5+sqrt($sumsq)),		last ROUND if $type==1; #EUC_2D
				$d=ceil(sqrt $sumsq),			last ROUND if $type==2; #CEIL_2D
				$d=ceil(sqrt ($sumsq/10.0)),	last ROUND if $type==3; #ATT
			}
			printf "%.0f ", $d;
		}
		print "\n";
	}
}

sub geo {
	# Read the coordinates and store them into @@coordx and @@coordy.
	# Only this time, the coordinates will be latitude and longitude.
	my($i)=0;
	my($j)=0;
	my($q1,$q2,$q3);
	my($DEG2RAD)=3.141592/180.0;  	# according to TSPLIB doc.
	my($pi) = 3.141592; # according to TSPLIB doc.
	my($RRR)=6378.388;  	# according to TSPLIB doc.
	my($deg,$mn);
	my(@@long)=();	# 1-based longitude array
	my(@@lat)=();	# 1-based latitude array
	while (($i<$n) && ($line=<>) ) {
		if ( $line=~ m/^\s*(\d+)\s+$float_expr\s+$float_expr/o ) {
			my($k)=$1;
			my($rawlat)=$2;
			my($rawlong)=$3;
			$deg = nint($rawlat);
			$mn=$rawlat-$deg;
			$lat[$k]=$pi*($deg+5.0*$mn/3.0)/180.0;
			$deg = nint($rawlong);
			$mn=$rawlong-$deg;
			$long[$k]=$pi*($deg+5.0*$mn/3.0)/180.0;
#print "$2$3$4 to $lat[$k] $5$6$7 to $long[$k]\n";
			$i++;
		} else {
			print STDERR $line;
			die "Rejected: not in \d+ degrees degrees form.";
		}
	}
	$i==$n || die "Not enough vertices on input";

	# Now write out the matrix.
	for ( $i=1;$i<$n;$i++) {
		my($d);
		for ( $j=$i+1;$j<=$n;$j++) {
			my($q1)=cos($long[$i]-$long[$j]);
			my($q2)=cos($lat[$i]-$lat[$j]);
			my($q3)=cos($lat[$i]+$lat[$j]);
			printf "%.0f ", 
				int(0.5+$RRR*arccos(0.5*((1.0+$q1)*$q2-(1.0-$q1)*$q3)));
		}
		print "\n";
	}
}

sub explicit {
	die "Yo David, write this code, will ya!";
}


###############

sub ceil {
	my($x,$ix)=shift;
    $ix = int($x);
    if ( $ix == $x ) {return $ix};
    return $ix+1;
}

# arcos(x) = arctan((sqrt(1-x^2))/x)
sub arccos {
	my($t)=shift;
	return atan2(sqrt(1-$t*$t),$t);
}

# convert to nearest integer, rounding halfway cases to larger magnitude.
sub nint {
	my($x)=shift;
	if ( $x < 0 ) {
		return int($x-0.5);
	} else {
		return int($x+0.5);
	}
}
@
