head	1.124;
access
	david
	neto;
symbols
	zero-four-zero:1.124;
locks
	neto:1.124;


1.124
date	98.07.16.21.58.55;	author neto;	state Exp;
branches;
next	1.123;

1.123
date	98.05.08.22.47.34;	author neto;	state Exp;
branches;
next	1.122;

1.122
date	97.12.13.17.25.38;	author neto;	state Exp;
branches;
next	1.121;

1.121
date	97.12.05.22.15.52;	author neto;	state Exp;
branches;
next	1.120;

1.120
date	97.09.27.17.53.40;	author neto;	state Exp;
branches;
next	1.119;

1.119
date	97.08.15.20.18.25;	author neto;	state Exp;
branches;
next	1.118;

1.118
date	97.06.13.17.29.51;	author neto;	state Exp;
branches;
next	1.117;

1.117
date	97.06.13.17.13.10;	author neto;	state Exp;
branches;
next	1.116;

1.116
date	97.06.13.17.07.34;	author neto;	state Exp;
branches;
next	1.115;

1.115
date	97.06.13.16.17.19;	author neto;	state Exp;
branches;
next	1.114;

1.114
date	97.06.11.17.54.04;	author neto;	state Exp;
branches;
next	1.113;

1.113
date	97.05.16.20.38.52;	author neto;	state Exp;
branches;
next	1.112;

1.112
date	97.05.16.18.11.41;	author neto;	state Exp;
branches;
next	1.111;

1.111
date	97.01.21.21.55.55;	author david;	state Exp;
branches;
next	1.110;

1.110
date	96.08.16.13.08.27;	author neto;	state Exp;
branches;
next	1.109;

1.109
date	96.08.16.13.04.43;	author neto;	state Exp;
branches;
next	1.108;

1.108
date	96.08.15.14.33.59;	author neto;	state Exp;
branches;
next	1.107;

1.107
date	96.08.15.14.24.30;	author neto;	state Exp;
branches;
next	1.106;

1.106
date	96.08.15.12.31.08;	author neto;	state Exp;
branches;
next	1.105;

1.105
date	96.08.15.11.15.49;	author neto;	state Exp;
branches;
next	1.104;

1.104
date	96.07.29.17.09.21;	author neto;	state Exp;
branches;
next	1.103;

1.103
date	96.07.29.16.19.48;	author neto;	state Exp;
branches;
next	1.102;

1.102
date	96.07.26.18.03.09;	author neto;	state Exp;
branches;
next	1.101;

1.101
date	96.06.24.16.15.07;	author neto;	state Exp;
branches;
next	1.100;

1.100
date	96.05.29.11.13.09;	author neto;	state Exp;
branches;
next	1.3;

1.3
date	96.05.24.16.38.23;	author neto;	state Exp;
branches;
next	1.2;

1.2
date	96.03.15.15.59.31;	author neto;	state Exp;
branches;
next	1.1;

1.1
date	96.03.04.13.53.44;	author neto;	state Exp;
branches;
next	;


desc
@Error checking and handling module.
@


1.124
log
@Added the LGPL notice in each file.
@
text
@


\noindent Copyright \copyright 1994, 1995, 1996, 1997, 1998 David Neto
\smallskip

\noindent 
   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Library General Public
   License as published by the Free Software Foundation; either
   version 2 of the License, or (at your option) any later version.
\smallskip

\noindent 
   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.
\smallskip

\noindent   
   You should have received a copy of the GNU Library General Public
   License along with this library; if not, write to the
   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA  02111-1307, USA.
\smallskip

\noindent   
   You may contact David Neto via email at {\tt netod@@@@acm.org}, or with
   greater latency at
\smallskip
\noindent{\obeylines
     Department of Computer Science
     University of Toronto
     10 King's College Rd.
     Toronto, Ontario
     M5S 3G4
     Canada
}
\medskip


\noindent\hbox{}\hrule\hbox{}\penalty-1000
\vskip0.5cm\relax



@@i webdefs.w
@@i types.w

{\obeylines
$Log: error.w,v $
Revision 1.123  1998/05/08 22:47:34  neto
Make core dump on error when compiled with special flag

Revision 1.122  1997/12/13 17:25:38  neto
Re-engineered the thing.  It's now more CWEB-like, and has better and
more correct functionality. It also is disentangled from the memory
module.

Revision 1.121  1997/12/05  22:15:52  neto
Remove dependency of error.w on resource.w

Revision 1.120  1997/09/27 17:53:40  neto
Fixed RCS behaviour about prefix to Log.

Revision 1.119  1997/08/15  20:18:25  neto
Added Index major section.

Revision 1.118  1997/06/13  17:29:51  neto
I accidentally deleted the RCS id and the cleanup function.
I now put them back.

Revision 1.117  1997/06/13  17:13:10  neto
Fixed conflicting types for error real if.

Revision 1.116  1997/06/13  17:07:34  neto
ANSI C forbids use of compound expressions as lvalues, so I took the
parens out from around the errorif macro.

Revision 1.115  1997/06/13  16:17:19  neto
Make errorif macro like a real function call, instead of a statement.
It now won't break if it's the only statement in a branch of an
if or body of a loop.

Revision 1.114  1997/06/11  17:54:04  neto
Fixed a formatting error.

Revision 1.113  1997/05/16  20:38:52  neto
Added a comment about vfprintf and autoconf.

Revision 1.112  1997/05/16  18:11:41  neto
Break locks by david and neto.
Include <config.h> and "lkconfig.h"

Revision 1.111  1997/01/21  21:55:55  david
Added standard copyright notice by including copyrt.w

Revision 1.110  96/08/16  13:08:27  neto
Added vfprintf to the list of things needed.

Revision 1.109  96/08/16  13:04:43  neto
Added fixincludes.

Revision 1.108  96/08/15  14:33:59  neto
Fixed one more const-related warning.

Revision 1.107  96/08/15  14:24:30  neto
Fixed the broken cast so that gcc doesn't complain about losing the
const on assignment from \_\_FILE\_\_.

Revision 1.106  96/08/15  12:31:08  neto
Include interface to memory.h,  needed mem\_report

Revision 1.105  96/08/15  11:15:49  neto
Include interface to resource

Revision 1.104  96/07/29  17:09:21  neto
Fixed to compile.

Revision 1.103  96/07/29  16:19:48  neto
Added *\_rcs\_id.
Made sure RCS log is activated within this file.

}

@@* Reporting errors. 
The function |errorif| provides a handy shorthand for the usual test
and print code
sequence used after allocation routines.

Since this package uses, GNU Autoconf, we can be a little smarter about
using |HAVE_VFPRINTF|.  I don't know what the alternatives are --- I'm an
ANSI C guy!

@@c
#include <config.h>
#include "lkconfig.h"
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#define FIXINCLUDES_NEED_VFPRINTF
#include "fixincludes.h"
#undef FIXINCLUDES_NEED_VFPRINTF

#include "error.h"
const char *error_rcs_id="$Id: error.w,v 1.123 1998/05/08 22:47:34 neto Exp neto $";


@@<Global variables@@>@@;
@@<Module variables@@>@@;

@@<Subroutines@@>@@;

@@ The |errorif| macro is overly elaborate only because I want to know
the offending source file and source line.  Note that 0 can be cast into
(just about?) anything.  
The |errorif| macro behaves almost like a function call.  
Note that in all cases, all side effects in the condition and 
the error message arguments take place, even if the error condition
is false, and even if errors aren't being
checked at all.

Just be sure that
|error_at_line| and |error_in_file| aren't masked in this
scope by local definitions.  (This would be a great time for 
\CPLUSPLUS/'s scope resolution operator |::|.)

@@(error.h@@>=
@@<Exported variables@@>@@;
@@<Exported subroutines@@>@@;

#if defined(ERROR_NO_CHECK)
#define errorif  /* Side effects in the condition still occur. */
#else
#define @@[errorif@@] @@[(error_in_file=__FILE__),(error_at_line=__LINE__),error_real_if@@]
#endif

@@
@@<Global variables@@>=
char const *error_in_file;
int error_at_line;

@@
@@<Exported variables@@>=
extern const char *error_rcs_id;
extern char const *error_in_file; 
extern int error_at_line;


@@ The |error_real_if| function actually does the hard work.  It checks to see
if the condition is true, and if so, shuts down the program, with
a message both on the standard output stream and the standard error output
stream.

@@<Subroutines@@>=
int
error_real_if(const int condition, const char *fmt,...)
{
	va_list args;
	va_start(args,fmt);
	if ( condition ) {
		@@<Do abnormal ending external reporting and cleanup@@>@@;
		printf("%s:%d:",error_in_file,error_at_line);
		vfprintf(stdout,fmt,args);
		fputc('\n',stdout);
		fflush(stdout);
		fprintf(stderr,"%s:%d:",error_in_file,error_at_line);
		vfprintf(stderr,fmt,args);
		fputc('\n',stderr);
		fflush(stderr);
#if defined(ERROR_DUMP_CORE_ON_ERROR)
		*((int *)0) = 1;	/* Dump core */
#endif
		exit(1);
	}
	va_end(args); /* |__ksr__| and AIX want this */
	/* Used to be |va_end| only for SUNOS */
	return 0; /* We need a return value for the |errorif| macro. */
}

@@
@@<Exported subroutines@@>=
int error_real_if(const int condition, const char *fmt,...);



@@ Sometimes it is convenient to display diagnostics from other parts
of the program.  For example, we optionally display statistics
both before and after cleaning up.  This might eventually be useful,
with a little discipline, for detecting memory leaks.

This module defines hooks for calling external reporting and cleanup
functions and the rest of the program is charged with the responsibility
of using those hooks.

Additionally, each call to the hooked procedures is guarded by a test
to see if we're already in that procedure.  After all, the program might
trigger another error while cleaning up or reporting!
The guard prevents endless mutual recursion: termination with a deficient
error message is better than non-termination.


@@<Do abnormal ending external reporting and cleanup@@>=
if ( error_doing_precleanup_stats || error_doing_cleanup 
	|| error_doing_postcleanup_stats ) return 0;
if ( error_precleanup_stats != NULL ) {
	error_doing_precleanup_stats = 1;
	(*error_precleanup_stats)();
	error_doing_precleanup_stats = 0;
}
if ( error_cleanup != NULL ) {
	error_doing_cleanup = 1;
	(*error_cleanup)();
	error_doing_cleanup = 0;
}
if ( error_postcleanup_stats != NULL ) {
	error_doing_postcleanup_stats = 1;
	(*error_postcleanup_stats)();
	error_doing_postcleanup_stats = 0;
}

@@
@@<Module variables@@>=
static int error_doing_precleanup_stats=0;
static int error_doing_cleanup=0;
static int error_doing_postcleanup_stats=0;

@@ The hook functions expect no arguments and don't return a value.
@@<Global variables@@>=
void (*error_precleanup_stats)(void) = NULL;
void (*error_cleanup)(void) = NULL;
void (*error_postcleanup_stats)(void) = NULL;

@@
@@<Exported variables@@>=
extern void (*error_precleanup_stats)(void);
extern void (*error_cleanup)(void);
extern void (*error_postcleanup_stats)(void);

@@*Index.
@


1.123
log
@Make core dump on error when compiled with special flag
@
text
@d1 47
a47 1
@@i copyrt.w
d53 3
d147 1
a147 1
const char *error_rcs_id="$Id: error.w,v 1.122 1997/12/13 17:25:38 neto Exp neto $";
@


1.122
log
@Re-engineered the thing.  It's now more CWEB-like, and has better and
more correct functionality. It also is disentangled from the memory
module.
@
text
@d7 5
d98 1
a98 1
const char *error_rcs_id="$Id: error.w,v 1.121 1997/12/05 22:15:52 neto Exp neto $";
d163 1
a163 1
#if 0
@


1.121
log
@Remove dependency of error.w on resource.w
@
text
@d7 3
a91 1
#include "memory.h"
d93 5
a97 1
const char *error_rcs_id="$Id: error.w,v 1.120 1997/09/27 17:53:40 neto Exp neto $";
d99 10
d110 4
d115 3
a117 1
void (*cleanup)(void) = NULL;
d119 8
d129 6
a134 2
static int error_in_error=0;
void (*error_abnormal_stats)(void) = NULL;
d137 6
d149 1
a149 8
		char const *saved_file = error_in_file;
		int saved_line = error_at_line;
		if ( error_abnormal_stats != NULL ) (*error_abnormal_stats)();
		if ( cleanup != NULL ) (*cleanup)();
		mem_report();

		error_in_file = saved_file;
		error_at_line = saved_line;
d168 3
a170 7
@@ The |errorif| macro is overly elaborate only because I want to know
the offending source file and source line.  Note that 0 can be cast into
(just about?) anything.  
The |errorif| macro behaves like a function call.  Just be sure that
|error_at_line| and |error_in_file| aren't masked in this
scopy by local definitions.  (This would be a great time for 
\CPLUSPLUS/'s scope resolution operator |::|.)
a171 1
@@(error.h@@>=
a172 6
extern const char *error_rcs_id;
extern void (*cleanup)(void);
extern char const *error_in_file; 
extern int error_at_line;
int error_real_if(const int, const char *fmt, ...);
extern void (*error_abnormal_stats)(void);
d174 34
d209 17
a225 5
#if defined(ERROR_NO_CHECK)
#define errorif  /* Side effects in the condition still occur. */
#else
#define errorif (error_in_file=__FILE__),(error_at_line=__LINE__),error_real_if
#endif
@


1.120
log
@Fixed RCS behaviour about prefix to Log.
@
text
@d7 3
d18 1
a18 1
Fixed conflicting types for error_real_if.
a84 2
#include <sys/time.h>
#include <sys/resource.h>
a88 1
#include "resource.h"
d91 1
a91 1
const char *error_rcs_id="$Id: error.w,v 1.119 1997/08/15 20:18:25 neto Exp neto $";
d99 2
a100 1
static int in_error=0;
d111 1
a111 10
		if ( !in_error ) {	/* This |in_error| business is a kludge. */
			int i,j;
			in_error = 1;
			i = resource_mark("abnormal ending");
				/* Assumes |resource_setup| has succeeded! */
			for ( j=0;j<i; j++ ) {
				resource_report(stdout,j,i);
				resource_report(stderr,j,i);
			} 
		}
d141 1
a141 1
\CPP/'s scope resolution operator |::|.)
d150 1
@


1.119
log
@Added Index major section.
@
text
@d5 5
a9 1
{\obeylines$Log: error.w,v $
d91 1
a91 1
const char *error_rcs_id="$Id: error.w,v 1.118 1997/06/13 17:29:51 neto Exp neto $";
@


1.118
log
@I accidentally deleted the RCS id and the cleanup function.
I now put them back.
@
text
@d6 4
d87 1
a87 1
const char *error_rcs_id="$Id: error.w,v 1.117 1997/06/13 17:13:10 neto Exp neto $";
d161 2
@


1.117
log
@Fixed conflicting types for error_real_if.
@
text
@d6 3
d83 1
a83 1
const char *error_rcs_id="$Id: error.w,v 1.116 1997/06/13 17:07:34 neto Exp neto $";
d145 2
d150 1
@


1.116
log
@ANSI C forbids use of compound expressions as lvalues, so I took the
parens out from around the errorif macro.
@
text
@d6 4
d80 1
a80 1
const char *error_rcs_id="$Id: error.w,v 1.115 1997/06/13 16:17:19 neto Exp neto $";
d144 1
a144 1
void error_real_if(const int, const char *fmt, ...);
@


1.115
log
@Make errorif macro like a real function call, instead of a statement.
It now won't break if it's the only statement in a branch of an
if or body of a loop.
@
text
@d6 5
d76 1
a76 1
const char *error_rcs_id="$Id: error.w,v 1.114 1997/06/11 17:54:04 neto Exp neto $";
d131 4
a134 1
The |errorif| macro behaves like a function call.
d145 1
a145 1
#define errorif (error_in_file=__FILE__,error_at_line=__LINE__,error_real_if)
@


1.114
log
@Fixed a formatting error.
@
text
@d6 3
d71 1
a71 1
const char *error_rcs_id="$Id: error.w,v 1.113 1997/05/16 20:38:52 neto Exp neto $";
d82 1
a82 1
void
d120 1
d123 5
a127 1
@@
d129 5
d135 1
a135 1
#define errorif if (0)	/* Beware of side-effects. */
d137 1
a137 3
void error_real_if(const int, const char *fmt, ...);
#define errorif {extern char const *error_in_file; extern int error_at_line; \
	error_in_file=__FILE__;error_at_line=__LINE__;}error_real_if
a138 4

extern const char *error_rcs_id;

extern void (*cleanup)(void);
@


1.113
log
@Added a comment about vfprintf and autoconf.
@
text
@d6 3
d50 1
a50 1
using HAVE_VFPRINTF.  I don't know what the alternatives are --- I'm an
d68 1
a68 1
const char *error_rcs_id="$Id: error.w,v 1.112 1997/05/16 18:11:41 neto Exp neto $";
@


1.112
log
@Break locks by david and neto.
Include <config.h> and "lkconfig.h"
@
text
@d6 4
d46 3
d65 1
a65 1
const char *error_rcs_id="$Id: error.w,v 1.111 1997/01/21 21:55:55 david Exp david $";
d74 1
@


1.111
log
@Added standard copyright notice by including copyrt.w
@
text
@d5 4
a8 1
{\obeylines$Log:	error.w,v $
d44 2
d58 1
a58 1
const char *error_rcs_id="$Id: error.w,v 1.110 96/08/16 13:08:27 neto Exp $";
@


1.110
log
@Added vfprintf to the list of things needed.
@
text
@d1 1
d6 3
d53 1
a53 1
const char *error_rcs_id="$Id: error.w,v 1.109 96/08/16 13:04:43 neto Exp $";
@


1.109
log
@Added fixincludes.
@
text
@d5 3
d42 1
d44 1
d49 1
a49 1
const char *error_rcs_id="$Id: error.w,v 1.108 96/08/15 14:33:59 neto Exp $";
@


1.108
log
@Fixed one more const-related warning.
@
text
@d5 3
d39 1
d44 1
a44 1
const char *error_rcs_id="$Id: error.w,v 1.107 96/08/15 14:24:30 neto Exp $";
@


1.107
log
@Fixed the broken cast so that gcc doesn't complain about losing the
const on assignment from \_\_FILE\_\_.
@
text
@d5 4
d40 1
a40 1
const char *error_rcs_id="$Id: error.w,v 1.106 96/08/15 12:31:08 neto Exp $";
d56 1
a56 1
		char *saved_file = error_in_file;
@


1.106
log
@Include interface to memory.h,  needed mem\_report
@
text
@d5 3
d36 1
a36 1
const char *error_rcs_id="$Id: error.w,v 1.105 96/08/15 11:15:49 neto Exp $";
d42 1
a42 1
char *error_in_file;
d92 1
a92 1
#define errorif {extern char *error_in_file; extern int error_at_line; \
@


1.105
log
@Include interface to resource
@
text
@d5 3
d31 1
d33 1
a33 1
const char *error_rcs_id="$Id: error.w,v 1.104 96/07/29 17:09:21 neto Exp $";
@


1.104
log
@Fixed to compile.
@
text
@d5 3
d27 1
d29 1
a29 1
const char *error_rcs_id="$Id: error.w,v 1.103 96/07/29 16:19:48 neto Exp $";
@


1.103
log
@Added *\_rcs\_id.
Made sure RCS log is activated within this file.
@
text
@d4 5
a8 1
{\obeylines$Log$
a17 1
const char error_rcs_id[]="$Id$";
d25 1
@


1.102
log
@Added ERROR\_NO\_CHECK
@
text
@d1 2
d4 2
d14 1
d23 2
d80 2
@


1.101
log
@Fixed comment for TeX
@
text
@d20 2
a21 2
static char *error_in_file;
static int error_at_line;
a63 7
void 
error_line(char *file, int line)
{
	error_in_file = file;
	error_at_line = line;
}

d66 3
d70 4
a73 2
void error_line(char *file, int line);
#define errorif error_line(__FILE__,__LINE__);error_real_if
@


1.100
log
@This version works.  
Needs improvement:
	command-line switches
	faster tabu check
	allow Papadimitriou tabu rule
	faster preprocessing
	different candidate lists
@
text
@d60 1
a60 1
	va_end(args); /* __ksr__ and AIX want this */
@


1.3
log
@Fixed up handling of |va_end|.
@
text
@@


1.2
log
@Initial implementation of LK.  This is buggy.
@
text
@d60 2
a61 5
#if __ksr__
	va_end(args);
#else
	va_end;
#endif
@


1.1
log
@Initial revision
@
text
@d55 3
@
