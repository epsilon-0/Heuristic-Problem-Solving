head	1.192;
access
	david
	neto;
symbols
	zero-four-zero:1.192;
locks
	neto:1.192;


1.192
date	98.07.16.21.58.55;	author neto;	state Exp;
branches;
next	1.191;

1.191
date	98.05.23.16.49.20;	author neto;	state Exp;
branches;
next	1.190;

1.190
date	98.05.09.22.51.39;	author neto;	state Exp;
branches;
next	1.189;

1.189
date	98.02.27.21.40.36;	author neto;	state Exp;
branches;
next	1.188;

1.188
date	98.02.27.19.43.14;	author neto;	state Exp;
branches;
next	1.187;

1.187
date	98.02.26.21.37.37;	author neto;	state Exp;
branches;
next	1.186;

1.186
date	98.02.21.04.04.36;	author neto;	state Exp;
branches;
next	1.185;

1.185
date	98.01.24.20.47.43;	author neto;	state Exp;
branches;
next	1.184;

1.184
date	97.11.07.22.35.57;	author neto;	state Exp;
branches;
next	1.183;

1.183
date	97.11.06.22.47.54;	author neto;	state Exp;
branches;
next	1.182;

1.182
date	97.10.18.18.08.13;	author neto;	state Exp;
branches;
next	1.181;

1.181
date	97.10.17.21.50.10;	author neto;	state Exp;
branches;
next	1.180;

1.180
date	97.09.27.18.06.21;	author neto;	state Exp;
branches;
next	1.179;

1.179
date	97.09.12.21.52.46;	author neto;	state Exp;
branches;
next	1.178;

1.178
date	97.08.15.20.18.25;	author neto;	state Exp;
branches;
next	1.177;

1.177
date	97.07.02.20.48.23;	author neto;	state Exp;
branches;
next	1.176;

1.176
date	97.07.02.17.51.20;	author neto;	state Exp;
branches;
next	1.175;

1.175
date	97.06.20.21.48.17;	author neto;	state Exp;
branches;
next	1.174;

1.174
date	97.06.20.20.55.28;	author neto;	state Exp;
branches;
next	1.173;

1.173
date	97.06.20.20.44.35;	author neto;	state Exp;
branches;
next	1.172;

1.172
date	97.06.20.19.34.02;	author neto;	state Exp;
branches;
next	1.171;

1.171
date	97.06.20.18.59.04;	author neto;	state Exp;
branches;
next	1.170;

1.170
date	97.06.20.18.32.26;	author neto;	state Exp;
branches;
next	1.169;

1.169
date	97.06.18.16.43.47;	author neto;	state Exp;
branches;
next	1.168;

1.168
date	97.06.17.20.28.57;	author neto;	state Exp;
branches;
next	1.167;

1.167
date	97.06.17.14.49.32;	author neto;	state Exp;
branches;
next	1.166;

1.166
date	97.06.17.14.47.12;	author neto;	state Exp;
branches;
next	1.165;

1.165
date	97.06.17.14.45.14;	author neto;	state Exp;
branches;
next	1.164;

1.164
date	97.06.16.21.22.16;	author neto;	state Exp;
branches;
next	1.163;

1.163
date	97.06.16.21.14.23;	author neto;	state Exp;
branches;
next	1.162;

1.162
date	97.06.16.21.01.11;	author neto;	state Exp;
branches;
next	1.161;

1.161
date	97.06.16.20.38.58;	author neto;	state Exp;
branches;
next	1.160;

1.160
date	97.06.16.20.26.58;	author neto;	state Exp;
branches;
next	1.159;

1.159
date	97.06.16.20.19.20;	author neto;	state Exp;
branches;
next	1.158;

1.158
date	97.06.16.20.05.14;	author neto;	state Exp;
branches;
next	1.157;

1.157
date	97.06.16.20.04.05;	author neto;	state Exp;
branches;
next	1.156;

1.156
date	97.06.16.19.15.32;	author neto;	state Exp;
branches;
next	1.155;

1.155
date	97.06.16.18.34.20;	author neto;	state Exp;
branches;
next	1.154;

1.154
date	97.06.16.17.36.52;	author neto;	state Exp;
branches;
next	1.153;

1.153
date	97.06.16.16.57.14;	author neto;	state Exp;
branches;
next	1.152;

1.152
date	97.06.16.16.45.51;	author neto;	state Exp;
branches;
next	1.151;

1.151
date	97.06.13.20.59.16;	author neto;	state Exp;
branches;
next	1.150;

1.150
date	97.05.16.18.11.41;	author neto;	state Exp;
branches;
next	1.149;

1.149
date	97.05.16.18.09.40;	author neto;	state Exp;
branches;
next	1.148;

1.148
date	97.04.23.21.28.07;	author neto;	state Exp;
branches;
next	1.147;

1.147
date	97.04.23.20.44.56;	author neto;	state Exp;
branches;
next	1.146;

1.146
date	97.02.07.16.52.23;	author neto;	state Exp;
branches;
next	1.145;

1.145
date	97.01.21.22.46.47;	author david;	state Exp;
branches;
next	1.144;

1.144
date	97.01.21.21.55.55;	author david;	state Exp;
branches;
next	1.143;

1.143
date	97.01.21.19.34.36;	author david;	state Exp;
branches;
next	1.142;

1.142
date	97.01.21.19.15.27;	author david;	state Exp;
branches;
next	1.141;

1.141
date	97.01.21.19.01.05;	author david;	state Exp;
branches;
next	1.140;

1.140
date	97.01.21.00.22.47;	author david;	state Exp;
branches;
next	1.139;

1.139
date	97.01.21.00.21.53;	author david;	state Exp;
branches;
next	1.138;

1.138
date	97.01.21.00.09.46;	author david;	state Exp;
branches;
next	1.137;

1.137
date	97.01.21.00.06.57;	author david;	state Exp;
branches;
next	1.136;

1.136
date	97.01.20.23.49.53;	author david;	state Exp;
branches;
next	1.135;

1.135
date	97.01.20.23.47.01;	author david;	state Exp;
branches;
next	1.134;

1.134
date	97.01.20.19.32.54;	author david;	state Exp;
branches;
next	1.133;

1.133
date	97.01.16.13.35.17;	author neto;	state Exp;
branches;
next	1.132;

1.132
date	96.12.23.13.07.03;	author neto;	state Exp;
branches;
next	1.131;

1.131
date	96.12.20.17.05.13;	author neto;	state Exp;
branches;
next	1.130;

1.130
date	96.12.20.17.02.54;	author neto;	state Exp;
branches;
next	1.129;

1.129
date	96.12.20.16.57.56;	author neto;	state Exp;
branches;
next	1.128;

1.128
date	96.12.20.16.41.53;	author neto;	state Exp;
branches;
next	1.127;

1.127
date	96.12.20.16.32.43;	author neto;	state Exp;
branches;
next	1.126;

1.126
date	96.12.20.13.40.39;	author neto;	state Exp;
branches;
next	1.125;

1.125
date	96.12.19.12.12.07;	author neto;	state Exp;
branches;
next	1.124;

1.124
date	96.12.17.14.50.05;	author neto;	state Exp;
branches;
next	1.123;

1.123
date	96.12.16.17.02.55;	author neto;	state Exp;
branches;
next	1.122;

1.122
date	96.12.16.16.38.37;	author neto;	state Exp;
branches;
next	1.121;

1.121
date	96.08.19.18.22.01;	author neto;	state Exp;
branches;
next	1.120;

1.120
date	96.08.16.16.29.59;	author neto;	state Exp;
branches;
next	1.119;

1.119
date	96.08.16.13.04.45;	author neto;	state Exp;
branches;
next	1.118;

1.118
date	96.08.16.12.40.42;	author neto;	state Exp;
branches;
next	1.117;

1.117
date	96.08.15.14.35.51;	author neto;	state Exp;
branches;
next	1.116;

1.116
date	96.08.15.14.18.47;	author neto;	state Exp;
branches;
next	1.115;

1.115
date	96.08.15.13.20.57;	author neto;	state Exp;
branches;
next	1.114;

1.114
date	96.08.14.13.35.52;	author neto;	state Exp;
branches;
next	1.113;

1.113
date	96.08.07.15.33.50;	author neto;	state Exp;
branches;
next	1.112;

1.112
date	96.08.07.15.18.44;	author neto;	state Exp;
branches;
next	1.111;

1.111
date	96.07.29.17.09.07;	author neto;	state Exp;
branches;
next	1.110;

1.110
date	96.07.29.16.19.50;	author neto;	state Exp;
branches;
next	1.109;

1.109
date	96.07.25.13.30.36;	author neto;	state Exp;
branches;
next	1.108;

1.108
date	96.07.05.18.18.46;	author david;	state Exp;
branches;
next	1.107;

1.107
date	96.06.28.12.18.42;	author neto;	state Exp;
branches;
next	1.106;

1.106
date	96.06.24.16.18.01;	author neto;	state Exp;
branches;
next	1.105;

1.105
date	96.06.20.16.11.58;	author neto;	state Exp;
branches;
next	1.104;

1.104
date	96.06.19.14.12.31;	author neto;	state Exp;
branches;
next	1.103;

1.103
date	96.06.04.12.41.58;	author neto;	state Exp;
branches;
next	1.102;

1.102
date	96.06.03.15.36.34;	author neto;	state Exp;
branches;
next	1.101;

1.101
date	96.05.31.17.07.05;	author neto;	state Exp;
branches;
next	1.100;

1.100
date	96.05.29.11.13.12;	author neto;	state Exp;
branches;
next	1.47;

1.47
date	96.05.28.11.52.53;	author neto;	state Exp;
branches;
next	1.46;

1.46
date	96.05.24.17.44.11;	author neto;	state Exp;
branches;
next	1.45;

1.45
date	96.05.23.14.49.36;	author neto;	state Exp;
branches;
next	1.44;

1.44
date	96.05.23.12.17.25;	author neto;	state Exp;
branches;
next	1.43;

1.43
date	96.05.23.11.46.44;	author neto;	state Exp;
branches;
next	1.42;

1.42
date	96.05.22.17.22.09;	author neto;	state Exp;
branches;
next	1.41;

1.41
date	96.05.22.16.40.22;	author neto;	state Exp;
branches;
next	1.40;

1.40
date	96.05.22.16.34.08;	author neto;	state Exp;
branches;
next	1.39;

1.39
date	96.05.22.15.49.08;	author neto;	state Exp;
branches;
next	1.38;

1.38
date	96.05.22.15.46.34;	author neto;	state Exp;
branches;
next	1.37;

1.37
date	96.05.22.15.39.12;	author neto;	state Exp;
branches;
next	1.36;

1.36
date	96.05.22.14.36.46;	author neto;	state Exp;
branches;
next	1.35;

1.35
date	96.05.22.14.16.14;	author neto;	state Exp;
branches;
next	1.34;

1.34
date	96.05.22.13.38.10;	author neto;	state Exp;
branches;
next	1.33;

1.33
date	96.05.21.13.55.57;	author neto;	state Exp;
branches;
next	1.32;

1.32
date	96.05.21.13.30.11;	author neto;	state Exp;
branches;
next	1.31;

1.31
date	96.05.21.12.49.15;	author neto;	state Exp;
branches;
next	1.30;

1.30
date	96.05.21.12.24.30;	author neto;	state Exp;
branches;
next	1.29;

1.29
date	96.05.16.15.42.54;	author neto;	state Exp;
branches;
next	1.28;

1.28
date	96.05.16.15.31.15;	author neto;	state Exp;
branches;
next	1.27;

1.27
date	96.05.16.15.25.20;	author neto;	state Exp;
branches;
next	1.26;

1.26
date	96.05.16.15.10.02;	author neto;	state Exp;
branches;
next	1.25;

1.25
date	96.05.16.15.01.20;	author neto;	state Exp;
branches;
next	1.24;

1.24
date	96.05.16.13.40.09;	author neto;	state Exp;
branches;
next	1.23;

1.23
date	96.05.16.12.58.26;	author neto;	state Exp;
branches;
next	1.22;

1.22
date	96.05.16.12.47.18;	author neto;	state Exp;
branches;
next	1.21;

1.21
date	96.05.16.12.36.15;	author neto;	state Exp;
branches;
next	1.20;

1.20
date	96.05.16.12.03.39;	author neto;	state Exp;
branches;
next	1.19;

1.19
date	96.05.16.11.55.45;	author neto;	state Exp;
branches;
next	1.18;

1.18
date	96.05.15.14.55.21;	author neto;	state Exp;
branches;
next	1.17;

1.17
date	96.05.15.14.28.10;	author neto;	state Exp;
branches;
next	1.16;

1.16
date	96.05.15.14.00.11;	author neto;	state Exp;
branches;
next	1.15;

1.15
date	96.05.15.13.54.06;	author neto;	state Exp;
branches;
next	1.14;

1.14
date	96.05.15.13.17.34;	author neto;	state Exp;
branches;
next	1.13;

1.13
date	96.05.14.17.49.26;	author neto;	state Exp;
branches;
next	1.12;

1.12
date	96.05.14.17.20.56;	author neto;	state Exp;
branches;
next	1.11;

1.11
date	96.05.14.17.20.11;	author neto;	state Exp;
branches;
next	1.10;

1.10
date	96.05.14.17.18.58;	author neto;	state Exp;
branches;
next	1.9;

1.9
date	96.05.14.17.18.07;	author neto;	state Exp;
branches;
next	1.8;

1.8
date	96.05.14.17.10.07;	author neto;	state Exp;
branches;
next	1.7;

1.7
date	96.05.14.16.40.20;	author neto;	state Exp;
branches;
next	1.6;

1.6
date	96.05.14.16.24.51;	author neto;	state Exp;
branches;
next	1.5;

1.5
date	96.05.13.16.51.10;	author neto;	state Exp;
branches;
next	1.4;

1.4
date	96.04.29.16.26.17;	author neto;	state Exp;
branches;
next	1.3;

1.3
date	96.03.15.15.59.43;	author neto;	state Exp;
branches;
next	1.2;

1.2
date	96.03.12.15.58.35;	author neto;	state Exp;
branches;
next	1.1;

1.1
date	96.03.04.13.53.58;	author neto;	state Exp;
branches;
next	;


desc
@My implementation of the Johnson, Bentley, McGeoch, and Rothberg version
of the Lin-Kernighan algorithm.
@


1.192
log
@Added the LGPL notice in each file.
@
text
@


\noindent Copyright \copyright 1994, 1995, 1996, 1997, 1998 David Neto
\smallskip

\noindent 
   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Library General Public
   License as published by the Free Software Foundation; either
   version 2 of the License, or (at your option) any later version.
\smallskip

\noindent 
   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.
\smallskip

\noindent   
   You should have received a copy of the GNU Library General Public
   License along with this library; if not, write to the
   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA  02111-1307, USA.
\smallskip

\noindent   
   You may contact David Neto via email at {\tt netod@@@@acm.org}, or with
   greater latency at
\smallskip
\noindent{\obeylines
     Department of Computer Science
     University of Toronto
     10 King's College Rd.
     Toronto, Ontario
     M5S 3G4
     Canada
}
\medskip


\noindent\hbox{}\hrule\hbox{}\penalty-1000
\vskip0.5cm\relax



@@i webdefs.w
@@i types.w

{\obeylines
$Log: jbmr.w,v $
Revision 1.191  1998/05/23 16:49:20  neto
Change bound value to lower bound value, etc.

Revision 1.190  1998/05/09 22:51:39  neto
Give two decimal points in milestones.

Revision 1.189  1998/02/27 21:40:36  neto
Lowered verbose level of end of LK step.
Fixed CWEB syntax of printing double bridge edge section.

Revision 1.188  1998/02/27 19:43:14  neto
Made printing for iterated Lin-Kernighan respect verbose rules.

Revision 1.187  1998/02/26 21:37:37  neto
Fixed an old bug!  Wasn't checking tabu condition in generic search for
the new edge to be removed being the new edge being proposed to be added.
Fixed a bug in reverting code: must use tour flip arb instead of just
tour flip.
Fixed a conceptual bug: the change log must also encode the scheme id
used in that improvement, and the reverting must undo those scheme changes.
Removed some debugging output.
Implement the double-bridge mutation in three flips instead of four.

This seems to work.  Now I'll remove some of the debugging output.

Revision 1.186  1998/02/21 04:04:36  neto
Added most of the support for Iterated Lin-Kernighan.

Revision 1.185  1998/01/24  20:47:43  neto
Fixed comment on CAREFUL OP

Revision 1.184  1997/11/07  22:35:57  neto
Added verbose message to say when we hit the max depth.
Adjusted verbose values so less is printed at 50.

Revision 1.183  1997/11/06  22:47:54  neto
I wasn't marking cities dirty for 4-changes or lambda-changes!
Ouch.

Revision 1.182  1997/10/18 18:08:13  neto
Convert to new neighbour list protocol.

Revision 1.181  1997/10/17  21:50:10  neto
Show Start and end milestones, and times for preprocessing as well.

Revision 1.180  1997/09/27 18:06:21  neto
Fixed RCS log behaviour.

Revision 1.179  1997/09/12  21:52:46  neto
Don't cause a seg fault in my verbose output: I was calling decluster d
even when I hadn't built the data structures!

Revision 1.178  1997/08/15  20:18:25  neto
Added Index major section.

Revision 1.177  1997/07/02  20:48:23  neto
Add online printing of length of broken t1 and t2 edge, and some online
depth printing.

Revision 1.176  1997/07/02  17:51:20  neto
Satisfy GCC's dataflow analysis w.r.t. this time.

Revision 1.175  1997/06/20  21:48:17  neto
Better comment about CAREFUL OP
rename num decluster reject to num reject by decluster, for uniformity.
Implement declustering in test surrounding major part of
  Update best gain and compose a list of eligible moves.

Revision 1.174  1997/06/20  20:55:28  neto
Formatting improvements.

Revision 1.173  1997/06/20  20:44:35  neto
Cleared up some clutter by using a macro for careful comparisons
with best gain.

Revision 1.172  1997/06/20  19:34:02  neto
Fixed typo in section name
Fixed a BIG MISTAKE:  compute cluster distance between t1 and t2ip2
*no* between t2ip1 and t2ip2.  Duh!

Revision 1.171  1997/06/20  18:59:04  neto
Added some stats gathering (num reject by cum 1, num reject before build e)
Check for cum gain > best gain *before* entering Update
best gain and compose an eligible list of moves.
This might save a *lot* of time because we may avoid searching
an entire nn list.

Revision 1.170  1997/06/20  18:32:26  neto
A better comment about building e list.
Commented out the code bloating PREV NEXT loop.
Made cluster rejection announcement at much lower verbose level, though
context is lost.
Count number of rejections due to declustering.

Revision 1.169  1997/06/18  16:43:47  neto
Milestones every 10th of a percent from 10 percent down through zero.

Revision 1.168  1997/06/17  20:28:57  neto
Added support for milestones.

Revision 1.167  1997/06/17  14:49:32  neto
Fixed a TeX error.

Revision 1.166  1997/06/17  14:47:12  neto
Fixed an unterminated hash if

Revision 1.165  1997/06/17  14:45:14  neto
Better formatting in eligibility test.
Added cluster compensation to the greedy test (Go deeper)

Revision 1.164  1997/06/16  21:22:16  neto
More debug verbose info.

Revision 1.163  1997/06/16  21:14:23  neto
Decluster test should use the best gain with slop.

Revision 1.162  1997/06/16  21:01:11  neto
At verbose 501, print every cluster distance.

Revision 1.161  1997/06/16  20:38:58  neto
JBMR ALLOW VERBOSE is always defined.  Now decide on zero/non-zero status
instead.

Revision 1.160  1997/06/16  20:26:58  neto
Added include decluster.h

Revision 1.159  1997/06/16  20:19:20  neto
Fixed a syntax error.

Revision 1.158  1997/06/16  20:05:14  neto
Need to include declevel.h to see whether to use declustering.

Revision 1.157  1997/06/16  20:04:05  neto
First cut at integrating decluster test.  Doesn't actually reject
just yet.  It just collects data.

Revision 1.156  1997/06/16  19:15:32  neto
Make unrolling the prev next loop conditional at compile time.

Revision 1.155  1997/06/16  18:34:20  neto
Make the code compact by putting both alternatives for t2ip2 into
the body of a loop.

Revision 1.154  1997/06/16  17:36:52  neto
Fixed a TeX bug.

Revision 1.153  1997/06/16  16:57:14  neto
Don't need debugging output for SPLIT GAIN VAR anymore.

Revision 1.152  1997/06/16  16:45:51  neto
Reversed the sense of REQUEST SPLIT GAIN VAR to REQUIRE SPLIT GAIN VAR
That way the default (safe) setting happens with fewer variables set.

Revision 1.151  1997/06/13  20:59:16  neto
Made it quieter

Revision 1.150  1997/05/16  18:11:41  neto
Break locks by david and neto.
Include <config.h> and "lkconfig.h"

Revision 1.149  1997/05/16  18:09:40  neto
Include <config.h> and lkconfig.h

Revision 1.148  1997/04/23  21:28:07  neto
Added elapsed time since last phase change to verbose reporting.

Revision 1.147  1997/04/23  20:44:56  neto
In verbose mode, report elapsed time since start of LK phase when
an improvement has been found.

Revision 1.146  1997/02/07  16:52:23  neto
Made every use of emphpar end with a paragraph break.

Revision 1.145  1997/01/21  22:46:47  david
Clarified conditional compilation and fixed a bug.

Revision 1.144  1997/01/21  21:55:55  david
Added standard copyright notice by including copyrt.w

Revision 1.143  1997/01/21  19:34:36  david
Clarified use of JBMR REQUEST SPLIT GAIN VAR

Revision 1.142  1997/01/21  19:15:27  david
Fixed setting of SPLIT GAIN VAR

Revision 1.140  1997/01/21  00:22:47  david
Removed offending pritnf

Revision 1.139  1997/01/21  00:21:53  david
Report both probe and move depths.

Revision 1.137  1997/01/21  00:06:57  david
Added tracking of probe depths.

Revision 1.136  1997/01/20  23:49:53  david
Changed max\_probe\_depth to max\_generic\_flips

Revision 1.135  1997/01/20  23:47:01  david
Fixed the limiting of probe depth.

Revision 1.134  1997/01/20  19:32:54  david
Optionally limit the probe depth.

Revision 1.133  97/01/16  13:35:17  neto
Get rid of a warning about old\_t when compiling with TABU LINEAR.

Revision 1.132  96/12/23  13:07:03  neto
New variable best gain with slop.  Saves many additions.

Revision 1.131  96/12/20  17:05:13  neto
Fixed typesetting woes by simplifiyng preprocessor stuff. (moved a brace.
).

Revision 1.130  96/12/20  17:02:54  neto
Fixed TeX typos and a spelling mistake.

Revision 1.129  96/12/20  16:57:56  neto
Fixed a tex bug.

Revision 1.128  96/12/20  16:41:53  neto
Fixed typo in section name (init bookkeeping vars)

Revision 1.127  96/12/20  16:32:43  neto
First attempt at incorporating instance\_epsilon

Revision 1.126  96/12/20  13:40:39  neto
Put the unified gain variables back in.  Make it optional.

Revision 1.125  96/12/19  12:12:07  neto
Fixed a CWEB typo in the rcs log.

Revision 1.124  96/12/17  14:50:05  neto
Now it compiles when debugging output is turned on.
Also, fixed a CWEB style infelicity.

Revision 1.123  96/12/16  17:02:55  neto
Fixed a typo.
Forgot the comparison function for eligible moves; it now handles
the split representation.

Revision 1.122  96/12/16  16:38:37  neto
First attempt at separating cum\_gain into positive and negative parts.

Revision 1.121  96/08/19  18:22:01  neto
Fixed uninitialized variables.  
generic flips made being uninitialized was a *bug*!

Revision 1.120  96/08/16  16:29:59  neto
Made it pass all warning flags when "allow verbose" is on.
Added "watch this city"

Revision 1.119  96/08/16  13:04:45  neto
Added fixincludes.

Revision 1.118  96/08/16  12:40:42  neto
Converted putchar to printf.   Otherwise, I'd never get a prototype
for SunOS's \_flusbuf.

Revision 1.117  96/08/15  14:35:51  neto
Fixed a const-related warning.

Revision 1.116  96/08/15  14:18:47  neto
Make it pass more gcc warning flags.

Revision 1.115  96/08/15  13:20:57  neto
Make it pass -Wall

Revision 1.114  96/08/14  13:35:52  neto
Use sort instead of qsort.

Revision 1.113  96/08/07  15:33:50  neto
Added reasons why pointer-difference tie-breaking would break code
in several places.

Revision 1.112  96/08/07  15:18:44  neto
Make qsort optionally preserve the order of equals.

Revision 1.111  96/07/29  17:09:07  neto
Fixed to compile.

Revision 1.110  96/07/29  16:19:50  neto
Added *\_rcs\_id.
Made sure RCS log is activated within this file.

Revision 1.109  96/07/25  13:30:36  neto
Changed ALLOW\_VERBOSE to JBMR\_ALLOW\_VERBOSE

Revision 1.108  1996/07/05  18:18:46  david
Fixed log. Duh.

Revision 1.107  96/06/28  12:18:42  neto
Moved some TeX definitions to webdefs.w

Revision 1.106  96/06/24  16:18:01  neto
Fixed comment that CWEB was interpreting.

Revision 1.105  96/06/20  16:11:58  neto
Use a more math-like typeset name for t2ip1 and t2ip2

Revision 1.104  96/06/19  14:12:31  neto
Finished adding splay TABU stuff.  It's all-or-nothing, though.
It could use some experimental work to determine the right cut-off.
Also, try the LEDA dictoinaries.

Revision 1.103  96/06/04  12:41:58  neto
More TABU stuff.

Revision 1.102  96/06/03  15:36:34  neto
More tabu stuff.

Revision 1.101  96/05/31  17:07:05  neto
Added some measurements regarding tabu check in the generic phase of
the search.
Began to parameterize the code regarding tabu check.

Revision 1.100  96/05/29  11:13:12  neto
This version works.  
Needs improvement:
	command-line switches
	faster tabu check
	allow Papadimitriou tabu rule
	faster preprocessing
	different candidate lists

Revision 1.47  96/05/28  11:52:53  neto
Added a fflush

Revision 1.46  96/05/24  17:44:11  neto
Added probe statistics.

Revision 1.45  96/05/23  14:49:36  neto
Added fflushes everywhere, and a hook to examine a particular city
in detail.
This version does the full LK now.  It hasn't crashed yet.

Revision 1.43  96/05/23  11:46:44  neto
Fixed up the showing of the t array.

Revision 1.42  96/05/22  17:22:09  neto
Removed a redundant test for |best\_scheme\_id| == 13.
Added |length\_t\_pcast| where necessary.  (Ooops!)

Revision 1.40  96/05/22  16:34:08  neto
Fixed announcement of generic rollback.

Revision 1.39  96/05/22  15:49:08  neto
Added a forgotten \#endif

Revision 1.37  96/05/22  15:39:12  neto
Make debugging output rely on value of |verbose|, and only compiled in
if |ALLOW\_VERBOSE| is defined.

Revision 1.36  96/05/22  14:36:46  neto
Runon comment!!!
Terminated properly now.

Revision 1.34  96/05/22  13:38:10  neto
During backtracking, we must clean up our scheme even though best\_gain>0
because that may be due to some other scheme.
Also, add some debugging output for generic flips.

Revision 1.33  96/05/21  13:55:57  neto
Refine the case 1.2 legality test for t6.
Added some Case marker comments.

Revision 1.32  96/05/21  13:30:11  neto
Fixed the inorder query in the reverse direction.

Revision 1.30  96/05/21  12:24:30  neto
Fixed log comments.
All initial 3-changes are checked for feasibilty before we commit to
adding them.
For 4-changes, we perform the feasibility checks that are possible
with cities 1-6 before picking 7.
Added legality checks for 4-changes.
Gave intuitive-style "proofs" as to why the performed checks are necessary
and sufficient.

Revision 1.29  96/05/16  15:42:54  neto
Fixed stupidity with scheme 2 dating back to analysis time.

Revision 1.28  96/05/16  15:31:15  neto
Added missing initial flip to scheme 2 (transcribing problem).

Revision 1.27  96/05/16  15:25:20  neto
Enforce |7!=3| in scheme 2.

Revision 1.26  96/05/16  15:10:02  neto
Fixed one place where |base\_scheme[6]| wasn't properly being set.

Revision 1.25  96/05/16  15:01:20  neto
Made |base\_scheme| an array. Does this work?

Revision 1.24  96/05/16  13:40:09  neto
Optimized scheme 3 feasibility check (now legality checks are finished sooner.)
Defensive switches: add default clause to every switch.
(Caught a bug: need to restore old values of |base\_scheme| for later
backtracking.)

Revision 1.23  96/05/16  12:58:26  neto
Comment about scheme 11.

Revision 1.22  96/05/16  12:47:18  neto
Fixed scheme 10.

Revision 1.21  96/05/16  12:36:15  neto
Fixed scheme 9, including an errant last move in the sequence of lflips.

Revision 1.20  96/05/16  12:03:39  neto
Fixed scheme 6.

Revision 1.19  96/05/16  11:55:45  neto
Fixed scheme 1 (see notes)

Revision 1.18  96/05/15  14:55:21  neto
Made |a| the last city in |tour\_inorder(a,b,c,d)|.  This is how
I use it.

Revision 1.17  96/05/15  14:28:10  neto
Fixed a missing indirection error on constraints for |t[7]|.

Revision 1.16  96/05/15  14:00:11  neto
Print the tour when neighbour conditions not met.

Revision 1.15  96/05/15  13:54:06  neto
Even more debugging output.

Revision 1.14  96/05/15  13:17:34  neto
More debugging output.

Revision 1.13  96/05/14  17:49:26  neto
Added debugging output.
Somehow I'm not undoing an unsuccessful scheme.

Revision 1.12  96/05/14  17:20:56  neto
ID to Id

Revision 1.11  96/05/14  17:20:11  neto
Replaced RCS Header with Id.
}

\def\t#1ip#2{t_{#1i+#2}}
@@s t2ip1 TeX
@@s t2ip2 TeX
% The following would be cruel...
%\def\twoxi{2i}	 
%@@@@s two_i TeX

@@*Johnson, Bentley, McGeoch, and Rothberg.
This module is my implementation of my understanding of the Johnson,
Bentley, McGeoch and Rothberg description of their implementation of
the Lin-Kernighan algorithm.
I hope that's clear.  If it is, then here's some more trouble:
I haven't got their report (it wasn't available as of February 28, 1996),
so I am going by the description given in Johson and McGeoch's
chapter on local search for the TSP. 

% Format |length_t| as if it were the keyword |int|
@@s length_t int

@@ This module provides the following interface.

Procedures 
|jbmr_setup| and |jbmr_cleanup| are the usual intialization 
and shutdown routines.

Procedure |jbmr_run| does the actual local search.

@@ Procedure |jbmr_run| uses the currently registered oriented tour implementation, which is
accessed through the routines beginning with |tour_|.  It assumes a
starting tour has already been constructed.  

It also uses nearest neighbour lists, already constructed by module
\module{NN}.


@@ The outline of this module is as follows:
@@c
#include <config.h>
#include "lkconfig.h"
@@<System headers@@>@@;
@@<Early module headers@@>@@;
@@<Module headers@@>@@;

@@<Module definitions@@>@@;
@@<Module types@@>@@;
@@<Module variables@@>@@;
@@<Module subroutines@@>@@;
@@<Subroutines@@>@@;
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.191 1998/05/23 16:49:20 neto Exp neto $";

@@ We will be using many routines from external libraries.  The interfaces
to those routines are described in the following headers.

@@<System headers@@>=
#include <stdio.h>
#define __USE_MISC		/* Linux needs this to get the definition of |nrand48| */
#include <stdlib.h>
#include <stddef.h>
#include <limits.h>
#include "fixincludes.h"

@@ The exported interface is contained in the \file{jbmr.h} header file,
which has the following form.

@@(jbmr.h@@>=
extern const char *jbmr_rcs_id;
@@<Exported subroutines@@>@@;

@@ To ensure consistency between the interface and the implementation,
we include our own header.
@@<Module headers@@>=
#include "prng.h"
#include "jbmr.h"


@@ 
Up front, we know we'll need interfaces to
the error checking and memory allocation
modules, the |length_t| type (from 
\module{length}), the |cost| function (from \module{read}), and
the nearest 
neighbour lists |nn_list| (from \module{nn}).  We also want the
|incumbent_len| variable (from \module{lk}), which we will be modifying.

@@<Early module headers@@>=
#include "error.h"
#include "memory.h"
#include "length.h"
#include "read.h"
#include "nn.h"
#include "lk.h"


@@*Setup and cleanup.
Procedure |jbmr_setup| just allocates the resources required by this module,
and sets up some module-level convenience variables.

@@<Subroutines@@>=
void
jbmr_setup(int the_n) {
	n = the_n;
	@@<Other setup code@@>@@;
}

@@
@@<Exported subroutines@@>=
void jbmr_setup(int the_n);

@@ We should declare |n|.
@@<Module variables@@>=
static int n;	/* The number of cities. */

@@ Deallocation is simple (especially with named sections!).
@@<Subroutines@@>=
void 
jbmr_cleanup(void)
{
	n=0;
	@@<Other cleanup code@@>@@;
}

@@
@@<Exported subroutines@@>=
void jbmr_cleanup(void);

@@
We'll maintain a set of ``dirty'' cities, \ie, those cities 
whose edges have been modified since the last time they were declared
locally optimal.  

Bentley invented this notion (as near as I can tell)
in the paper ``Fast algorithms for the geometric TSP'' (check title).
However, he implemented this using the concept of a ``don't-look'' bit.
Johnson, Bentley, McGeoch, and Rothberg adopt this notion,
with the same name.

Notice the ``don't look'' bit 
is in the reverse sense in which I'm thinking about this
problem.  That is, Bentley's bit is {\it off} when there is work to
be done.  I prefer to think of it in the positive terms.  That is,
there is an entry in the dictionary for every city for which there
is work to be done.  This is inspired by the notion of 
page table ``dirty'' bits
from operating systems work.


@@ We'll use a dictionary for this structure.  
We know that at some points in the
execution, for instance at the beginning, every city will be ``dirty''.
So we dispense with dynamic allocation for every transaction with the 
dictionary.  Instead, we'll just allocate an entire array at once.

@@<Other setup code@@>=
dirty_work = new_arr_of(int,n);
{ int i;
	for (i=0;i<n;i++) dirty_work[i] = i;
}

@@ We must declare this array.
@@<Module variables@@>=
static int *dirty_work;

@@ Cleaning up this portion is just deallocation. 
@@<Other cleanup code@@>=
free_mem(dirty_work);

@@ We'll also need to maintain a set of added edges.  JBMR never delete
an added edge.  In particular, this leads to the guarantee that we'll
never explore more than |n| moves for a particular improvement sequence.

Papadimitriou's variation (INSERT REFERENCE) 
dispenses with the added edges list and
instead never inserts a previously deleted edge.  This extends the
possible depth to roughly all |n(n-1)/2| (undirected) edges.  
This 
version of the Lin-Kernighan algorithm is the basis of a PLS-complete
problem.  I would like to implement this variation at some point in the
future.  The machinery is in place now.

I'll use  a dictionary to maintain the set of added edges.  We'll
allocate these as we need them, as this will likely be a small list.
So we don't allocate anything for this purpose on a module-level basis.

An alternative way of doing this is to forget messing around with 
the whole dictionary and to just compare with pairs of entries in the |t| array.
This not only saves space, but it may be faster in the common case, that is,
when the search is shallow.


@@*The Lin-Kernighan algorithm.
Ok.  Here's the big enchilada.

This is a local search routine.  It makes improvements until it can find
no more.  There are possible improvements to be made as long as there
are dirty cities.

We also implement the Iterated Lin-Kernighan scheme of Johnson
(INSERT REFERENCE) which was inspired by Martin-Otto-Felten's use of
chained local optimization.

@@<Subroutines@@>=
void 
jbmr_run (const int iterations, prng_t *random_stream) 
{
	@@<|jbmr_run| variables@@>@@;
	dict_t *dirty_set;
	int *dirty, iteration;

	@@<One-shot initialize@@>@@;
	@@<Allocate |jbmr_run| sets and arrays@@>@@;
	@@<Create the dirty set@@>@@;
	@@<Make all cities dirty@@>@@;
	@@<Show initial milestone@@>@@;

	for ( iteration=0; iteration < iterations ; iteration++ ) {
		@@<Per-iteration initialization@@>@@;
		while ( (dirty = (int *)dict_delete_any(dirty_set,NULL)) != NULL ) {
			@@<Search for an improving sequence starting at |*dirty|@@>@@;
		}
		@@<Verbose: report end of LK step@@>@@;
		@@<Revert to the previous solution if it was better@@>@@;
		@@<If doing another iteration, perturb with a double-bridge@@>@@;
	}
	@@<Verbose: report termination of LK phase@@>@@;
	@@<Show final milestone@@>@@;
	@@<Deallocate |jbmr_run| sets and arrays@@>@@;
	@@<Verbose: print statistics@@>@@;
}

@@
@@<Exported subroutines@@>=
void jbmr_run(const int iterations,prng_t*random_stream);

@@ We need the dictionary interface.   
And the dictionary itself needs the pool-oriented
memory allocator interface.
@@<Module headers@@>=
#include "pool.h"
#include "dict.h"

@@ We need to specify a comparison function and a printing function for cities.
@@<Create the dirty set@@>=
dirty_set = dict_create(cmp_int,prn_int);

@@ These are easily defined.

In other places I have augmented comparison functions to use the pointer
difference as a tie-breaker.  It turns out that |cmp_int| is only
used in conjunction with |dirty_set|, which in turn is defined over
the elements of |dirty_work|, which is just the identity function.  So
tie-breaking is meaningless here: the values are equal if and only if
the pointers are equal.
@@<Module subroutines@@>=
static int
cmp_int(const void *a, const void *b) {
    return (*(const int *)a)-(*(const int *)b);
}

static void 
prn_int(void *a) {
    printf("%lx=int %d",(unsigned long)a,*(int *)a);
}


@@ To make all cities dirty, we just insert every city into |dirty_set|.

@@d mark_dirty(CITY) (dict_insert(dirty_set,dirty_work+(CITY)))

@@<Make all cities dirty@@>=
{ int i;
dict_delete_all(dirty_set,NULL);
for (i=0;i<n;i++) {
	mark_dirty(i);
}
}

@@ We must also dispose of the dictionary.  We don't need a freeing action 
because the |dirty_work| array is deallocated in the |jbmr_cleanup| routine.

@@<Deallocate |jbmr_run| sets and arrays@@>=
dict_destroy(dirty_set,NULL);


@@ We'll need an array to remember the sequence of cities in the LK change.
I follow the notation introduced by Lin and Kernighan and use a 1-based
array named |t|.

For example, |t[1]| is the anchor to the Hamiltonian path, and |(t[1],t[2])|
is the first edge removed, and  |(t[2],t[3])| is the first edge added.
In general, edge |(t[2i-1],t[2i])| is the $i$'th edge removed, and
|(t[2i],t[2i+1])| is the $i$'th edge added.  
Edge 
|(t[2i],t[1])| is always a ``phantom'' edge, \ie, it is the edge which 
completes the Hamiltonian path to a Hamiltonian cycle, but is never drawn
in the descriptions of the LK algorithm.

This array 1-based and is treated as a growable array.
The array itself is |t|; the number of entries allocated to it is 
|t_max_alloc|.



@@<|jbmr_run| variables@@>=
int *t, t_max_alloc;

@@ 
The common case is for the 
|t| array to be
small. The average number of entries is roughly at most 
$14=8+6$ --- see the chapter
by Johnson and McGeoch.  Allocating 128 entries is a good compromise 
between saving on reallocations and saving space.

@@<Allocate |jbmr_run| sets and arrays@@>=
t_max_alloc = 128;
t = new_arr_of(int,t_max_alloc);

@@
@@<Deallocate |jbmr_run| sets and arrays@@>=
free_mem(t);

@@ We need a code fragment that will grow the array when necessary.

Doubling the size of the array each time we grow it 
requires at most constant amortized work per cell used. 

Under some  circumstances (known at compile-time),
we must notify others that we have moved the array.  
In particular, we must
update the nodes in the tabu splay tree.

@@<Make sure |t[two_i+2]| is valid@@>=
if ( two_i+3 >= t_max_alloc ) {
#if defined(TABU_SPLAY)
	int *old_t = t;
#endif
	do {
		t_max_alloc *= 2;	
	} while ( two_i+3 >= t_max_alloc );
	t = (int *)mem_realloc(t,sizeof(int)*t_max_alloc);
	@@<|t| has moved from |old_t| to |t|@@>@@;
}


@@ An extra tour query.  In my analysis, I found it useful to create the
following oriented tour query: |tour_inorder(a,b,c,d)| assumes that
|(a,b)| is an edge in the current tour, and answers the question ``in
a traversal of the tour beginning at |a| and going in the direction of
|b|, do we reach |c| no later than |d|? (We always count |a| as last.)''.

@@<Module subroutines@@>=
static int tour_inorder(int a, int b, int c, int d);
static int
tour_inorder(int a, int b, int c, int d) {
	if ( tour_next(a) == b ) return tour_between(b,c,d);
	else if ( tour_prev(a) == b ) return tour_between(d,c,b);
	else {
		@@<Debug: print the tour@@>@@;
		errorif(1,"Bad tour_inorder(%d,%d,%d,%d)\n"); 
		return -1;	/* Satisfy {\tt gcc -Wall}. */
	}
}

@@ We will need to record the cumulative improvement in the {\it Hamiltonian
path\/} following 
this sequence of moves.  This is recorded in the variable |cum_gain|.

Positive values mean net gains.

We'll also record, in |best_gain|, the gain made by the best {\it tour\/}
along this sequence (or along any two-city offshoot of this sequence).  
Note that |best_gain| and |cum_gain| are
not directly comparable because |cum_gain| doesn't include the cost of the
closing edge, \ie, the edge that joins the two ends of the Hamiltonian path.


%We use |possible_gain| as a working variable to compute the
%gain to be had by terminating the search now.
% |length_t possible_gain|;

@@ Some experiments that I run use a floating point type for |length_t|.
Unfortunately, sometimes these experiments don't terminate, especially
as problem sizes become larger, \eg, random Euclidean inputs with
$10^5$ or more cities.   (This happened the week of December 11, 1996.)

Some of the smaller runs that do manage to terminate end with 
a badly underestimated tour length; I check the computed ``incumbent'' length 
in |incumbent_len| against a freshly computed tour length.  This effect
increases with the problem size.

After
a little bit of thought, my best guess is that I run into the problem of
\term{catastrophic cancellation}.  
@@^catastrophic cancellation@@>
@@^precision@@>
@@^numerical analysis@@>
@@^floating point@@>
That is, when we compute the difference
between two nearly-equal numbers, most of the precision is lost. 
In our case, we are alternately adding and then subtracting edge costs
from the variable |cum_gain|.  We may even end up getting the wrong
sign in the end.  This, of course, easily leads to non-termination.

So, I split |cum_gain| into a positive part and a negative part,
|cum_gain_pos| and |cum_gain_neg|.  These three numbers are  are related
by the following equation:
$$
\hbox{|cum_gain|} = \hbox{|cum_gain_pos|} - \hbox{|cum_gain_neg|}.
$$
Actually, this allows a degree of freedom, and I constrain it somewhat
by stipulating
that both |cum_gain_pos| and |cum_gain_neg| should be non-negative numbers.
This is just like the construction of the set of integers as a set
of equivalence classes of pairs of natural numbers.  

In the present situation,
edge costs that increase the cumulative
gain (lengths of removed edges) are added to |cum_gain_pos|, and  edge costs
that decrease the cumulative
gain (lengths of added edges) are added to |cum_gain_neg|.  
I assume here that the |cost| function is non-negative.  In fact, it will
usually be positive-definite.

@@ On the other hand, I split these gain variables before I implemented the
idea of an \term{instance epsilon} (see below), which might alleviate the
same problem.  
@@^instance epsilon@@>
@@^epsilon, instance@@>
When the length type is inexact, the default is to split the gain variable
into positive and negative parts because that is safest.  
But this default may be overridden at compile time by defining the
symbol
|JBMR_REQUIRE_JOINED_GAIN_VAR|, say in file \file{lkconfig.h}.  
This symbol has no effect when the length type is exact.

Compile-time constant |LENGTH_TYPE_IS_EXACT|, provided by module
\module{LENGTH}
is non-zero when |length_t| is a type in which computations
are exact, \eg\ |length_t| is an integer or rational type.  
It is zero
when  there might be a loss of precision, \eg\ when |length_t| is
either |float| or |double|.

@@<Module definitions@@>=
#if LENGTH_TYPE_IS_EXACT || defined(JBMR_REQUIRE_JOINED_GAIN_VAR)
#define SPLIT_GAIN_VAR 0
#else
#define SPLIT_GAIN_VAR 1
#endif

@@ Now we can define the positive and negative cumulative gain variables.
@@<|jbmr_run| variables@@>=
#if SPLIT_GAIN_VAR
length_t cum_gain_pos, cum_gain_neg;
#endif

@@ Variable |best_gain| is always assigned the current value of the gain,
minus an edge cost.  So there is no need to break it up into positive
and negative parts.

@@<|jbmr_run| variables@@>=
length_t best_gain;

@@ Now, when using an integer type for |length_t|, we don't want to
overflow the representation.  So summing the alternating series in
a single variable is in fact decidedly {\it better\/} than splitting
it up.  So we need to retain the integer manipulations of |cum_gain|
and related variables anyway.  

We use the compile-time constant |SPLIT_GAIN_VAR| to distinguish the
two cases.

@@<|jbmr_run| variables@@>=
#if !SPLIT_GAIN_VAR
length_t cum_gain;
#endif

@@
The variables |best_two_i|, |best_exit_a|, and 
|best_exit_b| are defined by the following invariant:
{\medskip\leftskip=0.75in\rightskip=0.75in\noindent
The gain recorded in |best_gain| is put into effect 
by the changes encoded in |t[1]| through |t[best_two_i]|, followed
by the two cities |best_exit_a|, |best_exit_b|.\medskip}


The Lin-Kernighan algorithm includes many special cases for the initial 
2/3/4-change, and this affects the moves required for the exit.  If 
the best tour is found amongst these first few moves, then we must know
which sequence of moves to perform to get this best gain.  The identity
of this scheme is remembered in |best_scheme_id|, which takes on
values between 0 and 12, inclusive, for the initial 2/3/4-changes, and
13 for a generic change beyond that.  
See below
for a detailed discussion and encoding of these schemes.  It takes on the
value |-1| if it hasn't been defined yet.  

The value of |best_two_i| is always even.    
We maintain the invariant that  |best_scheme_id<0 == (best_gain == 0)|.
@@<|jbmr_run| variables@@>=
int best_two_i, best_exit_a, best_exit_b, best_scheme_id;


@@ I'll also use a boolean variable |more_backtracking| to signal when we should
keep on looking.  This variable will be non-zero when we should continue
looking for starting sequences for the
tabu search, and false otherwise.  In particular, its value is 
the negation of the boolean value of the phrase ``an improving move has
been implemented''.
This variable is used to escape from
various loops in this search.  

Now, |more_backtracking| will almost be synonymous with |best_gain==0|.  
However,
there is one place where they mean something different.  If the initial
segment of the |t| list is an improving (valid) 2-change, then |best_gain>0|
will hold, but we still want to look deeper, at least three levels deep.

So, you ask, why not postpone the setting of  |best_gain| until we enter
the non-backtracking portion of the tabu search?  The problem with this
is that, in case the 2-change is the best improvement we can make, we
don't end up pruning the search as much as we ought to.  That is, all
of the search, including the backtracking search for the initial 3-opt, ought
to be pruned by the 1-tree condition: |best_gain < cum_gain|, which 
is the same as |best_gain + cum_gain_neg < cum_gain_pos|.

This is why we need a seperate boolean variable.

In fact, an improving initial 2-change is not the only situtation where we
need to keep searching in spite of having an improvement already in hand.
{\it Lookahead\/} (see below) also requires us to have this kind of escape.

@@<|jbmr_run| variables@@>=
int more_backtracking;

@@ We will need a few bookkeeping variables.  

The integer |two_i| will be
an index in to the |t| array that points to the active endpoint, \ie, the
city at the end of the Hamiltonian path that is opposite to t[1], the anchor.
To put it another way, |(t[1],t[two_i])| is the phantom edge.

%The eight-entry (though 1-based) array |nn| is a set of read
%cursors into nearest neighbour lists.
%This is used to enumerate candidate neighbours.
% |int nn[9];|

@@<|jbmr_run| variables@@>=
int two_i;

@@*Constraints on the search. 
See my notes of March 7 and April 22 
for an explanation of the case analysis involved
in cycling through all the possible 3-changes (and sometimes 4-changes).

There are four kinds of constraints on the cities that we choose:
\emphpar{%
1.~The LK condition says that the cumulative 1-tree gain must be
greater than the improvement represented by the best tour gain discovered
so far.
In terms of our program variables, this is expressed by |cum_gain > best_gain|,
\ie, |cum_gain_pos > best_gain + cum_gain_neg|.
This is
the main stopping criterion, and it is checked both as we generate the
initial 2/3/4-change, and as we generate the cities on the
deep $\lambda$-change.  I will also call these ``deep'' changes 
{\sl generic}.
}

\emphpar{%
2.~The JBMR tabu edge condition says 
``never delete an added edge''.  This condition
will be checked as we generate both the initial 2/3/4-change 
and the deep portion of the $\lambda$-change.
}

\emphpar{%
3.~The specified edge changes must be feasible.  
That is, there must
always be a legal sequence of flips to get from the current tour to the
tour specified by the changes.  This is where the handling
of the initial 2/3/4-change differs from the rest of the $\lambda$-change.
}

\emphpar{%
The starting 2/3/4-change is checked for feasibility only after the entire
2/3/4-change is specified.  This is because the entire sequence of
flips required to effect the
change depends on the placement of even the last city in the sequence.
For example, see how the flips that implement cases 2.2.2.1.1 and 2.2.2.1.2
differ even in their first filp, even though only the position of the
last city changes between the two cases.  
}

\emphpar{%
Beyond the 2/3/4-change, \ie, the regular ``deep'' $\lambda$-changes
are checked as they are generated, just like for the other two conditions.
}

\emphpar{%
4.~I have added a ``stupid check'': during backtracking, never add the
most recently deleted edge.
This way we avoid covering the same ground twice while generating the
initial  2/3/4-change.  It also quickly eliminates some illegal choices,
specifically, in schemes 1, 8, and 11.
% THINK ABOUT THIS MORE CAREFULLY IN THE t[7] case, because we may want
%  to end up with  a different sequence ending?
%  Well, scheme 11 shows that it is useful at the t[7] level.
}

@@*Table-driven flips.
Now, if you look at the case analysis of April 22, you will see that there
is no discernable pattern to the flips required to effect the changes
in the initial 2/3/4-change.  Because of this, I use a table-driven 
approach to encoding these flips.  Instead of using in-line code implementing
the case analysis, I'm just going to encode my handiwork.

Encoding my handiwork in a table is simpler, smaller, and maybe even faster.
(It might be faster because the branches are easier to predict, either by
the compiler, or by the processor.)

@@ I should mention that there are in fact many possible ways to effect the
required 2/3/4-change.  I am only recording one.  If it is infeasible, then
this 2/3/4-change is declared infeasible.  Note that this is a conservative
approximation, and that it is conceivable that an alternative implementation
of the same 2/3/4-change might be feasible.  

However, I have chosen not to look for alternative implementations for
the following reasons.  

First, this search may take up too much time, and
is not likely to be of much benefit.  A change is infeasible because it
repeats at least one city, and perhaps repeats many.  If we fail once, then
we are making changes in a tight corner, and it is likely that many alternative
flip sequences encoding that change 
will also fail.  Why go through the bother of enumerating
all these alternatives when a simpler change can probably effect just
as good a gain?

Second, it was difficult enough to find the effecting sequences of flips
in the first place.  In fact, in my March analysis I didn't even see
that the 2/3/4-change required special handling (\ie, different from
the deeper changes in the $\lambda$-change).  Writing a program to 
enumerate all possible flips implementing a given 2/3/4-change would be a 
task comparable to writing a program enumerating 
all the possible solutions to the Rubik's
cube.  I don't want to do that.

@@  Here is the encoding of the flips required to effect the various
cases.

Array
|scheme[s]| holds the sequence of indices into the |t| array that implement
scheme |s|.  This sequence is read from left to right in groups of four.
A group of indices $a,b,c,d$ means apply |tour_flip(t[a],t[b],t[c],t[d])|.

The last entry of scheme |s| is in |scheme_max[s]-1|.
Array |scheme_num_cities| records the number of cities involved in each of
the schemes, \ie, the largest index into |t|.

The translation between case numbers (from my April 22 notes) and scheme
numbers is given in the comments.

@@<Module variables@@>=
static int scheme[14][16] =@@+{@@;
{
1,2,5,6,
4,3,2,5 },
/* Scheme 0, case 1.1.1 */

{
1,2,6,5,
2,6,4,3,
1,5,4,6 },
/* Scheme 1, case 1.1.2 */ 

{
5,6,3,4,
1,2,6,3,
6,2,8,7,
1,3,2,8 },
/* Scheme 2, case 1.2.1 */ 

{
5,6,3,4,
8,7,6,3,
1,2,3,8 },
/* Scheme 3, case 1.2.2 */ 

{
1,2,3,4 },
/* Scheme 4, case 2 */ 

{
1,2,3,4,
1,4,6,5,
6,4,8,7,
1,5,4,8 },
/* Scheme 5, case 2.1.1.1 */ 

{
1,2,3,4,
6,5,8,7,
1,4,5,8 },
/* Scheme 6, case 2.1.1.2 */ 

{
1,2,3,4,
1,4,5,6 },
/* Scheme 7, case 2.1.2 */ 

{
1,2,5,6,
5,2,3,4 },
/* Scheme 8, case 2.2.1 */ 

{
6,5,8,7,
4,3,8,5,
1,2,3,8 },
/* Scheme 9, case 2.2.2.1.1 */ 

{
1,2,8,7,
1,7,6,5,
1,5,2,8,
4,3,2,5 },
/* Scheme 10, case 2.2.2.1.2 */ 

{
6,5,4,3,
6,3,8,7,
1,2,3,8 },
/* Scheme 11, case 2.2.2.2.1 */ 

{
6,5,8,7,
1,2,5,8,
5,2,3,4 },
/* Scheme 12, case 2.2.2.2.2 */ 

{-1}	/* Scheme 13, a generic change, so this entry is unused apply */
}@@+;

static int scheme_max[14] = { 8,12,16,12,4,16,12,8,8,12,16,12,12,0 };
static int scheme_num_cities[14] = { 6,6,8,8,4,8,8,6,6,8,8,8,8,0 };

@@ We also need a scheme selection variable |scheme_id|.
It is declared local to the |jbmr_run| procedure, because it should not
be shared with other threads.

We determine the final value of |scheme_id| by performing the case
analysis as in my notes, all the while keeping |scheme_id| at value |-1|.  
During this determination, we use an 
array |base_scheme| indexed in the same way as |t|.
The value of |base_scheme[k]| is as 
tight a lower bound on the
final value of |scheme_id| as we can manage given the selections made
up to and including city |t[k]|.  Since schemes involve at most eight
cities, the values of index $k$ are bounded from above by 8.

When the analysis is finished, 
we set |scheme_id| and implement the changes required
for that scheme.  We maintain the invariant that |scheme_id == -1| if and
only if no intial 2/3/4-change has been implemented.

@@<|jbmr_run| variables@@>=
int scheme_id, base_scheme[9];


@@*Performing the search.
At the very least, this code assumes that we have allocated at least
nine (8+1) entries in the |t| array.

We examine both neighbours of |t[1]| as possibilities for |t[2]|.  
Because it may lead to a better initial gain, we first try the farther
tour neighbour of |t[1]|.  This is a greedy criterion; Lin and Kernighan
use this kind of criterion to prefer one neighbour of |t[7]| over the other.

@@<Search for an improving sequence starting at |*dirty|@@>=
{
	int t1_n[2], t1_i;
	length_t t1_l[2];
	@@<Verbose: announce start of search at |*dirty|@@>@@;
	t[1] = *dirty;
	t1_n[0] = tour_prev(t[1]);
	t1_n[1] = tour_next(t[1]);
	t1_l[0] = cost(t1_n[0],t[1]);
	t1_l[1] = cost(t1_n[1],t[1]);
#if JBMR_FARTHER_T1_FIRST
	if ( t1_l[0] < t1_l[1] ) {
		int tmp;@@+
		length_t tmp_l;
		tmp = t1_n[0];@@+t1_n[0] = t1_n[1];@@+t1_n[1] = tmp;
		tmp_l = t1_l[0];@@+t1_l[0]=t1_l[1];@@+t1_l[1]=tmp_l;
	}
#endif

	@@<Initialize the bookkeeping variables@@>@@;
	put_city(1);
	for ( t1_i = 0 ; t1_i < 2 && more_backtracking; t1_i++ ) {
		t[2] = t1_n[t1_i];
		@@<Verbose: new |(t1,t2)|@@>@@;
#if !SPLIT_GAIN_VAR
		cum_gain = t1_l[t1_i];
#else
		cum_gain_pos = t1_l[t1_i];
		cum_gain_neg = 0;
#endif
		put_city(2);
		@@<Search from |t[2]|@@>@@;
	}
	if ( best_gain > 0 ) {
		incumbent_len -= best_gain;
		@@<Verbose: announce improvement by |best_gain|@@>@@;
		@@<Check milestone@@>@@;
		@@<Set the |instance_epsilon| slop value@@>@@;
	}
}

@@  We initialize the cumulative gain components |cum_gain_pos| and
|cum_gain_neg| so that GCC's dataflow analysis doesn't complain when
the debugging code is allowed.

@@<Initialize the bookkeeping variables@@>=
#if !SPLIT_GAIN_VAR
cum_gain = 0;
#else
cum_gain_pos = cum_gain_neg = 0;
#endif
best_gain = 0; best_two_i = 0; best_exit_a = best_exit_b = -1;
more_backtracking = 1; scheme_id = best_scheme_id = -1;

@@*Searching at level 0.  
As you may have guessed already (for instance from the presence of the
variable |more_backtracking|), the Lin-Kernighan algorithms performs some
backtracking.  Now, it's an odd beast in that it neither performs arbitrary
depth backtracking---for instance as every branch and bound algorithm does---
nor does it perform zero backtracking, as most pure greedy algorithms do.
If it chose either of these strategies, then our code 
would be simplified because of the regularity of these search paradigms.

Instead Lin-Kernighan is a hybrid, performing backtracking on the 
first few levels, and
probing in a purely greedy manner at deeper levels.
Fortunately, ``first few'' really means
``is bounded by a constant''.  So it will be convenient for us to build
and iterate through 
a fixed amount of state using ordinary nested loops.

Just to make things more interesting, 
the combinatorics of $k$-changes forces
each level of the search to have its own oddities, so each must be coded
differently in places.
Yet much of the code has the same overall structure, and we would like
to reflect that single architecture by using a single collection of 
named sections.  

Now, sit down, because I'm about to tell you how I managed to reconcile
these conflicting coding design goals.  Believe me, you won't like it.

Here it is.  
Most of the code is in a single collection of named sections.   The
top level of these is replicated once for each of the four levels of 
backtracking.  However, the oddities of each are separated out via
conditional compilation using the macro |BL|, which stands for {\sl
backtracking level}, and takes on one of the values 0, 1, 2, or 3.  

Actually, this code isn't nearly as ugly as it used to be.  

@@
The search from |t[2]| is a prototype for the search from any city
in an even-numbered position in |t|.    They all share the same style:
first generate the list of all eligible moves from this point, and then
iterate through them.

INSERT MATERIAL ABOUT DECLUSTERING.

@@<Search from |t[2]|@@>=
two_i = 2;
@@<Verbose: update |probe_depth|@@>@@;
#define BL 0
{
#if JBMR_DECLUSTER_IN_ELIGIBILITY_TEST
const length_t cluster_dist=decluster_d(t[1],t[2]);
#else
const length_t cluster_dist=0;
#endif
@@<Update |best_gain| and compose a list of eligible moves@@>@@;
}
@@<Sort |e[BL]|@@>@@;
#undef BL
@@<Backtrack at level 0@@>@@;

@@ We employ lookahead as described in section 2B of the original LK
paper.  
It is also adopted by JBMR.  

This lookahead criterion states that we must choose the next two cities
so that
$$\cost(t[2i],t[2i+1]) - \cost(t[2i+1],t[2i+2])$$
is minimized.  That is, we go to the shortest succeeding Hamiltonian Path.

If we are in an initial special case, then we may be doing backtracking.
So we need to create a list
of such candidate moves; it will be convenient to sort them according to
the above criterion.

In such an array, each move's entry records the proposed choices for
|t[2i+1]| and |t[2i+2]|, 
the scheme ID (if applicable), and the net gain as expressed in 
|gain_pos| and |gain_neg|, the positive and negative parts of the gain.

@@<Module types@@>=
typedef struct {
	length_t gain_for_comparison;
#if JBMR_DECLUSTER_IN_ELIGIBILITY_TEST || JBMR_DECLUSTER_IN_GREEDY 
	length_t cluster_dist;
#endif
#if !SPLIT_GAIN_VAR
	length_t gain;
#else /* |SPLIT_GAIN_VAR| */
	length_t gain_pos, gain_neg;
#endif /* |SPLIT_GAIN_VAR| */
	int t2ip1, t2ip2, scheme_id;
} eligible_t;

@@ Each of the four possible search levels --- 
for searches at |two_i| being equal to
2,
4, 6, or higher --- has its own array of candidates.
These are stored in
the |e| array, in positions 0, 1, 2, and 3, respectively.  
% Only the first entry on the deepest level is used, because there is no
% backtracking at the deepest level.

@@<|jbmr_run| variables@@>=
eligible_t *(e[4]);

@@ Each entry must contain space for
least twice |nn_max_bound| entries because for each choice of |t[2i+1]|, there
are up to two choices for |t[2i+2]|.

@@<Allocate |jbmr_run| sets and arrays@@>=
e[0] = new_arr_of(eligible_t,nn_max_bound*2);
e[1] = new_arr_of(eligible_t,nn_max_bound*2);
e[2] = new_arr_of(eligible_t,nn_max_bound*2);
e[3] = new_arr_of(eligible_t,nn_max_bound*2);

@@
@@<Deallocate |jbmr_run| sets and arrays@@>=
free_mem(e[0]);
free_mem(e[1]);
free_mem(e[2]);
free_mem(e[3]);

@@ Now, we may have varying numbers of eligible sequences at each of the levels.
In particular, we may have fewer than |nn_max_bound| valid entries in the 
0, 1, or 2
entries 
of |e|.  Array |en| holds
these counts, and is indexed in the same way as |e|.

@@<|jbmr_run| variables@@>=
int en[4];

@@ During the actual backtracking search, we also need to know where amongst
the |e| array we are right now.  So we need four cursors, one for each
backtracking level.  These are stored in the integer array |ec|.  

At any point in the search, only entries |ec[0]| through |ec[BL]| are valid.
Furthermore, if |ec[i]| is valid, then |0<=ec[i]<en[i]|.

@@<|jbmr_run| variables@@>=
int ec[4];


@@
Some of my experiments with |length_t==double| did not terminate. 
This happened even
after I split the gain variables (|cum_gain|, |cum_1|, and |cum_2|) into 
positive and negative parts in order to avoid catastrophic cancellation.
Examining a particular run, I noticed that this program eventually
got itself into
an endless loop, bouncing back and forth between 
two 3-changes every 25 tries at a new |t[1]|.  I think each of these
3-changes cancelled the other, but very small rounding errors in the 
caused the program to think that each was an improving 3-change.  Clearly,
the program was wrong about one of them.

My proposed fix is to use a positive slop value, |instance_epsilon|, and prune
any sequence of moves with a smaller cumulative gain than this.
Now, I call this value |instance_epsilon| to distinguish it from the 
machine epsilon, |LENGTH_MACHINE_EPSILON|. (|LENGTH_MACHINE_EPSILON| is
is the smallest number that can be added to 1 so that the result
is distinguishable from 1.)  

Actually, we prune any sequence of moves with a cumulative gain less
than the current best tour gain plus the instance epsilon.  Since we're
always testing against |best_gain+instance_epsilon|, I define a new
variable |best_gain_with_slop| that is just this sum.   This saves
us a floating point addition every time we test against this value.

%We initialize |instance_epsilon| so that GCC's dataflow analysis will 
%be silenced on this point.  We use a value of 1, which if kept, would
%result in no
@@<|jbmr_run| variables@@>=
#if !(LENGTH_TYPE_IS_EXACT)
length_t instance_epsilon=incumbent_len * LENGTH_MACHINE_EPSILON;
length_t best_gain_with_slop;
#endif

@@ We must initialize |best_gain_with_slop| at the same time that we
intialize the bookkeeping variables.

@@<Initialize the bookkeeping variables@@>=
#if !(LENGTH_TYPE_IS_EXACT)
best_gain_with_slop = instance_epsilon;
#endif



@@
However, 
|instance_epsilon| and |LENGTH_MACHINE_EPSILON| are related.  
Since we eventually subtract each tour gain from the incumbent length,
we require that the tour gain be large enough so that this subtraction
makes a difference.  (Excuse the pun.)  
@@^pun@@>
So the minimum value of |instance_epsilon| is 
$$\hbox{|instance_epsilon|} = 
\hbox{|incumbent_len|} \times \hbox{|LENGTH_MACHINE_EPSILON|}.$$
This gets set upon entry to |jbmr_run| and whenever we commit to
a net tour length reduction.

@@<Set the |instance_epsilon| slop value@@>=
#if !(LENGTH_TYPE_IS_EXACT)
instance_epsilon = incumbent_len * LENGTH_MACHINE_EPSILON;
#endif

@@ The code looks really awful when we have two quasi-independent
dimensions of parameterization: exact vs.~inexact, and split vs.~joined.
The |CAREFUL_OP(LHS,OP,RHS)| takes out some of the visual clutter.   
It implements numerical comparison |OP| on left-hand side |LHS| and
right-hand side |RHS|.  The twist is that the |LHS| is a variable 
that might be split into positive and negative parts.  We try to avoid
catastrophic cancellation by adding negative parts to the right hand side.
The right hand side must end in a variable to which we may add
|_with_slop|.  Right now the only variable with that ending
is |best_gain_with_slop|.

The double hash |##| is the ANSI C token pasting
operator.  So, for example, if the length type is |double|, an inexact
type, and |SPLIT_GAIN_VAR| is true, then 
$$\hbox{|@@[CAREFUL_OP(cum_gain,<,best_gain)@@]|}$$ translates into
$$\hbox{|((cum_gain_pos)<(best_gain_with_slop)+(cum_gain_neg))|.}$$

@@<Module definitions@@>=
#if LENGTH_TYPE_IS_EXACT
#define CAREFUL_OP(LHS,OP,RHS) ((LHS) OP (RHS))
#elif SPLIT_GAIN_VAR
#define CAREFUL_OP(LHS,OP,RHS) ((LHS##_pos) OP ((RHS##_with_slop)+(LHS##_neg)))
#else
#define CAREFUL_OP(LHS,OP,RHS) ((LHS) OP (RHS##_with_slop))
#endif




@@  We use a few bookkeeping variables when we update |best_gain| and compose 
an eligible list.

The neighbour list for city |i| is computed by |nn_list(i,&nn_bound)|.
Such a list an array
of |nn_bound| city numbers,
sorted in ascending order of
distance from city |i|;
|nn_bound| is bounded above by |nn_max_bound|.

Cities |t2ip1| and |t2ip2| are the candidates for |t[two_i+1]| and 
|t[two_i+2]|, respectively.  Lengths |cum_1| and |cum_2|
are the cumulative gains when we append |t2ip1| and |t2ip2| to the |t| list,
respectively.
When |length_t| is an inexact type, these are represented by their positive
and negative parts |cum_1_pos| and |cum_1_neg|, and 
|cum_2_pos| and |cum_2_neg|, respectively.  

City |t2ip1| is chosen from the nearest neighbour list of |t[two_i]|.
Since nearest neighbour lists are sorted, we stop as soon as 
the cumulative gain dips below the current best improvement.
For each choice of |t2ip1|, we may have up to two choices for |t2ip2| --- 
the tour neighbours of |t2ip1|.   

Updating |best_gain| and composing the eligible list of moves is heavily
dependent upon the case analysis.  

If declustering is not in effect, then |cluster_dist| is always zero.
Otherwise, it is the cluster distance between |t[1]| and |t[two_i]|.

@@<Update |best_gain| and compose a list of eligible moves@@>=
en[BL]=ec[BL]=0;@@;
if ( @@[CAREFUL_OP(cum_gain,>,cluster_dist+best_gain)@@] ) {
int i, t2ip1, t2ip2, enbl, *neighbour_list, nn_bound; 
#if SPLIT_GAIN_VAR
	length_t cum_1_pos, cum_1_neg, cum_2_pos, cum_2_neg;
#else
	length_t cum_1, cum_2;
#endif
	@@<Verbose: show current position@@>@@;


#if SPLIT_GAIN_VAR
	cum_1_pos = cum_gain_pos;
#endif

	neighbour_list = nn_list(t[two_i],&nn_bound);
	for ( i=0, enbl=0; i<nn_bound ; i++ ) {
		t2ip1 = neighbour_list[i];
#if SPLIT_GAIN_VAR
		cum_1_neg = cum_gain_neg + cost(t[two_i],t2ip1);
#else
		cum_1 = cum_gain - cost(t[two_i],t2ip1);
#endif

        if ( @@[ CAREFUL_OP(cum_1,<=,best_gain) @@] ) {
			@@<Verbose: show terminating |cum_1|@@>@@;
			num_reject_by_cum_1++;
			break;
		}

		@@<Fill |e[BL][enbl]| for valid |t2ip2|'s and maybe update |best_gain|@@>@@;
	}
	en[BL] = enbl;
} else {
	num_reject_pre_e_build++;
}

@@ Variables |num_reject_by_cum_1| and |num_reject_pre_e_build| are purely
instrumentation.
@@<|jbmr_run| variables@@>=
int num_reject_by_cum_1, num_reject_pre_e_build;

@@
@@<One-shot initialize@@>=
num_reject_by_cum_1=num_reject_pre_e_build=0;


@@ On the first level, |t[4]| may be either neighbour of |t[3]|.  We don't
care which we pick first because they will be sorted by the greedy
lookahead criterion anyway.

I've factored out the code that does the updating.

@@<Fill |e[BL][enbl]| for valid |t2ip2|'s and maybe update |best_gain|@@>=
#if BL==0
	@@<Try both neighbours of |t2ip1|@@>@@;
#endif

@@ One at a time, we set |t2ip1| to each of the two neighbour current
neighbours of |t2ip1|.

Array |tour_neighbour| just lets us call either of |tour_prev| or
|tour_next|, depending on an integer parameter.  Since both those
latter functions are really just function pointers anyway, the overhead
of calling it through an array reference should be negligible.
Besides, this loop makes the code much more compact.  More compact code
should improve performance because it increases the effectiveness of 
the instruction cache.

Then again, it might be faster to unroll the loop.  
% It is unrolled if the symbol |JBMR_UNROLL_PREV_NEXT_LOOP| is defined.
If you so desire, substitute the following code for this section:

|t2ip2=tour_prev(t2ip1);|\par
|@@<Update |best_gain| and |e[BL]| if not tabu@@>@@;|\par
|t2ip2=tour_next(t2ip1);|\par
|@@<Update |best_gain| and |e[BL]| if not tabu@@>@@;|

But I warn you, this leads to very large \CEE/ files, and therefore
long compilation times.

@@<Try both neighbours of |t2ip1|@@>=
#if defined(JBMR_UNROLL_PREV_NEXT_LOOP)
#error "JBMR_UNROLL_PREV_NEXT_LOOP is not implemented"
#else
{	int which_neighbour; 
for (which_neighbour=0;which_neighbour<2;which_neighbour++) {
	t2ip2=(tour_neighbour[which_neighbour])(t2ip1);
	@@<Update |best_gain| and |e[BL]| if not tabu@@>@@;
}
}
#endif

@@ But we do need to declare array |tour_neighbour|.
It is an array of two pointers to functions that take an integer
and return an integer. Got that?
@@<|jbmr_run| variables@@>=
#if !defined(JBMR_UNROLL_PREV_NEXT_LOOP)
int (*tour_neighbour[2])(int);
#endif

@@ The ordering is arbitrary.
@@<One-shot initialize@@>=
#if !defined(JBMR_UNROLL_PREV_NEXT_LOOP)
tour_neighbour[0]=tour_prev;
tour_neighbour[1]=tour_next;
#endif

@@ 
The JBMR tabu rule is ``never delete an added edge''.  On the first level,
this amounts to |t[4]!=t[2]|, and we check that here.

@@<Update |best_gain| and |e[BL]| if not tabu@@>=
#if BL==0
if ( t[2] != t2ip2 ) {
	@@<Update |best_gain| and |e[BL]|.@@>@@;
}
#endif

@@  This bit of code records the move in the |e| array.

Once we reach here, we know that the proposed move is passes the 1-tree and
tabu tests, and is not known to be infeasible.  So it is an eligible move,
and it gets recorded in |e|.

@@<Update |best_gain| and |e[BL]|.@@>=
{ 
#if JBMR_DECLUSTER_IN_ELIGIBILITY_TEST || JBMR_DECLUSTER_IN_GREEDY
const length_t cluster_dist=decluster_d(t[1],t2ip2);
@@<Verbose: cluster distance@@>@@;
#endif

#if !SPLIT_GAIN_VAR
	cum_2 = cum_1 + cost(t2ip1,t2ip2);
#else /* |SPLIT_GAIN_VAR| */
	cum_2_pos = cum_1_pos + cost(t2ip1,t2ip2);
	cum_2_neg = cum_1_neg;
#endif /* |SPLIT_GAIN_VAR| */

#if JBMR_DECLUSTER_IN_ELIGIBILITY_TEST 
if ( @@[ CAREFUL_OP(cum_2,<,cluster_dist+best_gain) @@] ) {
	@@<Verbose: declustering rejects candidate pair@@>@@;
} else 
#endif

{
@@<Update |best_gain| and set scheme@@>@@;
e[BL][enbl].t2ip1 = t2ip1;
e[BL][enbl].t2ip2 = t2ip2;

#if !SPLIT_GAIN_VAR
	e[BL][enbl].gain_for_comparison = e[BL][enbl].gain = cum_2;
#else
	e[BL][enbl].gain_for_comparison = cum_2_pos-cum_2_neg;
	e[BL][enbl].gain_pos = cum_2_pos;
	e[BL][enbl].gain_neg = cum_2_neg;
#endif

#if JBMR_DECLUSTER_IN_GREEDY
#	if BL<3
		e[BL][enbl].gain_for_comparison -= cluster_dist;
#	else
		e[BL][enbl].cluster_dist = cluster_dist;
#	endif
#endif

@@<Verbose: output candidate pair@@>@@;
enbl++;
}
}

@@ We need the interface to the decluserting  module.
@@<Module headers@@>=
#include "decluster.h"
#include "declevel.h"

@@  This section of code performs two jobs for us:  sets the scheme, and 
perhaps update |best_gain|.

The scheme is determined by checking the ordering of the cities around
the tour.  This is all we need to do, indeed all we {\it can\/} do
at this point to discriminate between the possible
schemes.

Now, candidates for |t[3]| and |t[4]| can complete a legal 2-change
if and only if
|tour_inorder(t[1],t[2],t[4],t[3])| holds
and the move is feasible.    The ordering condition is the first thing this
section checks.

As far as feasibility goes, 
we already know that |t[2]!=t[3]| by the 1-tree condition, and that
|t[1]!=t[2]| and |t[3]!=t[4]| because each are respective tour neighbours.
So we need only check that |t[1]!=t[4]| holds.

@@<Update |best_gain| and set scheme@@>=
#if BL==0
	if ( tour_inorder(t[1],t[2],t2ip2,t2ip1) ) {
		e[BL][enbl].scheme_id = 4;
		if ( t[1] != t[4] ) {
			@@<Set |best_gain| if this move is better@@>@@;
		}
	} else {
		e[BL][enbl].scheme_id = 0;	/* Record for deeper levels. */
	}
#endif



@@ Here's where we finally (maybe) set |best_gain| and associated variables.

We need to compute the cost of closing up the Hamiltionian path to make
a Hamiltonian tour. There is only one way to do this: add in the phantom
edge from |t2ip2| to |t[1]|.

We've separated this code out because we will use it again and again.

@@<Set |best_gain| if this move is better@@>=
{const length_t cost_phantom = cost(t[1],t2ip2);
#if !SPLIT_GAIN_VAR 
   const length_t cum_exit_now = cum_2 - cost_phantom;
#endif

   if (
#if LENGTH_TYPE_IS_EXACT
	   cum_exit_now > best_gain
#elif SPLIT_GAIN_VAR
	   cum_2_pos  > best_gain_with_slop + cum_2_neg + cost_phantom
#else
	   cum_exit_now > best_gain_with_slop
#endif
      )
{

#if SPLIT_GAIN_VAR
	best_gain = cum_2_pos - cum_2_neg - cost_phantom;
#else
	best_gain = cum_exit_now;
#endif
#if !LENGTH_TYPE_IS_EXACT
	best_gain_with_slop = best_gain + instance_epsilon;
#endif

	best_two_i = two_i;
	best_exit_a = t2ip1;
	best_exit_b = t2ip2;
	best_scheme_id = e[BL][enbl].scheme_id;
	@@<Verbose: output new |best_gain|@@>@@;
}
}

@@ Now that we've constructed the lookahead array, we need to 
sort it in non-decreasing order of the |gain| entry.

Now, if only the rest of the code were this easy.  :)

We use the sorting routine pointed to by |sort|; it must have
the same signature as the |qsort| standard library function.  
Module \module{LK} sets the |sort| pointer.

@@<Sort |e[BL]|@@>=
sort(e[BL],(size_t)en[BL],sizeof(eligible_t),cmp_eligible);

@@ The comparison function returns an integer less than, equal to, or greater
than 0, if the gain of the
first input is respectively {\it greater\/} than, equal to or {\it less\/}
than the gain
of the second input.

Sometimes we want to make the comparision function a little more 
stringent, for example to ensuring repeatability in case of a randomized
sorting function.
We use a compile time constant |QSORT_DETERMINATE| to force 
the Quicksort method to be a stable sort by
breaking all ties between distinct entries.

@@<Module subroutines@@>=
static int
cmp_eligible(const void *a, const void *b) 
{
	length_t diff =   ((const eligible_t *)a)->gain_for_comparison
					- ((const eligible_t *)b)->gain_for_comparison;
	return diff > 0 ? -1 : (diff < 0 ? 1 : 

#if defined(QSORT_DETERMINATE)
			(int)(((eligible_t *)a)-((eligible_t *)b))
#else
											0 
#endif
											);
}

@@ We've now completed the construction of the eligible move list 
at the first level.
We're ready to implement backtracking.

We use specially named sections for each level of backtracking for
two reasons.  First, the code really looks different at each level,
so we may as well call it by a different name.
Second, 
we will be nesting all the code for the deeper search
within this code.  However, CWEB doesn't allow cyclic code webs.

Of course, I wouldn't have to nest the code if I allowed myself either
luxury of recursion or |goto|s.  I don't use recursion because I don't want
to pass all that local state around, nor pass it through an indirect reference
because that costs too much; I haven't made the local state
global because I want to port this routine to a multi-threaded environment.
I don't use |goto|s because they are {\sl considered harmful} INSERT
REFERENCE, though
not fatal INSERT REFERENCE.

@@ Here's the backtracking code at the first level.

The interesting bit here is the delay of implementing the 2-change until after
all its possible successors have been examined.


At all the levels below this one, there is an early exit mechanism.
Specifically,
if we find an improving sequence of moves, we keep following that path
for as long as possible.  Once we hit the end of this path in the search,
we implement the best improvement that we've found, and terminate the
search.  The mechanism for the early exit is the presence of the
|more_backtracking| variable in the test of our loop. 

I'll defer the description of how to unroll changes until later, because
I haven't even shown you how to implement those changes in the first place!

% Now, an interesting thing happens with the eligible move list.  It may be
% the case that early on, |best_gain| is rather small, so some poor opening
% moves get placed on list.  Later, however, |best_gain| may be improved, and
% therefore becomes a more selective filter for membership on the eligible
% moves list.
% 
% Stop the presses.  I don't care about this because the |best_gain| move
% is moved up to the start of the list.  When we process that best_gain
% move, we perform an early exit from the loop and therefore never process
% a succeeding eligible move.  So we don't need a second |best_gain|
% filter inside this loop.
% 
% 

@@<Backtrack at level 0@@>=
for (ec[0] = 0; more_backtracking && ec[0] < en[0] ; ec[0]++ ) {
	eligible_t *this_move = &e[0][ec[0]];
	t[3] = this_move->t2ip1;
	t[4] = this_move->t2ip2;
#if !SPLIT_GAIN_VAR
	cum_gain = this_move->gain;
#else
	cum_gain_pos = this_move->gain_pos;
	cum_gain_neg = this_move->gain_neg;
#endif
	two_i = 4;
	@@<Verbose: update |probe_depth|@@>@@;
#define BL 1
{
#if JBMR_DECLUSTER_IN_ELIGIBILITY_TEST
	const length_t cluster_dist=this_move->cluster_dist;
#else
	const length_t cluster_dist=0;
#endif
	@@<Update |best_gain| and compose a list of eligible moves@@>@@;
}
	@@<Sort |e[BL]|@@>@@;
#undef BL
	@@<Backtrack at level 1@@>@@;
	@@<If necessary, implement an improving 2-change@@>@@;
}

@@ Scheme 4 is a 2-change.  To implement such a change, we must first
unroll any
previous changes.
Then we fix up the end of the |t| array, implement the changes, and mark
the involved cities as dirty.

@@<If necessary, implement an improving 2-change@@>=
if ( best_scheme_id == 4 ) {
	@@<Unroll all the changes@@>@@;
	t[3] = best_exit_a; t[4] = best_exit_b;
	scheme_id = 4;
	@@<Implement |scheme_id|@@>@@;
	@@<Mark changed cities as dirty@@>@@;
	@@<Verbose: report improving 2-change@@>@@;
	more_backtracking = 0; 
}

@@ The cities which have had their edges changed by a tour improvement
should be marked dirty.


@@<Mark changed cities as dirty@@>=
{ int i;
	for ( i=1; i<=best_two_i ; i++ ) {
		mark_dirty(t[i]);
	}
	mark_dirty(best_exit_a);
	mark_dirty(best_exit_b);
}

@@ My implementation of Iterated Lin-Kernighan (see below) requires 
that we keep list of differences be kept between the end-tour of the previous 
iteration of LK and the end-tour of the current iteration.
The differences are just the sequences of improving $\lambda$-changes.

Each $\lambda$-change is encoded as the values of
|t[1]| through |t[best_two_i]| followed by |best_exit_a|, |best_exit_b|,
|scheme_id|, and finally the value |best_two_i+3|.
Now, the length goes {\it after\/} the array because we will be using
the log in reverse.

Of course, if there is nothing to revert to, then we shouldn't record 
the |t| array.  That is, only record the diffs when |iteration > 0|.


@@^Iterated Lin-Kernighan@@>

@@d write_log(a) (change_log[change_log_next++] = a)

@@<Mark changed cities as dirty@@>=
if ( iteration > 0 ) {
const int more_log = 4+best_two_i;
@@<Make sure |change_log| has space for |more_log| more integers@@>@@;
{ int j;
	for ( j=1;j<=best_two_i; j++) {
		write_log(t[j]);
	}
}
write_log(best_exit_a);
write_log(best_exit_b);
write_log(scheme_id);
write_log(3+best_two_i);
}


@@
@@<Make sure |change_log| has space for |more_log| more integers@@>=
if ( more_log >= change_log_max_alloc ) {
	do {
		change_log_max_alloc *= 2;	
	} while ( more_log >= change_log_max_alloc );
	change_log = (int *)mem_realloc(change_log,sizeof(int)*change_log_max_alloc);
}

@@ Initially |change_log| is given 10000 entries.

@@<Allocate |jbmr_run| sets and arrays@@>=
change_log_max_alloc=10000;
change_log = new_arr_of(int,change_log_max_alloc);

@@ We also need to clean it up.
@@<Deallocate |jbmr_run| sets and arrays@@>=
free_mem(change_log);


@@ We need to declare |change_log|, |change_log_next|, and
|change_log_max_alloc|.

@@<|jbmr_run| variables@@>=
int *change_log=NULL, change_log_max_alloc, change_log_next=0;


@@*Searching at level 1.  
Now we are ready to tackle the second level: picking |t[5]| and |t[6]|.

It would be dumb to allow |t[3]==t[5]|.  Why?  Because then |(t[4],t[5])|
would be just adding the edge |(t[3],t[4])| that we just removed!  
So we eliminate
this possibility at the outset.  

This kind of condition will always apply
from now on, \ie, at all deeper levels of the search.
Note that we didn't have this wrinkle to contend with at
the first backtracking level because requiring that |t[3]!=t[1]| holds 
is already covered
by the 1-tree condition.  Yet, the 1-tree condition doesn't eliminate this
check from this and lower levels because we may have a lot of 
gain credits already
``in the bank''.

From this point on, the feasibility conditions will be much more complicated. 
To simplify matters, we accumulate all the orientation knowledge we can right
at the start.  We do this so we don't ask any ``stupid'' questions later,
\ie, we never ask the same question twice. 

%(An algorithm that never asks stupid questions is called {\sl parsimonious}.
%This concept was invented by INSERT REFERENCE, and is discussed by Knuth
%in section 15 of his short book {\sl Axioms and Hulls}.  It's a nice idea,
%and I'm applying it here for the sake of efficiency, and perhaps efficacy.  
%I'm hoping that keeping 
%the interaction with the abstract tour data type to a minimum will both
%speed things up, and as a long shot, improve the chances that we'll have 
%less contention once this program is ported to a parallel setting.)

@@<Fill |e[BL][enbl]| for valid |t2ip2|'s and maybe update |best_gain|@@>=
#if BL==1
if ( t2ip1 != t[3] ) {
	switch( e[0][ec[0]].scheme_id ) {
	case 0: base_scheme[5] = tour_inorder(t[1],t[2],t2ip1,t[3]) ? 0 : 2; break;
	case 4: base_scheme[5] = tour_inorder(t[1],t[2],t2ip1,t[4]) ? 5 : 8; break;
	default: errorif(1,"Non exhaustive switch: %d",e[0][ec[0]].scheme_id);
	}
	@@<Verbose: show |base_scheme[5]|@@>@@;
	@@<Try both neighbours of |t2ip1|@@>@@;
}
#endif


@@ Here we must check the tabu condition: that |(t[5],t[6])| hasn't previously
been added.
That is, the move is tabu if
|(t[5] == t[4] && t[6] == t[5]) || (t[5] == t[5] && t[6] == t[4])
||(t[5] == t[2] && t[6] == t[3]) || (t[5] == t[3] && t[6] == t[2])|.
However, note that |t[5]==t[5]| is redundant.  Furthermore,
the test |(t[5] == t[4] && t[6] == t[5])| always fails because 
|t[5]| is always chosen to be different from |t[4]|; we want to add the
edge |(t[5],t[4])|, and hence |t[5]| appeared on the nearest neigbours list
of |t[4]|.
So we can skip that disjunct altogther.
The final tabu condition becomes:
 | (t[6] == t[4]) ||(t[5] == t[2] && t[6] == t[3]) || (t[5] == t[3] && 
t[6] == t[2])|.

%Here's a question about C compilers. I've stated the tabu condition in
%the positive sense.  That is, disallow conditions encapsulated in the
%formula $F$.  Then I use it as |!F|.  Now, C uses short-circuiting semantics
%for its logical boolean operators |||| and |&&|.  That means that the operands
%are evaluated left to right, and as soon as the final value is known, then
%evaluation terminates.  For example, this allows 
%the following test to always proceed
%without a divide by zero error:
%|x==0 || y==4/x|.
%Now, is the C compiler forced (say, by the ANSI standard) to 
%push the negation down so that the short-circuiting
%semantics of the embedded operators are always exposed?   I think so$\ldots$
%See sections 7.5.4 and 7.7 in Harbison and Steele's 
%\book{C: A Reference Manual}.

Once we have eliminated tabu moves, we start refining our knowledge of the
scheme.  This knowledge is used later on.

The legal values of |base_scheme[5]| upon entry are 0, 2, 5, and 8.

A base scheme of 0 at this point ends up either as scheme 0 or as scheme 1,
both of which are 3-changes.  Schemes 7 and 8, both of which are recognized
at this stage, are also 3-changes.
Before we commit to adding these to the list of
eligible moves, we must pass them through both a legaility and
the feasibility filter.  To save on variables, I only use a single
variable |is_illegal| to catch both cases.

For 4-changes, we also perform the legality and feasibility checks which
involve only cities |t[1]| through |t[6]|.

%Now, the |switch| statement looks funny because all the |tour_inorder| calls
%are the same.  But each branch of the switch performs different sanity checks,
%and records the results in |is_illegal|.  These aren't tabu restrictions,
%but just ensure that we won't try something illegal later on.

@@<Update |best_gain| and |e[BL]| if not tabu@@>=
#if BL==1
if ( !( /* Never delete an added edge. */
	(t2ip2 == t[4]) 
	||(t2ip1 == t[2] && t2ip2 == t[3]) 
	||(t2ip1 == t[3] && t2ip2 == t[2]) )) {
	int is_illegal = 0;
	switch( base_scheme[5] ) {
	case 0: /* 1234.  We know edge |{3,4}| is not the same as |{1,2}|
			because |1234| and |3!=1| by the 1-tree condition. */
		if ( tour_inorder(t[1],t[2],t2ip2,t2ip1) ) {	/* |1265| */
			base_scheme[6] = 0;	/* Case 1.1.1 */
			/* Edge |{6,5}| is not edge |{3,4}| because 1234 and 1253 and
			1265.  It is not edge |{1,2}| because |6!=5| and 1253 and 1234,
			so edge |{3,4}| intervenes between 5 and 1.  But feasibility
			check needs to be done.  */
			is_illegal = t[2] == t2ip1 || t[1] == t2ip2;
		} else {
			base_scheme[6] = 1;	/* Case 1.1.2 */
			/* |{5,6}!={1,2}| because |!1265| ensures that |5!=1| and |6!=2|,
			and edge |{3,4}| intervenes between 6 and 1.
			|{5,6}!={3,4}| because 1234 and |!1265|, so 1234 and 1256, and
			|5!=3| by the stupid check. However, 
			feasibility needs to be checked. */
			is_illegal = t[2] == t2ip2 || t[1] == t2ip1 || t[4] == t2ip2 
				|| t[1] == t2ip2;
		}
		break;
	case 2: 
		base_scheme[6] = 2;	/* Case 1.2 */
		is_illegal = tour_inorder(t[3],t[4],t2ip1,t2ip2); 
		/* Suppose it isn't illegal by the above test.  We want to
			make sure that |{6,5}!={3,4}| and |{6,5}!={1,2}| hold.
				We know |(1,2)|, |(3,4)|, and |(6,5)| are all oriented
			in the same way.  So |(6,5)!=(3,4)| because |5!=4| by construction.
			Also, |(6,5) != (1,2)| because |5!=2| since |!1253| is known.
			So legality holds as far as we can tell, without us doing any
				more work. */
		break;
	case 5: /* We know |!1234&&1254| */
		if ( tour_inorder(t[1],t[2],t2ip2,t2ip1) ) { /* 1265 */
			base_scheme[6] = 5;	/* Case 2.1.1 */
			/* Schemes 9 through 12 are 4-changes, so the
				checks involving cities 7 and 8 are deferred.  However
				we must disallow |{6,5}=={1,2}| and |{6,5}!={4,3}|.
				Let's do the second one first: |{6,5}!={4,3}| follows
				from |!1234| and |1254| and |1265| since 6 is nested before
				5 which is before 6.
				Now |{6,5}!={1,2}| follows because first, |{3,4}| intervenes
				between 5 and 1, so |5!=1|, and second, |6!=1| because
				1265 and |{3,4}| intervenes between 1 and 5, so it must
				also intervene between 1 and 6.  So legality---as far
				as we can tell---follows. */
		} else { /* |!1265| */
			base_scheme[6] = 7; /* Case 2.1.2 */
			/* Legality:  |{5,6}!={4,3}| because |!1234| implies |1243|, 
			and |!1265| implies 1256, but |5!=4| by construction.
			|{5,6}!={1,2}| may occur here, but only if |6==1|; we check that
			here in feasibility.  Feasibility pairs: 14, 16. */
			is_illegal = t2ip2 == t[1] || t[1]==t[4];
		}
		break;
	case 8: /* We know |!1234&&!1254| */
		if ( tour_inorder(t[4],t[3],t2ip2,t2ip1) ) { /* 4365 */
			base_scheme[6] = 8; /* Case 2.2.1 */
			/* Legality: 
			Knowing 4365 tells us that either |(4,3)| and |(6,5)|
			are oriented the same way, or |(6==4)| and |5==3|.
			The second case is not possible because it is eliminated by
			the stupid check; in particular, |{6,5}!={4,3}|.  	
			We must only worry about |{6,5}={1,2}|.  Now, |!1234| implies
			that 1243 and |4!=1| and |(1,2)| is oriented in the same way
			as (4,3), which in turn is oriented in the same way as
			(6,5).  But |!1254| tells us that 5 lies between 3 and 1,
			so 6 must lie between 3 and 5, and therefore 6 cannot be
			2 because 4 intervenes between 3 and 2.  So |{6,5}!={1,2}|
			and legality follows. 
			*/
		} else {	/* |!1234&&!1254&&!4365| */
			base_scheme[6] = 9; /* Case 2.2.2 */
			/* Schemes 9 through 12 are 4-changes, so the
				checks involving cities 7 and 8 are deferred.  However
				we must disallow |{6,5}=={1,2}| and |{6,5}!={4,3}|.
				First, |5!=3| by the stupid check, and |5!=4| by construction,	
				so |{6,5}!={4,3}|.
				Second, |!4365| implies |(5,6)| is oriented as |(4,3)|, which
				itself is oriented as |(1,2)| because |!1234| holds.
				So to ensure legality, as far as we can tell, we must
				enforce |(5,6)!=(1,2)| as a pair.
				*/
			is_illegal = t2ip2 == t[2];
		}
		break;
	default: errorif(1,"Non-exhaustive switch: %d",base_scheme[5]);
	}
	if ( !is_illegal ) {
		@@<Verbose: show |base_scheme[6]|@@>@@;
		@@<Update |best_gain| and |e[BL]|.@@>@@;
	}
}
#endif /* BL==1 */

@@ This section handles only eligible moves for backtracking level 1.  

Its first job is to set |e[BL][enbl].scheme_id|, which should take on the
value in |base_scheme[6]|.

Its second job is to update |best_gain| and associated variables when 
this move
is a legal tour-completing move.  To determine this, we
must check feasibility.  See my notes of May 8, 1996 for the
detailed analysis.  However, one can generate the constraints as follows. 

We need to make sure that every flip, say of the form |tour_flip(a,b,c,d)|,
is legal.

The first criterion is that edges |(a,b)| and |(d,c)| are oriented 
in the same way.
However, we don't need to check that here because the scheme analysis 
has already taken care of this.

The second criterion is that |a!=b|, |c!=d|, |b!=c|, and |d!=a|, which we
check here.

Now, we can eliminate some of these tests by the following observations.
City |2k| is
always distinct from city |2k+1| because the latter is found on the nearest
neighbour list of the former.  Also, |2k+1| is always distinct from |2k+2|
because the latter is a tour neighbour of the former.  We've just proven
that |t[k]!=t[k+1]| for all $k$.  This eliminates a good fraction of the
potential tests.

For completeness, here is a listing, for each scheme, 
of all the pairs that need to be
tested for inequality:
\emphpar{%
Scheme 0: 25,16\hfil\break
Scheme 1: 26,15,46,16\hfil\break
Scheme 2: 13,26,36,28,18\hfil\break
Scheme 3: 36,38,18\hfil\break
Scheme 4: 14\hfil\break
Scheme 5: 14,46,15,48\hfil\break
Scheme 6: 14,58,18\hfil\break
Scheme 7: 14,16\hfil\break
Scheme 8: 52,16\hfil\break
Scheme 9: 58,38,13,28\hfil\break
Scheme 10: 17,15,28,25,18\hfil\break
Scheme 11: 18,36,38\hfil\break
Scheme 12: 58,25,18
}

We have already used the Scheme 4 conditions at backtracking level 0.

As a reminder, upon entering this code, the value of |base_scheme[6]| is
restricted to one of 0, 1, 2, 5, 7, 8, or 9.  
This section of code will only test those schemes that don't involve
cities |t[7]| and |t[8]| (and which aren't scheme 4).  That list is:
schemes 0, 1, 7, and 8.  A simple test is to index into 
|scheme_num_cities| and make sure it is 6.


@@<Update |best_gain| and set scheme@@>=
#if BL==1
if ( scheme_num_cities[e[BL][enbl].scheme_id = base_scheme[6]]==6 ) {
	@@<Set |best_gain| if this move is better@@>@@;
}
#endif

@@ Now we're ready for the backtracking code for level 1.

The interesting aspect this time around is that we may have finished
defining an initial 3-change, in which case we should implement it and
move on to the general case.  Otherwise, we're building an initial 4-change,
and we just move to the next level.

@@<Backtrack at level 1@@>=
for (ec[1] = 0; more_backtracking && ec[1] < en[1] ; ec[1]++ ) {
	eligible_t *this_move = &e[1][ec[1]];
	t[5] = this_move->t2ip1;
	t[6] = this_move->t2ip2;
#if !SPLIT_GAIN_VAR
	cum_gain = this_move->gain;
#else
	cum_gain_pos = this_move->gain_pos;
	cum_gain_neg = this_move->gain_neg;
#endif
	two_i = 6;
	@@<Verbose: update |probe_depth|@@>@@;
	if ( scheme_num_cities[this_move->scheme_id] == 6 ) {
		scheme_id = this_move->scheme_id;
		@@<Implement |scheme_id|@@>@@;
		@@<Perform the greedy search@@>@@;
		@@<If necessary, implement an improving 3-change or clean up@@>@@;
	} else {
#define BL 2
			{
#if JBMR_DECLUSTER_IN_ELIGIBILITY_TEST
			const length_t cluster_dist=this_move->cluster_dist;
#else
			const length_t cluster_dist=0;
#endif
			@@<Update |best_gain| and compose a list of eligible moves@@>@@;
			}
		@@<Sort |e[BL]|@@>@@;
#undef BL
		@@<Backtrack at level 2@@>@@;
	}
}


@@
As with improving 2-changes, we check to see if we must implement an
improving 3-change at this level after a deeper search.  

Note the special
handling of the case where the best 3-change is a prefix of the deeper
search that we're dropping out of.  I do this to reduce the interaction with
the tour abstract data type in the hopes that this will reduce contention
in the parallel setting.

Once a positive tour gain has been discovered, we do exactly one
deep search before implementing the sequence of moves leading to the
best gain discovered so far. This implies that at this point, 
cities |t[1]| through
|t[4]| are common between the best gain sequence and the current changes.
So to ensure that the best sequence is a 
prefix of the latest deep search, we need only check that |best_exit_a| and
|best_exit_b| equal |t[5]| and |t[6]|, respectively.

@@<If necessary, implement an improving 3-change or clean up@@>=
if ( more_backtracking ) {
	if ( best_gain > 0 && scheme_num_cities[best_scheme_id] == 6 ) {
		if ( best_exit_a == t[5] && best_exit_b == t[6] ) {
			@@<Unroll all the generic changes.@@>@@;
		} else {
			@@<Unroll all the changes@@>@@;
			t[5] = best_exit_a; t[6] = best_exit_b;
			scheme_id = best_scheme_id;
			@@<Implement |scheme_id|@@>@@;
		}
		@@<Mark changed cities as dirty@@>@@;
		@@<Verbose: report improving 3-change@@>@@;
		more_backtracking = 0;
	} else {
		@@<Unroll all the changes@@>@@;
	}
}

@@ This code will be used in a couple of places, so it's generalized.
The |scheme| table encodes all the hard work I did to figure out the 
appropriate moves.  So we end up with just a simple loop.

@@<Implement |scheme_id|@@>=
{@@+int i, n=scheme_max[scheme_id], *s = &scheme[scheme_id][0];
@@<Verbose: announce implement scheme@@>@@;
	for (i=0 ; i<n ; i+= 4) {
		tour_flip_arb(t[s[i]],t[s[i+1]],t[s[i+2]],t[s[i+3]]);
	}
}

@@ The generic tour flipping routine |tour_flip(a,b,c,d)| requires that certain
orientation conditions hold, namely 
|a == tour_next(b)| and |d==tour_next(c)|.  This isn't always convenient.
So I've defined the following procedure to allow either that
condition or the condition 
|a == tour_prev(b)| and |d==tour_prev(c)|.

@@<Module subroutines@@>=
static void tour_flip_arb(int a, int b, int c, int d);
static void
tour_flip_arb(int a, int b, int c, int d) {
	@@<Verbose: announce |tour_flip_arb(a,b,c,d)|@@>@@;
	if ( b==d || a==c) return; /* This is a no-op. */
	if ( a == tour_next(b) && d == tour_next(c) ) {
		tour_flip(a,b,c,d);
		@@<Verbose: flip case a@@>@@;
	} else if ( a == tour_prev(b) && d == tour_prev(c) ) {
		tour_flip(b,a,d,c);
		@@<Verbose: flip case b@@>@@;
	} else {
		printf("\nNeighbour conditions not met\n");
		@@<Debug: print the tour@@>@@;
		printf("\t(%d) %d (%d)",tour_prev(a),a,tour_next(a));
		printf("\t(%d) %d (%d)",tour_prev(b),b,tour_next(b));
		printf("\t(%d) %d (%d)",tour_prev(c),c,tour_next(c));
		printf("\t(%d) %d (%d)",tour_prev(d),d,tour_next(d));
		printf("\n");
		errorif(1,"Neighbour conditions not met.");
	}
}

@@*Searching at level 2.
While we're in the groove of taking care of all these special cases, let's
finish up the 4-changes.

The legal 4-changes have an interesting special structure.  
It turns out that there the choice of segment that |t[7]| is allowed
to belong to depends on the first six cities.
The required conditions are as follows:
\emphpar{%
Base scheme 2: |tour_inorder(t[1],t[2],t[7],t[3])|\hfil\break
Base scheme 5: |tour_inorder(t[6],t[5],t[7],t[4])|\hfil\break
Base scheme 9: |tour_inorder(t[1],t[2],t[7],t[5])|
}

However, as usual, the first thing we do is the ``stupid'' check, \ie, make
sure we don't double back on ourselves.

In all cases, |t[8]| may be either neighbour of |t[7]|, subject to 
tabu and 1-tree conditions, of course.

@@<Fill |e[BL][enbl]| for valid |t2ip2|'s and maybe update |best_gain|@@>=
#if BL==2
if ( t2ip1 != t[5] ) {
	int i1, i2, i4;
	switch( base_scheme[7] = e[1][ec[1]].scheme_id ) {
	case 2: i1=1; i2=2; i4=3; break;
	case 5: i1=6, i2=5, i4=4; break;
	case 9: i1=1, i2=2, i4=5; break;
	default: errorif(1,"Got to 4-change in base scheme %d", base_scheme[7]); 
		i1=i2=i4=-1;	/* Satisfy GCC's dataflow warnings. */
		break;
	}
	if ( tour_inorder(t[i1],t[i2],t2ip1,t[i4]) ) {
		@@<Try both neighbours of |t2ip1|@@>@@;
	}
}
#endif


@@ Here we must check the tabu condition: that |(t[7],t[8])| hasn't previously
been added.
That is, the move is tabu if
\emphpar{%
|(t[7] == t[6] && t[8] == t[7]) || (t[7] == t[7] && t[8] == t[6])|\hfil\break
|||(t[7] == t[4] && t[8] == t[5]) || (t[7] == t[5] && t[8] == t[4])|\hfil\break
|||(t[7] == t[2] && t[8] == t[3]) || (t[7] == t[3] && t[8] == t[2])|.}

As before, 
|t[7]==t[7]| is redundant, and
the test |(t[7] == t[6] && t[8] == t[7])| always fails because 
|t[7]| is always chosen to be different from |t[6]|.
So we can skip that disjunct altogther.

The final tabu condition becomes
\emphpar{%
|(t[8] == t[6])|\hfil\break
|||(t[7] == t[4] && t[8] == t[5]) || (t[7] == t[5] && t[8] == t[4])|\hfil\break
|||(t[7] == t[2] && t[8] == t[3]) || (t[7] == t[3] && t[8] == t[2])|.}

Once we have eliminated tabu moves, we start refining our knowledge of the
scheme.  This knowledge is used when we actually implement the specified
4-change.  This is the deepest level of backtracking, so it will also
be the last level of refinement of the scheme.  That is, our scheme
determinations here are final.

If there was a problem involving only cities |t[1]| through |t[6]|, 
then we've already dealt with them earlier.  The only checking done
involves either |t[7]| or |t[8]| or both.

To see that these tests are unambiguous and complete, one has to do 
a bit of work.  That is, not all the details are shown here.  The best
way to derive these constraints is to doodle with small circles with labelled
vertices, and make some deductions.  That's what are in my notes.


But before you go off and do all that tricky and tedious work, you should
know that 
the guiding principle is that |(t[7],t[8])| must never be on of the
previously removed edges.

%Scheme 9 requires |8!=1|, but this is part of the feasibility check, so
%we don't have to waste time here to do it.  We
%make that the first pair to be tested in the feasibility entry for scheme 9.
%
% Actually, this is moot because 8!=1  scheme 9 only occurs when 1287,
% and this is incompatible with (1,2)==(8,7).

@@<Update |best_gain| and |e[BL]| if not tabu@@>=
#if BL==2
if ( !( 
	(t2ip2 == t[6]) 
	||(t2ip1 == t[4] && t2ip2 == t[5]) 
	||(t2ip1 == t[5] && t2ip2 == t[4]) 
	||(t2ip1 == t[2] && t2ip2 == t[3]) 
	||(t2ip1 == t[3] && t2ip2 == t[2]) )) {
	int infeasible_4_change, is_illegal = 0;
	switch( base_scheme[7] ) {
	case 2: 
		if ( tour_inorder(t[1],t[2],t2ip1,t2ip2) ) {
			base_scheme[8] = 2;	/* Case 1.2.1 */
			is_illegal = t2ip2 == t[4] || t2ip2 == t[1];
		} else {
			base_scheme[8] = 3; 
			/* Ok here because we know 1273, and |8!=1| because that would be
				included in the 1278 case, \ie, scheme 2. */
		}
		break;
	case 5: 
		if ( tour_inorder(t[1],t[2],t2ip2,t2ip1) ) {
			base_scheme[8] = 5;
			/* We know |7!=5| by stupid check, and |6574| by construction;
			together, this means |8!=6|.  Now, |1287|, so |8!=3|. */
		} else {
			base_scheme[8] = 6; 
			is_illegal = t2ip2 == t[3];
			/* |6574| by construction, so |7!=2|; together with |!1287&&1265|,
			means |8!=6|.  The only danger lies in |(7,8)==(4,3)|. */
		}
		break;
	case 9:	/* |!1234&&!1254&&!4365| */
		if ( tour_inorder(t[1],t[2],t2ip1,t[4]) ) {	/* |1274| */
			if ( tour_inorder(t[1],t[2],t2ip2,t2ip1) ) { /* |1287| */
				base_scheme[8] = 9;
				/* First, |!1234| implies |4!=1|; together with |1274| and 
					|1287| implies |8!=1|. 
					Second, |!1234| implies |4!=1&&3!=2|; together with
					|1274| and |1287|, this shows |8!=3|.  So both
					possibilities are eliminated. */
			} else {	/* |!1287|, so |1278 && 2!=8 && 8!=7 && 7!=1| */
				base_scheme[8] = 10; 
				is_illegal = t2ip2 == t[3];
				/* |7==4| possible, so need to exclude |8==3|.
				We can tell that |8!=1| because 8 is at most 3, but 
				then edge |(5,6)| intervenes before we get to 1. */
			}
		} else {	/* |!1274| */
				/* Knowing |1275| by construction, and |!1274|, and the
				fact that |1| is shielded from |7| by |6|, and |2| is 
				shielded from |7| by |4|, we can conlude that |7| is 
				restricted to the 3--5 segment.   */
			if ( tour_inorder(t[1],t[2],t2ip1,t2ip2) ) {
				base_scheme[8] = 11;
				is_illegal = t2ip2 == t[6];
				/* Because |7| is restricted to the 3--5 segment, and |1278|,
				|8==6| is the only danger. */
			} else {
				base_scheme[8] = 12;
				is_illegal = t2ip2 == t[4];
				/* Because |7| is restricted to the 3--5 segment, and |1278|,
				|8==4| is the only danger. */
			}
		}
		break;
	default: errorif(1,"Non-exhaustive switch: %d",base_scheme[7]);
	}
	if ( !is_illegal ) {
		@@<Define |infeasible_4_change|@@>@@;
		if ( !infeasible_4_change ) {
			@@<Update |best_gain| and |e[BL]|.@@>@@;
		}
	}
}
#endif

@@ The possible values of |base_scheme[8]| coming into this section
are precisely those that involve cities |t[7]| and |t[8]|, namely 2, 3, 5, 6,
9, 10, 11, and 12.

@@<Define |infeasible_4_change|@@>=
{@@+ int i, *sc, sn;
t[7] = t2ip1;
t[8] = t2ip2;
infeasible_4_change = 0;
sc = &scheme_feas_check[base_scheme[8]][0];
sn = scheme_feas_n[base_scheme[8]];
for ( i=0; i<sn ; i+=2 ) {
	if ( t[sc[i]] == t[sc[i+1]] ) { infeasible_4_change = 1; break; }
}
}

@@ But we need to fill in the tables that the above code uses.  Refer  to
the table listed earlier.  These should always be kept in synch with
the |scheme| array.

@@<Module variables@@>=
static int scheme_feas_check[14][10] = {
{-1},	/* Scheme 0; not used */
{-1},	/* Scheme 1; not used */
{1,3,3,6,2,6,1,8,2,8},	/* Scheme 2 */
{3,8,1,8,3,6},	/* Scheme 3 */
{-1},	/* Scheme 4; not used */
{1,4,4,6,1,5,4,8},	/* Scheme 5 */
{1,4,5,8,1,8},	/* Scheme 6 */
{-1},	/* Scheme 7; not used */
{-1},	/* Scheme 8; not used */
{1,8,3,8,5,8},	/* Scheme 9 */
{1,7,1,5,2,8,2,5,1,8},	/* Scheme 10 */
{1,8,3,6,3,8},	/* Scheme 11 */
{5,8,2,5,1,8},	/* Scheme 12 */
{-1}	/* Scheme 13; not used */
};

static int scheme_feas_n[14] = {0,0,10,6,0,8,6,0,0,6,10,6,6,0};

@@ By the time we get here, {\it every\/} 4-change completes 
the Hamiltonian cycle as if by magic.  Actually, it's really 
by design and hard work.

@@<Update |best_gain| and set scheme@@>=
#if BL==2
	e[BL][enbl].scheme_id = base_scheme[8];
	@@<Set |best_gain| if this move is better@@>@@;
#endif

@@ Now we're ready for the backtracking code for level 2, which is a 
loop over the possible candidates as before.

When we get here, every combination of six cities at the start of the
|t| array, together with |t2ip1| and |t2ip2| forms a legal 4-change.  
However, they haven't yet been implemented, though they have been
checked for 
feasibility.  
So we implement the 4-change, 
and then perform the greedy portion of the search.

@@<Backtrack at level 2@@>=
for (ec[2] = 0; more_backtracking && ec[2] < en[2] ; ec[2]++ ) {
	eligible_t *this_move = &e[2][ec[2]];
	t[7] = this_move->t2ip1;
	t[8] = this_move->t2ip2;
#if !SPLIT_GAIN_VAR
	cum_gain = this_move->gain;
#else
	cum_gain_pos = this_move->gain_pos;
	cum_gain_neg = this_move->gain_neg;
#endif
	two_i = 8;
	@@<Verbose: update |probe_depth|@@>@@;
	scheme_id = this_move->scheme_id;
	@@<Implement |scheme_id|@@>@@;
	@@<Perform the greedy search@@>@@;
	@@<If necessary, implement an improving 4-change or clean up@@>@@;
}

@@
As with improving 2-changes and 3-changes, we  check 
to see if we must implement an
improving 4-change at this level after a deeper search.  

Again we handle the special case of the best changes being a prefix
of the greedy search we just dropped out of.
Analogously, we need examine the values of only |t[7]| and |t[8]| to
check for this special case.

@@<If necessary, implement an improving 4-change or clean up@@>=
if ( more_backtracking ) {
	if ( best_gain > 0 && scheme_num_cities[best_scheme_id] == 8 ) {
		if ( best_exit_a == t[7] && best_exit_b == t[8] ) {
			@@<Unroll all the generic changes.@@>@@;
		} else {
			@@<Unroll all the changes@@>@@;
			t[7] = best_exit_a; t[8] = best_exit_b;
			scheme_id = best_scheme_id;
			@@<Implement |scheme_id|@@>@@;
		}
		@@<Mark changed cities as dirty@@>@@;
		@@<Verbose: report improving 4-change@@>@@;
		more_backtracking = 0;
	} else {
		@@<Unroll all the changes@@>@@;
	}
}

@@*Greedy search.
Here's the inner loop of Lin-Kernighan, but without all that backtracking
baggage.  It repeatedly takes the move that has the best cumulative gain,
all the while updating and recording the best tour gain.

To keep our code and data
separate from the other backtracking levels, we define |BL| to be 3, the
next available number.   The scratch space in |e[BL]| and |en[BL]| is reused
during each iteration.

Once we reach here, the 2/3/4-change has been implemented.
So the
flips performed here are all of a regular form involving only |t[1]|,
|t[2i]|, |t[2i+1]|, and |t[2i+2]|.

@@<Perform the greedy search@@>=
{@@+int go_deeper;
last_special_two_i = two_i;
generic_flips_made = 0; 
@@<Prime the tabu structure@@>@@;
@@<Verbose: announce start of generic search@@>@@;
for ( go_deeper = 1; go_deeper ; ) {
	@@<Possibly limit the depth of the search@@>@@;
	@@<Verbose: update |probe_depth|@@>@@;
	@@<Make sure |t[two_i+2]| is valid@@>@@;
#define BL 3
	{
#if JBMR_DECLUSTER_IN_ELIGIBILITY_TEST
	const length_t cluster_dist=decluster_d(t[1],t[two_i]);
#else
	const length_t cluster_dist=0;
#endif
	@@<Update |best_gain| and compose a list of eligible moves@@>@@;
	}
#undef BL
	if ( en[3] > 0 ) {
		@@<Go deeper@@>@@;
	} else {
		@@<End the generic search@@>@@;
		go_deeper = 0;
	}
}
@@<Empty the tabu structure@@>@@;
}

@@ Some researchers have suggested speeding up the algorithm by
arbitrarily limiting the depth of the search.  I believe this
is unnatural, but I've implemented this hook.  

@@<Possibly limit the depth of the search@@>=
#if defined(JBMR_LIMIT_PROBE_DEPTH)
if ( generic_flips_made >= max_generic_flips ) {
	@@<Verbose: hit the max generic flips@@>@@;
	@@<End the generic search@@>@@;
	go_deeper=0; 
	break;
}
#endif

@@ In several places I'll need to know the boundary between the special
changes required for the initial 2/3/4-change, and the general changes
of the greedy search.  Variable |last_special_two_i| records the position
of this boundary.

We also need to know when generic flips have been made.  
This knowledge is used when
we attempt to unroll them.  It's no additional work 
to {\it count} the number of generic moves, so this is what we do.
This is an interesting statistic in itself.

Variable |generic_flips_made| counts the number of generic flips made.
It is reset to zero on every entry to the generic search, and incremented
from then on.  It is also used to guard the code that unrolls the generic
flips.  However, we might not begin a generic search before we test whether
there is anything to unroll.  So we must initialize it when we declare it.

Each use of variable |last_special_two_i| is either nested 
within the greedy search
or is guarded by a test on variable |generic_flips_made|.  
So strictly speaking,
we don't need to initialize |last_special_two_i|.  
But the data flow analysis of GCC will
complain about this.  To keep it quiet, we initialize it anyway, but to
a ridiculously large number.

@@<|jbmr_run| variables@@>=
int last_special_two_i;
int generic_flips_made;

@@
@@<Per-iteration initialization@@>=
last_special_two_i=INT_MAX;
generic_flips_made=0;




@@  We pick |t[2i+2]| so that it is always possible to complete the
path to a cycle with this move.

@@<Fill |e[BL][enbl]| for valid |t2ip2|'s and maybe update |best_gain|@@>=
#if BL==3
	if ( t[two_i] == tour_prev(t[1]) ) t2ip2 = tour_next(t2ip1);
	else t2ip2 = tour_prev(t2ip1);
	@@<Update |best_gain| and |e[BL]| if not tabu@@>@@;
#endif


@@ This  first implementation 
 uses a loop to check the tabu condition.  This is a linear search 
through the |t| array.  Because we perform this for every pair of cities
appended to |t|, this results in quadratic behaviour overall.
We might consider doing something smarter,
like using a good dictionary implementation.  Now {\it there's\/} an idea!

On average, I expect this search to be small, because the 
number of cities involved in an average $\lambda$-change is something on
the order of 12 to 16.  (Johnson and McGeoch say that the average depth of a
$\lambda$-change is around 3 edges beyond the initial backtracking stages,
which themselves involve anywhere between at most 6 and 8 cities.  However,
Their inputs are mostly Euclidean inputs where the 
points are randomly chosen from a uniform distribution
over the unit square.)
However, both Lin and Kernighan, and JBMR report
initially having up to around a quarter of all the cities involved in 
the early stages.

Ok.  I've gone away and done some measurements.  The following numbers
are for instance \type{brd14051},
using the 20 nearest neighbours as candidates, and counting only those generic
searches which got at least one level deep.  The unit of depth is a single
city in the |t| list.
With an arbitrary insertion starting tour, there were 103627 non-trivial
generic probes,
minimum depth was 6, maximum was 4264, average was 30.0, and a standard 
deviation
of 56.2.  From a random starting tour, the numbers were
102875 non-trivial generic probe sequences, 
minimum 6 depth, maximum 13032 (surprise!), 
average 34.2, and standard deviation of 76.8.

I was surprised by how deep these probes were.
So the quadratic behaviour for large $N$ is actually a Very Bad Thing.   
So I {\it
will} end up using the dictionary after all.  But wait until my prototype
is finished.

On reflection, the big difference is that the average {\it search\/} might go
much deeper than the average committed {\it change}.  That's an important
difference, with important consequences for parallelization.  In particular,
the probing may disturb a much larger portion of the tour data structure 
(whatever that might be) than the changes we commit.

@@ Of course, first we'll check the feasibility.

@@<Update |best_gain| and |e[BL]| if not tabu@@>=
#if BL==3
if ( t2ip2 != t[1] && t2ip2 != t[two_i] ) {	/* Feasibility check. */
	int is_tabu=0;
	@@<Set |is_tabu| appropriately@@>@@;
	if ( !is_tabu ) {
		@@<Update |best_gain| and |e[BL]|.@@>@@;
	}
}
#endif


@@ This time around, the ``scheme'' system doesn't really apply.  
We'll mark that with a scheme number of 13.

@@<Update |best_gain| and set scheme@@>=
#if BL==3
e[BL][enbl].scheme_id = 13;
@@<Set |best_gain| if this move is better@@>@@;
#endif

@@ Now that we've composed a list of possible moves, we implement the one
that has the greatest cumulative gain.  

In all previous cases, we've
presorted the |e[BL]| array.  But we haven't done that here because we just
want to use the best move.  So we begin by doing a linear search for
the best move.  (A simple adversary argument shows that this
is optimal in the number of comparisons, to within one comparison.)

Once we've found our candidate, we implement its change.
@@<Go deeper@@>=
{ int i, best_i=-1; 
#if !SPLIT_GAIN_VAR
	length_t best_len=0;
#else
	length_t best_len_pos=0, best_len_neg=0;
#endif
@@<Verbose: go deeper@@>@@;
	for ( i=0; i<en[3] ; i++ ) {
		if (
#if JBMR_DECLUSTER_IN_GREEDY
			e[3][i].cluster_dist +
#endif
#if !SPLIT_GAIN_VAR
			best_len < e[3][i].gain
#else
			best_len_pos + e[3][i].gain_neg < best_len_neg + e[3][i].gain_pos
#endif
           )
		{
			best_i = i;
#if !SPLIT_GAIN_VAR
			best_len = e[3][i].gain;
#else
			best_len_pos = e[3][i].gain_pos;	
			best_len_neg = e[3][i].gain_neg;	
#endif
		}
	}
	errorif(best_i==-1,"Shouldn't be going deeper.");
#if !SPLIT_GAIN_VAR
	cum_gain = best_len;
#else
	cum_gain_pos = best_len_pos;
	cum_gain_neg = best_len_neg;
#endif
	t[two_i+1] = e[3][best_i].t2ip1;
	t[two_i+2] = e[3][best_i].t2ip2;
	tour_flip_arb(t[1],t[two_i],t[two_i+1],t[two_i+2]);
	@@<Add to the tabu structure@@>@@;
	two_i += 2;
	generic_flips_made++; 
	@@<Verbose: announce generic flip made@@>@@;
}

@@ This code handles the end of the generic search.  There are two cases
to consider.

In the first case, no improvement has been found along any point in the
search.  We should then unroll all the changes.

In the second case, we have found an improvement.  If this improvement
is generic, then we roll back to it.  Otherwise the improvement is an
initial 2/3/4-change, and it is handled after we exit from this generic
section.

@@<End the generic search@@>=
if ( best_gain == 0 ) {
	@@<Unroll all the changes@@>@@;
} else if ( best_scheme_id == 13 ) {
	@@<Revert to the best generic gain@@>@@;
}

@@ If there is an improving move that ended generically, then this
code 
backs up (if necessary) and implements it.

@@<Revert to the best generic gain@@>=
{
	int low_j, best_is_prefix;
	errorif( best_gain <= 0, "Bad best_scheme_id == 13");
	best_is_prefix = t[best_two_i+1] == best_exit_a 
		&& t[best_two_i+2] == best_exit_b;
	low_j = best_two_i + (best_is_prefix ? 2 : 0);
	@@<Unroll all the generic changes down to |low_j|@@>@@;
	if ( !best_is_prefix ) {
		tour_flip_arb(t[1],t[best_two_i],best_exit_a,best_exit_b);
	}
	@@<Mark changed cities as dirty@@>@@;
	@@<Verbose: report improving $\lambda$-change@@>@@;
	more_backtracking = 0;
}

@@ There are a couple of odds and ends left.  The first is unrolling the
generic changes down to |low_j|.   Each unrolling flip has a nice symmetry
with the flip that implemented it.

@@<Unroll all the generic changes down to |low_j|@@>=
{@@+ int j;
	errorif( low_j < last_special_two_i, "Generic broken! caught at unrolling time");
	for ( j=two_i ; j>low_j ; j-=2 ) {
		@@<Verbose: generic rollback at |j|@@>@@;
		tour_flip_arb(t[1],t[j],t[j-1],t[j-2]);
	}
	generic_flips_made = (low_j - last_special_two_i) / 2;
	@@<Verbose: announce generic flips remain after rollback@@>@@;
}

@@ If generic changes have been made, then unrolling them 
just applies the previous section 
with |low_j == last_special_two_i|.  

@@<Unroll all the generic changes.@@>=
if ( generic_flips_made ) {
	int low_j = last_special_two_i;
	@@<Unroll all the generic changes down to |low_j|@@>@@;
}

@@ Unrolling all the changes is just unrolling the generic changes followed
by unrolling the scheme changes.

@@<Unroll all the changes@@>=
@@<Unroll all the generic changes.@@>@@;
@@<Unroll the scheme changes@@>@@;

@@ The last piece is just unrolling the initial 2/3/4-change.  
We must use the |scheme[scheme_id]| array from right to left.  It's the
shoes and socks principle from group theory.

We have unrolling to do ony when a scheme has been implemented, \ie, 
when |scheme_id > -1|.  We must remember to mark these changes as undone,
by resetting |scheme_id| to |-1|.

@@<Unroll the scheme changes@@>=
if ( scheme_id >= 0 ) {
	int j, *s = scheme[scheme_id];
	@@<Verbose: unroll scheme |scheme_id|@@>@@;
	for ( j=scheme_max[scheme_id]-4;j>=0;j-=4) {
		tour_flip_arb(t[s[j]],t[s[j+3]],t[s[j+2]],t[s[j+1]]);
	}
	scheme_id = -1;
	@@<Verbose: report failure@@>@@;
}

@@*Tabu rules.
In order to prevent the search from endlessly cycling, Lin and Kernighan
defined two tabu rules regarding edges:
\centrepar{Never delete an added edge.}
and
\centrepar{Never add a deleted edge.}
In fact, these rules guarantee that the generic portion of the search
will be at  most $n$ levels deep.

JBMR keep only the first condition, so I call it the JBMR tabu rule.
Using only this rule, the search is still at most only $n$ levels deep.


Meanwhile, in {\sl The complexity of the Lin-Kernighan heuristic for the
traveling salesman problem}, SIAM Journal on Computing, {\bf 21} 3, June 1992,
460--465, 
Papadimitriou proved that a 
simplification of the Lin-Kernighan
algorithm that used only the second tabu rule
solves a problem that is PLS-complete.  (For an introduction to 
PLS-completeness,
see the paper {\sl How easy is local search?} by Johnson,
Papadimitriou, and Yannakakis, JCSS, {\bf 37}, 1988, 79--100.)
Until at least November 1995 (source: Johnson and McGeoch, November 20, 1995 
INSERT BETTER REFERENCE),
there had been no reported experience using
this tabu rule only.    
I have come to call the second tabu rule the Papadimitriou tabu rule.  

Note that using the second tabu rule 
only allows us to go much deeper: up to $n(n-1)/2$
levels instead of only $n$.  But the price is PLS-completeness.  Is the price
worth paying?  Nobody knows---yet.  On the one hand, it appears to be
much less restrictive because one is allowed to go much deeper.  On the
other hand, the rule may be much faster to check.  Why?  Well, lookahead
forces us to check the JBMR rule for every candidate |t2ip2|  for each
choice of |t2ip1|, typically 10 checks or more per choice of |t2ip1|.  
Meanwhile,
the Papadimitriou rule may be checked as soon as a candidate for |t2ip1| is 
known, resulting in one edge to be checked per choice of |t2ip1|.  
%We'll see.

@@ When considering data structures for this problem, it might help to  know
the context in which it will be used.  

In this  program, the usage pattern is as follows:\br
\def\q{\hbox{}\hskip3em\relax}
\noindent create table\br
repeat $\{$\br
\q repeat $\{$\br
\q\q repeat find\br
\q\q insert\br
\q$\}$\br
\q make empty\br
$\}$

Also, I expect that most of the find operations will result in a miss.
	

@@  We can check the tabu condition in time that is linear in the
number of moves made so far.  There is no additional space overhead,
and the multiplicative constant is small.

The JBMR rule is ``Never delete an added edge''.  Added edges are of the
form $(t_{2k},t_{2k+1})$.

Papadimitriou's tabu rule is ``Never add a deleted edge''.   
How do I implement
that?  Hmmm.  I need to do that one step {\it earlier}, \ie\ as soon as 
|t2ip1| is chosen.

@@<Set |is_tabu| appropriately@@>=
#if defined(TABU_LINEAR)
#if defined(TABU_JBMR)
{
int i;
for ( i=2, is_tabu = 0; i < two_i ; i+= 2 ) {
	if ( (t2ip1 == t[i] && t2ip2 == t[i+1]) 
		|| (t2ip1 == t[i+1] && t2ip2 == t[i]) ) {
		is_tabu = 1;
		break;
	}
}
}
#elif defined(TABU_Papadimitriou)
{ errorif(1,"TABU_Papadimitriou is not implemented yet"); }
#else
#error "Need one of TABU_JBMR or TABU_Papadimitriou defined"
#endif
#endif /* |TABU_LINEAR| */

@@ The linear check needs no setup or teardown.
@@<Prime the tabu structure@@>=

@@
@@<Add to the tabu structure@@>=

@@
@@<Empty the tabu structure@@>=

@@ Another alternative for the tabu structure is a dictionary.  In this
case, we will be using a splay tree.  Splay trees have nice working
set properties (see Sleator and Tarjan), and worst case amortized
times of $O(\log n)$ per operation.  Besides, the code's already written.

We might consider implementing
a hash table instead.  On average, hash tables are supposedly faster.
But they are an implementation headache because we don't know the
size of the dictionary in advance, and so we would have to grow the hash
table as it filled up, reallocating space, and rehashing everything.  Ugh.

I will consider using the dictionaries supplied with LEDA, the Library of
Efficient Data Structures and Algorithms,
{\tt http://www.mpi-sb.mpg.de/LEDA/leda.html}.  But then I 
must use C++, and I don't know the allocation properties of LEDA.
In particular, I'm worried about its (lack of?) concurrency control.

@@ The dictionary must be created first.  We will 
reuse the same dictionary for every generic probe.

@@<|jbmr_run| variables@@>=
#if defined(TABU_SPLAY)
dict_t *tabu = dict_create(cmp_pair,NULL);
#endif

@@ The comparison function implements lexicographic ordering.

The tricky part is that 
 edge $(p,q)$ must be considered the same as edge $(q,p)$.  We enforce
this by making the first coordinate at least as large as the second coordinate.

For correctness, I should not break ties by doing a pointer comparison as
I have optionally done in other places.  That would break this code because
I want to be able to find an edge in the dictionary without knowing where
it is stored.  After all, that's the whole point of the splay tabu structure.

@@<Module subroutines@@>=
#if defined(TABU_SPLAY)
static int cmp_pair(const void *a, const void *b);
static int 
cmp_pair(const void *a, const void *b) {
	int a1 =  *((const int *)a), a2 = *(((const int *)a)+1);
	int b1 =  *((const int *)b), b2 = *(((const int *)b)+1);
	if ( a1 < a2 ) { int t = a1; a1 = a2; a2 = t; }
	if ( b1 < b2 ) { int t = b1; b1 = b2; b2 = t; }
    return a1==b1 ? a2-b2 : a1-b1;
}
#endif


@@ The proposed edge to be deleted is |(t2ip1,t2ip2)|.  We'll save some
branches in the comparison function if we order this edge appropriately
here.

@@<Set |is_tabu| appropriately@@>=
#if defined(TABU_SPLAY) && defined(TABU_JBMR)
{ int edge[2];
	if ( t2ip1 < t2ip2 ) {edge[0] = t2ip2; edge[1] = t2ip1;}
	else {edge[0] = t2ip1; edge[1] = t2ip2;}
	is_tabu = dict_find(tabu,edge) != NULL;
}
#endif

@@ This section initializes the tabu structure with the edges added in the
backtracking stage, \ie\ the scheme changes.  We only use the |t| array
here and ignore the implementation we actually used to get to this point.
This is faster (because there are fewer added edges in the |t| array
than in the scheme implementation sequence), simpler, and less skewed
toward the particular implementations of schemes that we have chosen.

The added edges are |(t[2],t[3])|, |(t[4],t[5])|, \etc.

@@<Prime the tabu structure@@>=
#if defined(TABU_SPLAY) && defined(TABU_JBMR)
{
	int i;
	for ( i=2; i<two_i ; i+= 2 ) dict_insert(tabu,t+i);
}
#endif

@@
@@<Add to the tabu structure@@>=
#if defined(TABU_SPLAY) && defined(TABU_JBMR)
	dict_insert(tabu,t+two_i);
#endif

@@  Emptying the splay tree is the same job in both the JBMR and Papadimitriou
cases.  We don't want to do anything at the nodes, so we pass |NULL| as the
procedure.

@@<Empty the tabu structure@@>=
#if defined(TABU_SPLAY)
	dict_delete_all(tabu,NULL);
#endif

@@ The only thorn in the side of things is that if we ever move the 
|t| array during reallocation, then we must move each of the pointers in
the tree.   We do this by subtracting the value |old_t| and adding the value
|t| to each dictionary entry payload pointer, but only after
it has been 
cast from |void *| to |int *|.

We use a special dictionary operation for this job, |dict_update_all|.
One of its parameters is a pointer to a procedure to update the 
contents of the dictionary entry in place.  But this updating
procedure must know how to modify the pointer, in this case it must know
the values of |t| and |old_t|, which are local to this |jbmr_run| and should
not be shared with other threads.  But the |\CEE| language does not
allow nested function definitions.  What are we to do?

It has been said that there isn't much in computer science that can't be
solved by another level of indirection.  The solution here is to
pass not only a pointer to the procedure, but a pointer to data that
should be passed to that procedure.  (It's simpler once you read the
code, honest.)  Another way of thinking about this is that we pass
the environment that should be passed to that procedure.  Implementors
of functional
programming languages will recognize this as a thunk with its environment.
Everything old is new again.  The best ideas are stolen, I mean, reused.

So this determines the interface to the |dict_update_all| procedure. 
Heck, I wrote the dictionary module, so I have complete freedom to add
this to its interface.  And yes, I was lazy and only added this procedure
only after I needed here.

@@<|t| has moved from |old_t| to |t|@@>=
#if defined(TABU_SPLAY)
{	int *env[2];	
	env[0] = old_t;
	env[1] = t;
	dict_update_all(tabu,move_t,env);
}
#endif

@@ Here's the procedure that actually does the moving.  Its first parameter
is the environment that it needs; its second parameter is a pointer to
the integer pointer (disguising as a |void| pointer) that it must change.

Now that I've written it, all I can say is, ``Egads!''.  
@@<Module subroutines@@>=
#if defined(TABU_SPLAY)
static void move_t(void *env,void **p);
static void
move_t(void *env,void **p) {
	int *old_t = ((int **)env)[0], *t = ((int **)env)[1];
	*p = (void *)( t + ((int *)(*p) - old_t));
}
#endif


@@  Whenever we make an improvement, we check to see if we've passed
a milestone in terms of percentage above a lower bound.
Of course, this is conditional a upon the user specifying a lower bound
on the command line.  The value of the lower bound is stored in 
|lower_bound_value|, and its name is stored in |lower_bound_name|.

@@<Check milestone@@>=
#if JBMR_MAX_VERBOSE >= 25
if ( lower_bound_name && verbose >= 25 ) {
	double this_time=0;
	if ( incumbent_len <= milestone_value ) this_time=resource_user_tick();
	while ( incumbent_len <= milestone_value && milestone < num_milestones ) {
		printf("Milestone: %4.2f%% above %s after %.2f (+ %.2f) sec\n",
			milestone_percentage[milestone]*100, 
			lower_bound_name,
			this_time,
			this_time==milestone_time ? 0 : this_time-milestone_time );
		milestone_time=this_time;
		milestone++; 
		if ( milestone < num_milestones ) 
			milestone_value = lower_bound_value*(1+milestone_percentage[milestone]);
	}
	fflush(stdout);
}
#endif

@@ 
@@<|jbmr_run| variables@@>=
const double milestone_percentage[] = 
{ .10,
.099, .098, .097, .096, .095, .094, .093, .092, .091, .090,
.089, .088, .087, .086, .085, .084, .083, .082, .081, .080,
.079, .078, .077, .076, .075, .074, .073, .072, .071, .070,
.069, .068, .067, .066, .065, .064, .063, .062, .061, .060,
.059, .058, .057, .056, .055, .054, .053, .052, .051, .050,
.049, .048, .047, .046, .045, .044, .043, .042, .041, .040,
.039, .038, .037, .036, .035, .034, .033, .032, .031, .030,
.029, .028, .027, .026, .025, .024, .023, .022, .021, .020,
.019, .018, .017, .016, .015, .014, .013, .012, .011, .010,
.009, .008, .007, .006, .005, .004, .003, .002, .001, .000 };
int milestone;
length_t milestone_value; 
const int num_milestones=sizeof(milestone_percentage)/sizeof(double);
double milestone_time;

@@
@@<One-shot initialize@@>=
milestone=0;
milestone_value = lower_bound_value*(1+milestone_percentage[milestone]);
milestone_time=0.0;

@@
@@<Module headers@@>=
#include "resource.h"


@@ We show where we started from, percentage-wise.
@@<Show initial milestone@@>=
#if JBMR_MAX_VERBOSE >= 25
if ( lower_bound_name && verbose >= 25 && lower_bound_value > 1e-5 ) {
	printf("Initial milestone: %.1f%% above %s\n",
		100*(incumbent_len-lower_bound_value)/lower_bound_value, lower_bound_name );
	fflush(stdout);
}
#endif

@@ We also show where we end up.
@@<Show final milestone@@>=
#if JBMR_MAX_VERBOSE >= 25
if ( lower_bound_name && verbose >= 25 && lower_bound_value > 1e-5 ) {
	printf("Final milestone: %.2f%% above %s\n",
		100*(incumbent_len-lower_bound_value)/lower_bound_value, lower_bound_name );
	fflush(stdout);
}
#endif


@@*Debugging output.  
This is the debugging output I needed to remove all the bugs  
I removed.  And I sincerely hope that no bugs remain.

To reduce the size of the object code, set |JBMR_MAX_VERBOSE| to a smaller
number.   That compile-time definition controls how much of the debugging
output can be generated.

The \type{-v} or \type{--verbose} command-line options allow the user
to set variable |verbose| and therefore the amount of output generated,
subject to the limits placed by |JBMR_MAX_VERBOSE|.

@@
@@<Verbose: announce improvement by |best_gain|@@>=
#if JBMR_MAX_VERBOSE >= 50
if ( verbose >= 50 ) {
	static double last_time=0.0;
	const double this_time=resource_user_tick();
	printf("=== improve by " length_t_spec " to "length_t_spec,
		length_t_pcast(best_gain),length_t_pcast(incumbent_len));
	printf("  after %.3f (+ %.3f) sec\n", this_time,this_time-last_time);
	last_time=this_time;
	fflush(stdout);
}
#endif


@@
@@<Verbose: report termination of LK phase@@>=
#if JBMR_MAX_VERBOSE >= 20
if ( verbose >= 20 ) {
	const double lk_time = resource_user_tick();
	const double ds_time = resource_user_tick_from(begin_data_structures_mark);
	printf("LK phase ended with incumbent_len == " length_t_spec 
		" after %.3f sec for LK and %.3f sec for ds+LK\n", 
		length_t_pcast(incumbent_len), lk_time, ds_time);
	fflush(stdout);
}
#endif

@@
@@<Verbose: announce start of search at |*dirty|@@>=
#if JBMR_MAX_VERBOSE >= 100
if ( verbose >= 100 ) {
	printf("Search for an improvement starting at city %d\n",*dirty);
	fflush(stdout);
#if defined(JBMR_WATCH_THIS_CITY)
	if ( *dirty ==  JBMR_WATCH_THIS_CITY ) { 
		old_verbose = verbose;
		old_verbose_is_set = 1; 
		verbose = 2000;
	} else if ( old_verbose_is_set ) {
		verbose = old_verbose; 
		old_verbose_is_set = 0;
	}
#endif
}
#endif

@@
@@<Module variables@@>=
#if JBMR_MAX_VERBOSE >= 100 && defined(JBMR_WATCH_THIS_CITY)
static int old_verbose, old_verbose_is_set=0;
#endif


@@
@@<Verbose: announce generic flip made@@>=
#if JBMR_MAX_VERBOSE >= 150
if ( verbose >= 150 ) {
	printf("Generic flips made: %d\n", generic_flips_made);
	fflush(stdout);
}
#endif

@@
@@<Verbose: announce generic flips remain after rollback@@>=
#if JBMR_MAX_VERBOSE >= 150
if ( verbose >= 150 ) {
	printf("Generic flips remain after rollback: %d\n", generic_flips_made);
	fflush(stdout);
}
#endif


@@
@@<Verbose: announce start of generic search@@>=
#if JBMR_MAX_VERBOSE >= 175
if ( verbose >= 175 ) {
	printf("Start generic search\n");
	fflush(stdout);
}
#endif


@@
@@<Verbose: output new |best_gain|@@>=
#if JBMR_MAX_VERBOSE >= 200
if ( verbose >= 200 ) {
	@@<Verbose: indent@@>@@;
	printf("best_gain = "length_t_spec" %d %d s%d\n",
		length_t_pcast(best_gain), best_exit_a, best_exit_b,best_scheme_id);
	fflush(stdout);
}
#endif

@@
@@<Verbose: announce implement scheme@@>=
#if JBMR_MAX_VERBOSE >= 300
if ( verbose >= 300 ) {
	printf("Implement scheme %d\n",scheme_id);
	@@<Verbose: show |t|@@>@@;
	fflush(stdout);
}
#endif

@@
@@<Verbose: unroll scheme |scheme_id|@@>=
#if JBMR_MAX_VERBOSE >= 300
if ( verbose >= 300 ) {
	printf("Unrolling the scheme %d changes\n",scheme_id);
	@@<Verbose: show |t|@@>@@;
	fflush(stdout);
}
#endif

@@  Show |t| and its associated cumulative and tour gains.
@@<Verbose: show |t|@@>=
#if JBMR_MAX_VERBOSE >= 300
if ( verbose >= 300 ) {
	int i;
	length_t c=0, b=0;
	printf("t: ");
	for ( i=1;i<=two_i;i++) {
		if ( i%2 ) { /* is odd */
			if ( i>1 ) c -= cost(t[i],t[i-1]);
		} else { /* is even */
			c += cost(t[i],t[i-1]);
		}
		printf("%d ",t[i]);
	}
	b = c - cost(t[1],t[two_i]);
	printf(length_t_spec" ",length_t_pcast(c));
	printf(length_t_spec"\n",length_t_pcast(b));
	fflush(stdout);
}
#endif



@@
@@<Verbose: announce |tour_flip_arb(a,b,c,d)|@@>=
#if JBMR_MAX_VERBOSE >= 350
if ( verbose >= 350 ) {
	printf("tour_flip_arb(%d,%d,%d,%d)",a,b,c,d);
	fflush(stdout);
}
#endif

@@
@@<Verbose: generic rollback at |j|@@>=
#if JBMR_MAX_VERBOSE >= 350
if ( verbose >= 350 ) {
	printf("Rollback generic flip(t%d t%d t%d t%d)\n",1,j,j-1,j-2);
	fflush(stdout);
}
#endif

@@
@@<Verbose: flip case a@@>=
#if JBMR_MAX_VERBOSE >= 350
if ( verbose >= 350 ) {
	printf(" case a\n");
	fflush(stdout);
}
#endif

@@
@@<Verbose: flip case b@@>=
#if JBMR_MAX_VERBOSE >= 350
if ( verbose >= 350 ) {
	printf(" case b\n");
	fflush(stdout);
}
#endif

@@ Here, |t[two_i]| is the last thing added.
@@<Verbose: show current position@@>=
#if JBMR_MAX_VERBOSE >= 400
if ( verbose >= 400 ) {
	@@<Verbose: indent@@>@@;
	printf("%d %d "length_t_spec" "length_t_spec" s%d\n", t[two_i-1], t[two_i],
#if !SPLIT_GAIN_VAR
		length_t_pcast(cum_gain), 
#else
		length_t_pcast(cum_gain_pos-cum_gain_neg), 
#endif
		length_t_pcast(best_gain), scheme_id );
	fflush(stdout);
}
#endif



@@
@@<Module subroutines@@>=
#if JBMR_MAX_VERBOSE >= 300
#if !SPLIT_GAIN_VAR
#define put_city(X) \
if ( verbose >= 300 ) { \
	int i;\
	length_t cg = cum_gain, bg = best_gain; \
	for ( i=0;i<(X);i++) {printf(" ");}\
	printf("t%d == %d p=%d n=%d",(X),t[(X)],tour_prev(t[(X)]),tour_next(t[(X)]));\
	if (X>1) { \
		int c = cost(t[(X)-1],t[X]); \
		printf(" c(t%d,t%d)=%d",(X)-1,(X),c); \
		c = cost(t[(X)],t[1]); \ 
		printf(" c(t%d,t1)=%d",(X),c); \
	} \
	printf("\tcg "length_t_spec" bg "length_t_spec"\n",length_t_pcast(cg),\
		length_t_pcast(bg)); \
	fflush(stdout); \
}
#else
#define put_city(X) \
if ( verbose >= 300 ) { \
	int i;\
	length_t cg = cum_gain_pos-cum_gain_neg, bg = best_gain; \
	for ( i=0;i<(X);i++) {printf(" ");}\
	printf("t%d == %d p=%d n=%d",(X),t[(X)],tour_prev(t[(X)]),tour_next(t[(X)]));\
	if (X>1) { \
		int c = cost(t[(X)-1],t[X]); \
		printf(" c(t%d,t%d)=%d",(X)-1,(X),c); \
		c = cost(t[(X)],t[1]); \ 
		printf(" c(t%d,t1)=%d",(X),c); \
	} \
	printf("\tcg "length_t_spec" bg "length_t_spec"\n",length_t_pcast(cg),\
		length_t_pcast(bg)); \
	fflush(stdout); \
}
	
#endif
#else
#define put_city(X)
#endif

@@
@@<Verbose: output candidate pair@@>=
#if JBMR_MAX_VERBOSE >= 500
if ( verbose >= 500 ) {
	@@<Verbose: indent@@>@@;
#if !SPLIT_GAIN_VAR
	printf("%d: %d %d "length_t_spec" s%d\n",
		enbl,t2ip1,t2ip2,
		length_t_pcast(cum_2),
#else
	printf("%d: %d %d "length_t_spec"-"length_t_spec"="length_t_spec" s%d\n",
		enbl,t2ip1,t2ip2,
		length_t_pcast(cum_2_pos),
		length_t_pcast(cum_2_neg),
		length_t_pcast(cum_2_pos-cum_2_neg),
#endif
		e[BL][enbl].scheme_id);
	fflush(stdout);
}
#endif

@@
@@<Verbose: cluster distance@@>=
#if JBMR_MAX_VERBOSE >= 501 && (JBMR_DECLUSTER_IN_ELIGIBILITY_TEST||JBMR_DECLUSTER_IN_GREEDY)
if ( verbose >= 501 ) {
	@@<Verbose: indent@@>@@;
	printf(" v---- next clust_dist==%f\n", (double)cluster_dist);
}
#endif

@@
@@<Verbose: declustering rejects candidate pair@@>=
#if JBMR_MAX_VERBOSE
num_reject_by_decluster++;
#if JBMR_MAX_VERBOSE >= 500
if ( verbose >= 500 ) {
	@@<Verbose: indent@@>@@;
	printf("%d: %d %d "length_t_spec" s%d rejected (#%d), clust_dist==%f\n",
		enbl,t2ip1,t2ip2,
#if !SPLIT_GAIN_VAR
		length_t_pcast(cum_2),
#else
		length_t_pcast(cum_2_pos-cum_2_neg),
#endif
		e[BL][enbl].scheme_id,
		num_reject_by_decluster,
		(double)cluster_dist);
	fflush(stdout);
}
#endif
#endif

@@
@@<|jbmr_run| variables@@>=
int num_reject_by_decluster;


@@
@@<One-shot initialize@@>=
num_reject_by_decluster=0;

@@
@@<Verbose: show terminating |cum_1|@@>=
#if JBMR_MAX_VERBOSE >= 500
if ( verbose >= 500 ) {
	@@<Verbose: indent@@>@@;
#if !SPLIT_GAIN_VAR
	printf("Terminating |cum_1| "length_t_spec"\n", length_t_pcast(cum_1));
#else
	printf("Terminating |cum_1| "length_t_spec" "
		"(== "length_t_spec" - " length_t_spec")\n",
		length_t_pcast(cum_1_pos-cum_1_neg),
		length_t_pcast(cum_1_pos),
		length_t_pcast(cum_1_neg) );
#endif
	fflush(stdout);
}
#endif

@@ Show the candidate list.
@@<Verbose: go deeper@@>=
#if JBMR_MAX_VERBOSE >= 500
if ( verbose >= 500 ) {
	int i; 
	@@<Verbose: indent@@>@@; printf("go deeper candidates begin\n");
	for ( i=0; i<en[3] ; i++ ) {
#if !SPLIT_GAIN_VAR
		@@<Verbose: indent@@> printf("%d %d "length_t_spec" s%d\n", 
			e[3][i].t2ip1, 
			e[3][i].t2ip2, 
			length_t_pcast(e[3][i].gain),
			e[3][i].scheme_id );
#else
		@@<Verbose: indent@@> printf("%d %d "length_t_spec" (=="length_t_spec"-"
			length_t_spec") s%d\n", 
			e[3][i].t2ip1, 
			e[3][i].t2ip2, 
			length_t_pcast(e[3][i].gain_pos-e[3][i].gain_neg), 
			length_t_pcast(e[3][i].gain_pos), 
			length_t_pcast(e[3][i].gain_neg), 
			e[3][i].scheme_id );
#endif
	}
	@@<Verbose: indent@@>@@; printf("go deeper candidates end\n");
	fflush(stdout);
}
#endif

@@
@@<Verbose: show |base_scheme[5]|@@>=
#if JBMR_MAX_VERBOSE >= 1000
if ( verbose >= 1000 ) {
	@@<Verbose: indent@@>@@; printf("base_scheme5 == %d\n",base_scheme[5]);
	fflush(stdout);
}
#endif

@@
@@<Verbose: show |base_scheme[6]|@@>=
#if JBMR_MAX_VERBOSE >= 1000
if ( verbose >= 1000 ) {
	@@<Verbose: indent@@>@@; printf("base_scheme6 == %d\n",base_scheme[6]);
	fflush(stdout);
}
#endif


@@ This one's only used by other verbose output sections.
@@<Verbose: indent@@>=
#if JBMR_MAX_VERBOSE
{ int i; for (i=0;i<two_i;i++) printf(" "); }
#endif

@@ This is printed as debugging output when something fails.
@@<Debug: print the tour@@>=
{ int i, c,cn;
	printf("Tour: 0");
	for ( i=0, c=0; i<n ; i++ ) {
		errorif( c == 0 && i > 0, "Not a tour");
		cn = tour_next(c);
		printf(" %d",cn);
		c = cn;
		if ( i%20 == 19 ) printf("\n");
	}
	printf("\n");
	fflush(stdout);
	errorif( c != 0, "Not a tour");
}

@@*Tracking probe depths.
@@<Module definitions@@>=
#if JBMR_MAX_VERBOSE||JBMR_REPORT_DEPTHS
#define TRACK_DEPTHS 1
#else
#define TRACK_DEPTHS 0
#endif

@@
@@<Verbose: report improving 2-change@@>=
#if TRACK_DEPTHS
move_depth = 4;
@@<Verbose: report move stats@@>@@;
#endif

@@
@@<Verbose: report improving 3-change@@>=
#if TRACK_DEPTHS
move_depth = 6;
@@<Verbose: report move stats@@>@@;
#endif

@@
@@<Verbose: report improving 4-change@@>=
#if TRACK_DEPTHS
move_depth = 8;
@@<Verbose: report move stats@@>@@;
#endif

@@
@@<Verbose: report improving $\lambda$-change@@>=
#if TRACK_DEPTHS
move_depth = best_two_i+2;
@@<Verbose: report move stats@@>@@;
#endif

@@
@@<Verbose: report failure@@>=
#if TRACK_DEPTHS
move_depth = 0;
@@<Verbose: report move stats@@>@@;
#endif

@@
@@<Verbose: update |probe_depth|@@>=
#if TRACK_DEPTHS
if ( probe_depth < two_i+2 ) (probe_depth = two_i+2);
#endif


@@
@@<Initialize the bookkeeping variables@@>=
#if TRACK_DEPTHS
probe_depth = move_depth = 0;
#endif

@@
@@<|jbmr_run| variables@@>=
#if TRACK_DEPTHS
int probe_depth, move_depth;
#endif

@@
@@<Verbose: report move stats@@>=
#if JBMR_MAX_VERBOSE >= 125
if ( verbose >= 125 ) {
	printf("Move_stats: %d %d %d\n",probes,move_depth,probe_depth);
	fflush(stdout);
	probes++;
}
#endif
#if TRACK_DEPTHS
last_probe_depth=probe_depth;
p_depths[probe_depth]++;
m_depths[move_depth]++;
move_depth = probe_depth = 0;
#endif


@@
@@<|jbmr_run| variables@@>=
#if JBMR_MAX_VERBOSE >= 125
int probes = 0;
#endif

@@
@@d DEPTHS_BOUND (n+20)
@@<Other setup code@@>=
#if TRACK_DEPTHS && defined(TABU_JBMR)
p_depths = new_arr_of(int,DEPTHS_BOUND);
m_depths = new_arr_of(int,DEPTHS_BOUND);
{int i; for (i=0;i<DEPTHS_BOUND;i++) p_depths[i]=m_depths[i]=0;}
#endif


@@
@@<Other cleanup code@@>=
#if TRACK_DEPTHS
free_mem(p_depths);
free_mem(m_depths);
#endif

@@
@@<Module variables@@>=
#if TRACK_DEPTHS
static int *p_depths=NULL, *m_depths=NULL;
#endif

@@
@@<Verbose: report depths@@>=
#if TRACK_DEPTHS
{ int i,j;
	for (i=DEPTHS_BOUND-1;p_depths[i]!=0;i--);
	for (j=0;j<=i;j++) {
		if ( p_depths[j] ) printf("p %d citydeep %d\n",j,p_depths[j]);
	}
	for (i=DEPTHS_BOUND-1;m_depths[i]!=0;i--);
	for (j=0;j<=i;j++) {
		if ( m_depths[j] ) printf("m %d citydeep %d\n",j,m_depths[j]);
	}
}
#endif


@@
@@<Verbose: print statistics@@>=
@@<Verbose: report depths@@>@@;
printf("Statistics: num_reject_by_cum_1 %d\n",num_reject_by_cum_1);
printf("Statistics: num_reject_pre_e_build %d\n",num_reject_pre_e_build);
printf("Statistics: num_reject_by_decluster %d\n",num_reject_by_decluster);


@@
@@<Verbose: new |(t1,t2)|@@>=
#if JBMR_MAX_VERBOSE >= 70
if ( verbose>=70 ) {
printf("(t1,t2)= (%d,%d) cost=%f, d=%f p=%d\n",t[1],t[2],(double)cost(t[1],t[2]),
#if JBMR_DECLUSTER_IN_ELIGIBILITY_TEST || JBMR_DECLUSTER_IN_GREEDY
	(double)decluster_d(t[1],t[2]) 
#else
	(double)-1 /* Don't cause a seg fault. */
#endif
, last_probe_depth);
}
#endif

@@
@@<|jbmr_run| variables@@>=
#if TRACK_DEPTHS
int last_probe_depth=0;
#endif


@@
@@<Verbose: hit the max generic flips@@>=
#if JBMR_MAX_VERBOSE >= 75
if ( verbose>=75 ) {
	printf(" hit max generic flips: %d >= %d\n",
		generic_flips_made,max_generic_flips);
}
#endif

@@*Iterated Lin-Kernighan.
Given a LK-optimal tour, one might try to find a better tour by
perturbing it a little and then running LK on it again.  That's the idea
behind Iterated Lin-Kernighan.

Of course, sometimes the tour we find after the perturbation is worse than
we we started with.  So we need to be able to revert to what we started with.
We use the |change_log|, but in reverse order.

In either case reset the change log index to zero.

@@<Revert to the previous solution if it was better@@>=
if ( iteration > 0 && change_log_next > 0 && previous_incumbent_len < incumbent_len ) {
	@@<Verbose: announce reverting to previous@@>@@;
	while ( change_log_next > 0 ) {
		@@<Undo a $\lambda$-change@@>@@;
		change_log_next -= change_log[change_log_next-1]+1;
	}
	errorif(change_log_next!=0,"Bug!");
	@@<Undo the mutation@@>@@;
	incumbent_len = previous_incumbent_len;
}
change_log_next = 0;

@@ 
@@<|jbmr_run| variables@@>=
length_t previous_incumbent_len=0;

@@ As described earlier, the $lambda$-change is encoded by 
|t[1]| through |t[best_two_i]|, then |best_exit_a|, |best_exit_b|,
|scheme_id|,
and finally |best_two_i+3|.

We need the length value last because we are decoding the $lambda$-change 
it from the end down toward the beginning.  We need the scheme id because
we can't blindly unwind just from the |t| array since some of the
early moves would destroy the tour.

In the following code, |first_pos| is the position where |t[1]| is stored;
|first_generic_pos| is the position of the first city recorded as part
of the generic search, it therefore marks the transition from the 
scheme flips and the generic flips.
In the generic flips, value |j| marks the $c$ city in the 
|tour_flip_arb(a,b,c,d)| move that we're trying to undo (with a 
|tour_flip_arb(a,d,c,b)|.

For undoing the scheme changes, |st| acts just like the |t| array did
when doing the scheme changes, |s| is the scheme change script that we
read backwards, and |si| is the index that runs through the script.

@@<Undo a $\lambda$-change@@>=
{
const int len=change_log[change_log_next-1], 
		revert_scheme_id = change_log[change_log_next-2],
		first_pos=change_log_next-1-len,
		first_generic_pos=first_pos + scheme_num_cities[revert_scheme_id],
		t1=change_log[first_pos], *st=(&change_log[first_pos])-1;
int j,si,*s=&scheme[revert_scheme_id][0];
@@<Verbose: announce undoing a segment of change log@@>@@;
errorif(first_pos<0,"Bug!");
for ( j=change_log_next-4; j >= first_generic_pos ; j-=2 ) { /* Undo generic changes. */
	tour_flip_arb(t1,change_log[j+1],change_log[j],change_log[j-1]);
}
for (si=scheme_max[revert_scheme_id]-4 ; si>=0 ; si-= 4) { /* Undo the scheme changes. */
	tour_flip_arb(st[s[si]],st[s[si+3]],st[s[si+2]],st[s[si+1]]);
}
}

@@ If we are going to go through another round of LK-optimization, we 
store the current tour length in 
|previous_incumbent_len| and then perform a double-bridge perturbation.


@@<If doing another iteration, perturb with a double-bridge@@>=
if ( iteration < iterations-1 ) {
	int edge[4][2];
	previous_incumbent_len = incumbent_len;
	@@<Put four distinct oriented edges into |edge|@@>@@;
	@@<Sort the bridge edges@@>@@;
	@@<Perform the double-bridge mutation using |edge|@@>@@;
}
@@<Verbose: announce new (probably higher) incumbent length@@>@@;



@@
@@<Put four distinct oriented edges into |edge|@@>=
{
int ok, count=0;
do {
	int i,j;
	errorif(count++>1000,"Ummm, random double-bridge search didn't stop after 1000 tries");
	for (i=0,ok=1;ok && i<4;i++) { 
		edge[i][0]=prng_unif_int(random_stream,(long)n);
		edge[i][1]=tour_next(edge[i][0]);
		for (j=0; ok && j<i ;j++) { /* Check for uniqueness. */
			if ( edge[j][0] == edge[i][0] ) ok=0;
		}
	}
} while(!ok);
}

@@
@@<Put four distinct oriented edges into |edge|@@>=
#if JBMR_MAX_VERBOSE >= 60
if ( verbose >= 60 ) {
int i;
printf("Doing double-bridge: ");
for (i=0;i<4;i++) printf("%d(%d,%d) ",i,edge[i][0],edge[i][1]);
printf("\n");
}
#endif

@@ We take |edge[0]| as the reference edge, and sort the other three
manually.  It's bubblesort, folks. (Or rather bubblesort's opposite, rocksort.)

@@d swap_bridge(a,b) {int temp=a[0];a[0]=b[0];b[0]=temp;temp=a[1];a[1]=b[1];b[1]=temp;}
@@d bridge_less(a,b) (tour_inorder(edge[0][0],edge[0][1],a[0],b[0]))


@@<Sort the bridge edges@@>=
{int bottom,rock;
for (bottom=3;bottom>1;bottom--) {
	for(rock=1;rock<bottom;rock++) {
		if ( bridge_less(edge[rock],edge[rock+1]) )  {
			swap_bridge(edge[rock],edge[rock+1]);
		}
	}
}
}


@@ Only three flips are required to perform
the double-bridge move.  A little pencil and paper shows that the following
sequence works.

@@d bridge_t(X) (edge[(X-1)>>1][(X-1)&1])
@@d bridge_move(a,b,c,d) (tour_flip_arb(bridge_t(a),bridge_t(b),bridge_t(c),bridge_t(d)))

@@<Perform the double-bridge mutation using |edge|@@>=
bridge_move(1,2,6,5);
bridge_move(8,7,4,3);
bridge_move(1,5,2,6);

@@ Here's a tricky part.  We also have to record the perturbation and undo
it when reverting to the previous iteration's tour.

@@d mutate(a) (mutation[mutation_next++]=bridge_t(a))

@@<Perform the double-bridge mutation using |edge|@@>=
{ int mutation_next=0;
mutate(1);
mutate(2);
mutate(6);
mutate(5);

mutate(8);
mutate(7);
mutate(4);
mutate(3);

mutate(1);
mutate(5);
mutate(2);
mutate(6);
}

@@ We also need to reflect the mutation in the incumbent length.

There is some redundancy here that I should probably get rid of.


@@<Perform the double-bridge mutation using |edge|@@>=
#if JBMR_MAX_VERBOSE >= 60
#define bc(a,b) (<@@Verbose: print double bridge edge |(a,b)|@@>,
			cost(bridge_t(a),bridge_t(b)))
#else
#define bc(a,b) (cost(bridge_t(a),bridge_t(b)))
#endif

incumbent_len += bc(1,6);
incumbent_len += bc(2,5);
incumbent_len += bc(4,7);
incumbent_len += bc(3,8);
incumbent_len -= bc(1,2);
incumbent_len -= bc(3,4);
incumbent_len -= bc(5,6);
incumbent_len -= bc(7,8);
	
@@
@@<Verbose: print double bridge edge |(a,b)|@@>=
(verbose >= 60 
	? printf("cost(%d,%d)="length_t_spec"\n",
		bridge_t(a),bridge_t(b),length_t_pcast(cost(bridge_t(a),bridge_t(b))))
	: 0
)

@@ We also mark as dirty the cities involved in the mutation.
@@<Perform the double-bridge mutation using |edge|@@>=
{int i;
for (i=1;i<=8;i++)
	mark_dirty(bridge_t(i));
}


@@
@@<|jbmr_run| variables@@>=
int mutation[12];

@@ 
@@<Undo the mutation@@>=
{ int i;
for (i=8;i>=0;i-=4)
	tour_flip_arb(mutation[i],mutation[i+3],mutation[i+2],mutation[i+1]);
}

@@
@@<Verbose: report end of LK step@@>=
#if JBMR_MAX_VERBOSE >= 40
if ( verbose>=40 ) {
	printf("End of LK step %d, incumbent_len = "length_t_spec"\n",
		iteration + 1,
		length_t_pcast(incumbent_len));
}
#endif

@@
@@<Verbose: announce new (probably higher) incumbent length@@>=
#if JBMR_MAX_VERBOSE >= 60
if (verbose>=60){
printf("+++incumbent_len is now "length_t_spec"\n",length_t_pcast(incumbent_len));
}
#endif


@@
@@<Verbose: announce reverting to previous@@>=
#if JBMR_MAX_VERBOSE >= 57
if (verbose>=57) {
printf("Reverting to previous\n");
}
#endif

@@
@@<Verbose: announce undoing a segment of change log@@>=
#if JBMR_MAX_VERBOSE >= 65
if ( verbose >= 65 ) {
printf("  first_pos = %d change_log_next = %d\n",first_pos,change_log_next);
}
#endif

@@*Index.
@


1.191
log
@Change bound value to lower bound value, etc.
@
text
@d1 47
a47 1
@@i copyrt.w
d53 3
d542 1
a542 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.190 1998/05/09 22:51:39 neto Exp neto $";
@


1.190
log
@Give two decimal points in milestones.
@
text
@d7 3
d493 1
a493 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.189 1998/02/27 21:40:36 neto Exp neto $";
d3243 1
a3243 1
|bound_value|, and its name is stored in |bound_name|.
d3247 1
a3247 1
if ( bound_name && verbose >= 25 ) {
d3253 1
a3253 1
			bound_name,
d3259 1
a3259 1
			milestone_value = bound_value*(1+milestone_percentage[milestone]);
d3280 1
a3280 1
length_t milestone_value;
d3287 1
a3287 1
milestone_value = bound_value*(1+milestone_percentage[milestone]);
d3298 1
a3298 1
if ( bound_name && verbose >= 25 && bound_value > 1e-5 ) {
d3300 1
a3300 1
		100*(incumbent_len-bound_value)/bound_value, bound_name );
d3308 1
a3308 1
if ( bound_name && verbose >= 25 && bound_value > 1e-5 ) {
d3310 1
a3310 1
		100*(incumbent_len-bound_value)/bound_value, bound_name );
@


1.189
log
@Lowered verbose level of end of LK step.
Fixed CWEB syntax of printing double bridge edge section.
@
text
@d7 4
d490 1
a490 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.188 1998/02/27 19:43:14 neto Exp neto $";
d3248 1
a3248 1
		printf("Milestone: %4.1f%% above %s after %.2f (+ %.2f) sec\n",
d3306 1
a3306 1
	printf("Final milestone: %.1f%% above %s\n",
@


1.188
log
@Made printing for iterated Lin-Kernighan respect verbose rules.
@
text
@d7 3
d486 1
a486 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.187 1998/02/26 21:37:37 neto Exp neto $";
d4057 1
a4057 2
<Verbose: print double bridge edge |(a,b)|@@>=
#if JBMR_MAX_VERBOSE >= 60
a4062 1
#endif
d4085 4
a4088 3
#if JBMR_MAX_VERBOSE >= 50
if ( verbose>=50 ) {
	printf("End of LK step, incumbent_len = "length_t_spec"\n",
@


1.187
log
@Fixed an old bug!  Wasn't checking tabu condition in generic search for
the new edge to be removed being the new edge being proposed to be added.
Fixed a bug in reverting code: must use tour flip arb instead of just
tour flip.
Fixed a conceptual bug: the change log must also encode the scheme id
used in that improvement, and the reverting must undo those scheme changes.
Removed some debugging output.
Implement the double-bridge mutation in three flips instead of four.

This seems to work.  Now I'll remove some of the debugging output.
@
text
@d7 12
d483 1
a483 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.186 1998/02/21 04:04:36 neto Exp neto $";
d1953 1
a1953 1
@@d write_log(a) (printf(" %d",a),change_log[change_log_next++] = a)
a1958 1
printf("Writing log (change_log_next = %d):",change_log_next);
a1967 1
printf("\n");
d3236 1
d3253 1
d3287 1
d3293 1
d3297 1
d3303 1
d3306 11
a3316 3
@@*Debugging output.  This is turned on only if |JBMR_ALLOW_VERBOSE| is
non-zero,
and |verbose>0|.
d3320 1
a3320 1
#if JBMR_ALLOW_VERBOSE
d3335 1
a3335 1
#if JBMR_ALLOW_VERBOSE
d3348 1
a3348 1
#if JBMR_ALLOW_VERBOSE
d3367 1
a3367 1
#if JBMR_ALLOW_VERBOSE && defined(JBMR_WATCH_THIS_CITY)
d3374 1
a3374 1
#if JBMR_ALLOW_VERBOSE
d3383 1
a3383 1
#if JBMR_ALLOW_VERBOSE
d3393 1
a3393 1
#if JBMR_ALLOW_VERBOSE
d3403 1
a3403 1
#if JBMR_ALLOW_VERBOSE
d3414 1
a3414 1
#if JBMR_ALLOW_VERBOSE
d3424 1
a3424 1
#if JBMR_ALLOW_VERBOSE
d3434 1
a3434 1
#if JBMR_ALLOW_VERBOSE
d3458 1
a3458 1
#if JBMR_ALLOW_VERBOSE
d3467 1
a3467 1
#if JBMR_ALLOW_VERBOSE
d3476 1
a3476 1
#if JBMR_ALLOW_VERBOSE
d3485 1
a3485 1
#if JBMR_ALLOW_VERBOSE
d3494 1
a3494 1
#if JBMR_ALLOW_VERBOSE
d3512 1
a3512 1
#if JBMR_ALLOW_VERBOSE
d3555 1
a3555 1
#if JBMR_ALLOW_VERBOSE
d3576 1
a3576 1
#if JBMR_ALLOW_VERBOSE && (JBMR_DECLUSTER_IN_ELIGIBILITY_TEST||JBMR_DECLUSTER_IN_GREEDY)
d3585 1
a3585 1
#if JBMR_ALLOW_VERBOSE
d3587 1
d3603 1
d3616 1
a3616 1
#if JBMR_ALLOW_VERBOSE
d3634 1
a3634 1
#if JBMR_ALLOW_VERBOSE
d3663 1
a3663 1
#if JBMR_ALLOW_VERBOSE
d3672 1
a3672 1
#if JBMR_ALLOW_VERBOSE
d3680 1
a3680 1
@@ This one's only used by other sections.
d3682 1
a3682 1
#if JBMR_ALLOW_VERBOSE
d3704 1
a3704 1
#if JBMR_ALLOW_VERBOSE||JBMR_REPORT_DEPTHS
d3766 1
a3766 1
#if JBMR_ALLOW_VERBOSE
d3783 1
a3783 1
#if JBMR_ALLOW_VERBOSE
d3836 1
a3836 1
#if JBMR_ALLOW_VERBOSE
d3857 1
a3857 1
#if JBMR_ALLOW_VERBOSE
d3877 1
a3877 1
	printf("Reverting to previous\n");
d3922 1
a3922 2
printf("  first_pos = %d change_log_next = %d\n",first_pos,change_log_next);

a3926 1

d3945 1
a3945 1
printf("+++incumbent_len is now "length_t_spec"\n",length_t_pcast(incumbent_len));
a3955 1
	printf("New bridge\n");
a3962 1
	if ( !ok) printf("Fail\n");
d3968 3
a3970 1
{int i;
d3975 1
a4001 1
@@d mutate(a) (mutation[mutation_next++]=bridge_t(a))
a4003 1
printf("Double-bridge\n");
d4011 2
d4035 4
a4038 3
@@d  bc(a,b) (printf("cost(%d,%d)="length_t_spec"\n",
				bridge_t(a),bridge_t(b),length_t_pcast(cost(bridge_t(a),bridge_t(b))
			 )),
d4040 3
a4043 1
@@<Perform the double-bridge mutation using |edge|@@>=
d4053 9
a4077 1
printf("Undoing the mutation\n");
d4084 1
a4084 1
#if JBMR_ALLOW_VERBOSE
d4091 24
@


1.186
log
@Added most of the support for Iterated Lin-Kernighan.
@
text
@d7 3
d471 1
a471 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.185 1998/01/24 20:47:43 neto Exp neto $";
d638 1
d688 3
d695 1
a695 1
	dict_insert(dirty_set,dirty_work+i);
a1913 1
@@d mark_dirty(CITY) (dict_insert(dirty_set,dirty_work+(CITY)))
d1929 3
a1931 7
Each $\lambda$-change is encoded as the corrsponding |t| array 
(together with the 
corresponding |best_exit_a| and |best_exit_b|) built during the
discovery of that improving sequence.  Each |t| array is encoded 
integers |t[1]| through
|t[best_two_i]| followed by |best_exit_a| and then |best_exit_b|,
and finally by its length.
a1938 1

d1941 1
a1941 1
@@d write_log(a) (change_log[change_log_next++] = a)
d1945 3
a1947 1
@@<Make sure |change_log| has space for |4+best_two_i| more integers@@>@@;
d1955 3
a1957 1
write_log(2+best_two_i);
d1962 2
a1963 2
@@<Make sure |change_log| has space for |4+best_two_i| more integers@@>=
if ( 4+best_two_i >= change_log_max_alloc ) {
d1966 1
a1966 1
	} while ( 4+best_two_i >= change_log_max_alloc );
d1976 5
d2357 1
d2460 1
a2460 1
% (Actually, this is moot because 8!=1  scheme 9 only occurs when 1287,
d2735 9
a2743 2
int last_special_two_i=INT_MAX;
int generic_flips_made=0;
d2806 1
a2806 1
if ( t2ip2 != t[1] ) {	/* Feasibility check. */
d3851 1
d3853 2
a3854 9
		const int len=change_log[change_log_next-1], 
				first_pos=change_log_next-1-len,
				t1=change_log[first_pos];
		int j;
		errorif(first_pos<0,"Bug!");
		for ( j=change_log_next-4; j > first_pos ; j-=2 ) {
			tour_flip(t1,change_log[j+2],change_log[j+1],change_log[j]);
		}
		change_log_next -= len+1;
d3866 41
d3921 1
a3935 1
printf("%d(%d,%d) ",i,edge[i][0],edge[i][1]);
d3944 7
d3971 1
a3971 1
@@ Only four flips are required to perform
d3976 1
a3976 1
@@d bridge_move(a,b,c,d) (tour_flip(bridge_t(a),bridge_t(b),bridge_t(c),bridge_t(d)))
d3980 4
a3983 4
bridge_move(1,2,8,7);
bridge_move(8,2,4,3);
bridge_move(2,4,6,5);
bridge_move(1,7,4,6);
d3992 3
a3996 3

mutate(8);
mutate(2);
d4000 2
a4002 7
mutate(4);
mutate(6);
mutate(5);

mutate(1);
mutate(7);
mutate(4);
d4007 8
d4016 9
a4024 1
incumbent_len += 1/0;
d4028 4
a4031 1
*NULL=0;
d4036 1
a4036 1
int mutation[16];
d4041 3
a4043 2
for (i=12;i>=0;i-=4)
	tour_flip(mutation[i],mutation[i+3],mutation[i+2],mutation[i+1]);
d4054 1
@


1.185
log
@Fixed comment on CAREFUL OP
@
text
@d7 3
d468 1
a468 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.184 1997/11/07 22:35:57 neto Exp neto $";
d475 1
d491 1
d590 1
a590 1
Papadimirtriou's variation (INSERT REFERENCE) 
d616 4
d622 2
a623 1
jbmr_run (void) {
d626 1
a626 1
	int *dirty;
d632 1
d634 7
a640 3
	@@<Show initial milestone@@>@@;
	while ( (dirty = (int *)dict_delete_any(dirty_set,NULL)) != NULL ) {
		@@<Search for an improving sequence starting at |*dirty|@@>@@;
d650 1
a650 1
void jbmr_run(void);
d1205 1
d1212 1
d1918 60
d3817 160
@


1.184
log
@Added verbose message to say when we hit the max depth.
Adjusted verbose values so less is printed at 50.
@
text
@d7 4
d465 1
a465 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.183 1997/11/06 22:47:54 neto Exp neto $";
d1441 2
a1442 2
The |CAREFUL_CMP(LHS,CMP,RHS)| takes out some of the visual clutter.   
It implements numerical comparison |CMP| on left-hand side |LHS| and
@


1.183
log
@I wasn't marking cities dirty for 4-changes or lambda-changes!
Ouch.
@
text
@d7 4
d461 1
a461 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.182 1997/10/18 18:08:13 neto Exp neto $";
d2609 1
d3213 1
a3213 1
if ( verbose >= 50 ) {
d3712 1
a3712 1
if ( verbose>=50 ) {
d3727 10
@


1.182
log
@Convert to new neighbour list protocol.
@
text
@d7 3
d457 1
a457 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.181 1997/10/17 21:50:10 neto Exp neto $";
d1881 3
d1887 1
a1887 1
		dict_insert(dirty_set,dirty_work+t[i]);
d1889 2
d2545 1
d2809 1
@


1.181
log
@Show Start and end milestones, and times for preprocessing as well.
@
text
@d7 3
d437 3
a439 5
It also uses the nearest
neighbour lists which reside in the global variable |nn_list|. 
This variable is an array indexed by city number.  Entry |i| is an array
of |nn_bound| |nn_entry_t| entries, sorted in ascending order of
distance from city |i|.
d454 1
a454 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.180 1997/09/27 18:06:21 neto Exp neto $";
d1328 1
a1328 1
least twice |nn_bound| entries because for each choice of |t[2i+1]|, there
d1332 4
a1335 4
e[0] = new_arr_of(eligible_t,nn_bound*2);
e[1] = new_arr_of(eligible_t,nn_bound*2);
e[2] = new_arr_of(eligible_t,nn_bound*2);
e[3] = new_arr_of(eligible_t,nn_bound*2);
d1345 1
a1345 1
In particular, we may have fewer than |nn_bound| valid entries in the 
d1460 7
d1490 1
a1490 1
int i, t2ip1, t2ip2, enbl; 
d1503 1
a1503 1

d1505 1
a1505 1
		t2ip1 = nn_list[t[two_i]][i];
@


1.180
log
@Fixed RCS log behaviour.
@
text
@d7 3
d453 1
a453 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.179 1997/09/12 21:52:46 neto Exp neto $";
d616 1
d3151 1
a3151 1
@@ We also show where we started from, percentage-wise.
d3159 8
d3191 2
a3192 1
	const double this_time=resource_user_tick();
d3194 2
a3195 1
		" after %.3f sec\n", length_t_pcast(incumbent_len), this_time);
@


1.179
log
@Don't cause a seg fault in my verbose output: I was calling decluster d
even when I hadn't built the data structures!
@
text
@d5 6
a10 1
{\obeylines$Log: jbmr.w,v $
d450 1
a450 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.178 1997/08/15 20:18:25 neto Exp neto $";
@


1.178
log
@Added Index major section.
@
text
@d6 3
d445 1
a445 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.177 1997/07/02 20:48:23 neto Exp neto $";
d3672 6
a3677 1
	(double)decluster_d(t[1],t[2]), last_probe_depth);
@


1.177
log
@Add online printing of length of broken t1 and t2 edge, and some online
depth printing.
@
text
@d6 4
d442 1
a442 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.176 1997/07/02 17:51:20 neto Exp neto $";
d3678 2
@


1.176
log
@Satisfy GCC's dataflow analysis w.r.t. this time.
@
text
@d6 3
d438 1
a438 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.175 1997/06/20 21:48:17 neto Exp neto $";
d1173 1
d3600 1
d3658 16
@


1.175
log
@Better comment about CAREFUL OP
rename num decluster reject to num reject by decluster, for uniformity.
Implement declustering in test surrounding major part of
  Update best gain and compose a list of eligible moves.
@
text
@d6 6
d435 1
a435 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.174 1997/06/20 20:55:28 neto Exp neto $";
d3085 1
a3085 1
	double this_time;
@


1.174
log
@Formatting improvements.
@
text
@d6 3
d429 1
a429 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.173 1997/06/20 20:44:35 neto Exp neto $";
d1237 2
d1243 6
d1250 1
d1413 4
a1416 1
operator.
d1422 1
a1422 1
#define CAREFUL_OP(LHS,OP,RHS) ((LHS##_pos) OP ((RHS##_with_slop)+LHS##_neg))
d1450 2
d1455 1
a1455 1
if ( @@[CAREFUL_OP(cum_gain,>,best_gain)@@] ) {
d1811 6
d1818 1
d2143 8
a2150 1
		@@<Update |best_gain| and compose a list of eligible moves@@>@@;
d2536 6
d2543 1
d3404 2
a3405 2
if ( verbose >= 50 ) {
	num_decluster_reject++;
d3415 1
a3415 1
		num_decluster_reject,
d3423 1
a3423 1
int num_decluster_reject;
d3428 1
a3428 1
num_decluster_reject=0;
d3646 1
a3646 1
printf("Statistics: num_decluster_reject %d\n",num_decluster_reject);
@


1.173
log
@Cleared up some clutter by using a macro for careful comparisons
with best gain.
@
text
@d6 4
d426 1
a426 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.172 1997/06/20 19:34:02 neto Exp neto $";
d830 2
a831 2
To tell the difference between the two situations, we take advantage of the
compile-time constant |SPLIT_GAIN_VAR| defined above.
d1438 1
a1438 1
if ( CAREFUL_OP(cum_gain,>,best_gain) ) {@@;
d1461 1
a1461 1
        if ( CAREFUL_OP(cum_1,<=,best_gain) ) {
d1577 1
a1577 1
if ( CAREFUL_OP(cum_2,<,cluster_dist+best_gain) ) {
d2547 6
a2552 3
All uses of |last_special_two_i| are either nested within the greedy search
or guarded by a test on |generic_flips_made|.  So strictly speaking,
we don't need to initialize it.  But the data flow analysis of GCC will
@


1.172
log
@Fixed typo in section name
Fixed a BIG MISTAKE:  compute cluster distance between t1 and t2ip2
*no* between t2ip1 and t2ip2.  Duh!
@
text
@d6 5
d422 1
a422 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.171 1997/06/20 18:59:04 neto Exp neto $";
d1385 26
d1433 2
a1434 10
en[BL]=ec[BL]=0;
if (
#if LENGTH_TYPE_IS_EXACT 
	cum_gain > best_gain
#elif SPLIT_GAIN_VAR
	cum_gain_pos > best_gain_with_slop + cum_gain_neg 
#else
	cum_gain > best_gain_with_slop
#endif
) {
d1457 1
a1457 11
        if (
#if LENGTH_TYPE_IS_EXACT
			cum_1 <= best_gain 
#elif SPLIT_GAIN_VAR
			cum_1_pos <= best_gain_with_slop + cum_1_neg
#else
			cum_1 <= best_gain_with_slop
#endif

           )
		{
a1560 1
int declustering_rejects=0;
a1566 6

#	if JBMR_DECLUSTER_IN_ELIGIBILITY_TEST
		declustering_rejects = 
			cum_2 < best_gain_with_slop + cluster_dist;
#	endif /* |JBMR_DECLUSTER_IN_ELIGIBILITY_TEST| */

a1569 4
#	if JBMR_DECLUSTER_IN_ELIGIBILITY_TEST
		declustering_rejects = 
			cum_2_pos < best_gain_with_slop + cum_2_neg + cluster_dist;
#	endif /* |JBMR_DECLUSTER_IN_ELIGIBILITY_TEST| */
d1573 1
a1573 1
if ( declustering_rejects ) {
@


1.171
log
@Added some stats gathering (num reject by cum 1, num reject before build e)
Check for cum gain > best gain *before* entering Update
best gain and compose an eligible list of moves.
This might save a *lot* of time because we may avoid searching
an entire nn list.
@
text
@d6 7
d417 1
a417 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.170 1997/06/20 18:32:26 neto Exp neto $";
d1463 1
a1463 1
@@<One-shot initialization@@>=
d1549 1
a1549 1
const length_t cluster_dist=decluster_d(t2ip1,t2ip2);
@


1.170
log
@A better comment about building e list.
Commented out the code bloating PREV NEXT loop.
Made cluster rejection announcement at much lower verbose level, though
context is lost.
Count number of rejections due to declustering.
@
text
@d6 7
d410 1
a410 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.169 1997/06/18 16:43:47 neto Exp neto $";
d574 1
a574 1
	@@<Verbose: report depths@@>@@;
d1395 6
a1400 3
{ int i, t2ip1, t2ip2, enbl; 
#if !SPLIT_GAIN_VAR
	length_t cum_1, cum_2;
d1402 5
d1408 2
d1421 3
a1423 1
#if !SPLIT_GAIN_VAR
a1424 2
#else
		cum_1_neg = cum_gain_neg + cost(t[two_i],t2ip1);
d1439 1
d1446 2
a1447 1
	ec[BL] = 0;
d1450 10
d3587 6
@


1.169
log
@Milestones every 10th of a percent from 10 percent down through zero.
@
text
@d6 3
d403 1
a403 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.168 1997/06/17 20:28:57 neto Exp neto $";
d1378 2
d1454 10
a1463 1
It is unrolled if the symbol |JBMR_UNROLL_PREV_NEXT_LOOP| is defined.
d1467 1
a1467 4
t2ip2=tour_prev(t2ip1);
@@<Update |best_gain| and |e[BL]| if not tabu@@>@@;
t2ip2=tour_next(t2ip1);
@@<Update |best_gain| and |e[BL]| if not tabu@@>@@;
d3321 2
a3322 1
if ( verbose >= 500 ) {
d3324 1
a3324 1
	printf("%d: %d %d "length_t_spec" s%d rejected, clust_dist==%f\n",
d3332 1
d3337 9
@


1.168
log
@Added support for milestones.
@
text
@d6 3
d400 1
a400 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.167 1997/06/17 14:49:32 neto Exp neto $";
d3004 7
a3010 1
{ .10, .09, .08, .07, .06, .05, .045, .04, 
@


1.167
log
@Fixed a TeX error.
@
text
@d6 3
d397 1
a397 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.166 1997/06/17 14:47:12 neto Exp neto $";
d555 1
d1144 1
d2973 58
a3048 3
@@
@@<Module headers@@>=
#include "resource.h"
@


1.166
log
@Fixed an unterminated hash if
@
text
@d6 3
d394 1
a394 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.165 1997/06/17 14:45:14 neto Exp neto $";
d1236 1
a1236 1
#else /* SPLIT_GAIN_VAR */
d1238 1
a1238 1
#endif /* SPLIT_GAIN_VAR */
@


1.165
log
@Better formatting in eligibility test.
Added cluster compensation to the greedy test (Go deeper)
@
text
@d6 4
d391 1
a391 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.164 1997/06/16 21:22:16 neto Exp neto $";
d1532 5
a1536 4
#if BL<3
	e[BL][enbl].gain_for_comparison -= cluster_dist;
#else
	e[BL][enbl].cluster_dist = cluster_dist;
@


1.164
log
@More debug verbose info.
@
text
@d6 3
d387 1
a387 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.163 1997/06/16 21:14:23 neto Exp neto $";
d1224 3
d1229 1
a1229 1
#else
d1231 1
a1231 1
#endif
d1492 1
a1492 1
cum_2 = cum_1 + cost(t2ip1,t2ip2);
d1494 4
a1497 3
#if JBMR_DECLUSTER_IN_ELIGIBILITY_TEST
declustering_rejects = cum_2 < best_gain_with_slop + cluster_dist;
#endif /* |JBMR_DECLUSTER_IN_ELIGIBILITY_TEST| */
d1500 6
a1505 5
cum_2_pos = cum_1_pos + cost(t2ip1,t2ip2);
cum_2_neg = cum_1_neg;
#if JBMR_DECLUSTER_IN_ELIGIBILITY_TEST
declustering_rejects = cum_2_pos < best_gain_with_slop + cum_2_neg + cluster_dist;
#endif /* |JBMR_DECLUSTER_IN_ELIGIBILITY_TEST| */
d1511 1
a1511 1
} else {} /* Don't really reject just yet. Just gather data. */
d1520 1
a1520 1
e[BL][enbl].gain_for_comparison = e[BL][enbl].gain = cum_2;
d1522 3
a1524 3
e[BL][enbl].gain_for_comparison = cum_2_pos-cum_2_neg;
e[BL][enbl].gain_pos = cum_2_pos;
e[BL][enbl].gain_neg = cum_2_neg;
d1528 4
a1531 1
e[BL][enbl].gain_for_comparison -= cluster_dist;
d2588 3
@


1.163
log
@Decluster test should use the best gain with slop.
@
text
@d6 3
d384 1
a384 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.162 1997/06/16 21:01:11 neto Exp neto $";
d3191 1
a3193 1
#if !SPLIT_GAIN_VAR
d3196 4
d3212 1
a3212 1
	printf(" clust_dist==%f\n", (double)cluster_dist);
d3221 1
a3221 1
	printf("%d: %d %d "length_t_spec" s%d rejected clust_dist==%f\n",
@


1.162
log
@At verbose 501, print every cluster distance.
@
text
@d6 3
d381 1
a381 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.161 1997/06/16 20:38:58 neto Exp neto $";
d1486 1
a1486 1
declustering_rejects = cum_2 < best_gain + cluster_dist;
d1493 1
a1493 1
declustering_rejects = cum_2_pos < best_gain + cum_2_neg + cluster_dist;
@


1.161
log
@JBMR ALLOW VERBOSE is always defined.  Now decide on zero/non-zero status
instead.
@
text
@d6 4
d378 1
a378 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.160 1997/06/16 20:26:58 neto Exp neto $";
d1476 1
d3198 9
d3219 1
a3219 1
		cluster_dist);
@


1.160
log
@Added include decluster.h
@
text
@d6 3
d374 1
a374 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.159 1997/06/16 20:19:20 neto Exp neto $";
d2935 2
a2936 1
@@*Debugging output.  This is turned on only if |JBMR_ALLOW_VERBOSE| is defined,
d2941 1
a2941 1
#if defined(JBMR_ALLOW_VERBOSE)
d2959 1
a2959 1
#if defined(JBMR_ALLOW_VERBOSE)
d2970 1
a2970 1
#ifdef JBMR_ALLOW_VERBOSE
d2989 1
a2989 1
#if defined(JBMR_ALLOW_VERBOSE) && defined(JBMR_WATCH_THIS_CITY)
d2996 1
a2996 1
#ifdef JBMR_ALLOW_VERBOSE
d3005 1
a3005 1
#ifdef JBMR_ALLOW_VERBOSE
d3015 1
a3015 1
#ifdef JBMR_ALLOW_VERBOSE
d3025 1
a3025 1
#ifdef JBMR_ALLOW_VERBOSE
d3036 1
a3036 1
#ifdef JBMR_ALLOW_VERBOSE
d3046 1
a3046 1
#ifdef JBMR_ALLOW_VERBOSE
d3056 1
a3056 1
#ifdef JBMR_ALLOW_VERBOSE
d3080 1
a3080 1
#ifdef JBMR_ALLOW_VERBOSE
d3089 1
a3089 1
#ifdef JBMR_ALLOW_VERBOSE
d3098 1
a3098 1
#ifdef JBMR_ALLOW_VERBOSE
d3107 1
a3107 1
#ifdef JBMR_ALLOW_VERBOSE
d3116 1
a3116 1
#ifdef JBMR_ALLOW_VERBOSE
d3134 1
a3134 1
#ifdef JBMR_ALLOW_VERBOSE
d3177 1
a3177 1
#ifdef JBMR_ALLOW_VERBOSE
d3194 1
a3194 1
#ifdef JBMR_ALLOW_VERBOSE
d3212 1
a3212 1
#ifdef JBMR_ALLOW_VERBOSE
d3230 1
a3230 1
#ifdef JBMR_ALLOW_VERBOSE
d3259 1
a3259 1
#ifdef JBMR_ALLOW_VERBOSE
d3268 1
a3268 1
#ifdef JBMR_ALLOW_VERBOSE
d3278 1
a3278 1
#ifdef JBMR_ALLOW_VERBOSE
d3300 1
a3300 1
#if defined(JBMR_ALLOW_VERBOSE)||defined(JBMR_REPORT_DEPTHS)
d3362 1
a3362 1
#if defined(JBMR_ALLOW_VERBOSE)
d3378 1
a3378 1
#if defined(JBMR_ALLOW_VERBOSE)
@


1.159
log
@Fixed a syntax error.
@
text
@d6 3
d371 1
a371 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.158 1997/06/16 20:05:14 neto Exp neto $";
d1514 1
a1514 1
@@
d1516 1
@


1.158
log
@Need to include declevel.h to see whether to use declustering.
@
text
@d6 3
d368 1
a368 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.157 1997/06/16 20:04:05 neto Exp neto $";
d3189 1
a3189 1
	printf("%d: %d %d "length_t_spec" s%d rejected clust_dist==%f"\n",
@


1.157
log
@First cut at integrating decluster test.  Doesn't actually reject
just yet.  It just collects data.
@
text
@d6 4
d365 1
a365 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.156 1997/06/16 19:15:32 neto Exp neto $";
d1507 4
@


1.156
log
@Make unrolling the prev next loop conditional at compile time.
@
text
@d6 3
d361 1
a361 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.155 1997/06/16 18:34:20 neto Exp neto $";
d1197 1
a1197 1
	int t2ip1, t2ip2, scheme_id;
d1203 1
d1410 1
a1410 1
@@<Update |best_gain| and |e[BL]| if not tabu@@>=
d1412 1
a1412 1
@@<Update |best_gain| and |e[BL]| if not tabu@@>=
d1455 6
d1463 6
a1468 1
#else
d1471 9
d1481 2
d1488 1
a1488 1
e[BL][enbl].gain = cum_2;
d1490 1
d1495 4
d1501 2
d1597 5
a1601 5
Unfortunately, this gets rather complicated because we cover two cases
in each of two orthogonal dimensions.  The first dimension deals with
whether we use a split representation for the gain (done in the case
that |length_t| is an inexact type).  The second dimension deals
with whether to force the Quicksort method to be a stable sort by
d1606 4
a1609 4
cmp_eligible(const void *a, const void *b) {
#if !SPLIT_GAIN_VAR
	length_t diff =   ((const eligible_t *)a)->gain 
					- ((const eligible_t *)b)->gain; 
a1610 9
#else
	length_t agp = ((const eligible_t *)a)->gain_pos, 
			 agn = ((const eligible_t *)a)->gain_neg;
	length_t bgp = ((const eligible_t *)b)->gain_pos, 
			 bgn = ((const eligible_t *)b)->gain_neg;
	const length_t ambp = agp+bgn;
	const length_t ambn = agn+bgp;
	return (ambp < ambn) ? -1 : ((ambp > ambn) ? 1 : 
#endif
d3169 18
@


1.155
log
@Make the code compact by putting both alternatives for t2ip2 into
the body of a loop.
@
text
@d6 4
d358 1
a358 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.154 1997/06/16 17:36:52 neto Exp neto $";
d1400 3
d1404 6
d1416 1
d1422 1
d1424 1
d1428 1
d1431 1
@


1.154
log
@Fixed a TeX bug.
@
text
@d6 3
d354 1
a354 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.153 1997/06/16 16:57:14 neto Exp neto $";
d507 1
d1382 18
a1399 1
	t2ip2 = tour_prev(t2ip1);
d1401 13
a1413 3
	t2ip2 = tour_next(t2ip1);
	@@<Update |best_gain| and |e[BL]| if not tabu@@>@@;
#endif
d1717 1
a1717 4
	t2ip2 = tour_prev(t2ip1);
	@@<Update |best_gain| and |e[BL]| if not tabu@@>@@;
	t2ip2 = tour_next(t2ip1);
	@@<Update |best_gain| and |e[BL]| if not tabu@@>@@;
d2089 1
a2089 4
		t2ip2 = tour_prev(t2ip1);
		@@<Update |best_gain| and |e[BL]| if not tabu@@>@@;
		t2ip2 = tour_next(t2ip1);
		@@<Update |best_gain| and |e[BL]| if not tabu@@>@@;
@


1.153
log
@Don't need debugging output for SPLIT GAIN VAR anymore.
@
text
@d6 3
d351 1
a351 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.152 1997/06/16 16:45:51 neto Exp neto $";
d716 1
a716 1
|JBMR_REQUIRE_JOINED_GAIN_VAR|, say in file \{lkconfig.h}.  
@


1.152
log
@Reversed the sense of REQUEST SPLIT GAIN VAR to REQUIRE SPLIT GAIN VAR
That way the default (safe) setting happens with fewer variables set.
@
text
@d6 4
d348 1
a348 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.151 1997/06/13 20:59:16 neto Exp neto $";
a504 6
if (verbose>=10) {
fprintf(stderr,"SPLIT_GAIN_VAR==%d\n",SPLIT_GAIN_VAR);
fprintf(stdout,"SPLIT_GAIN_VAR==%d\n",SPLIT_GAIN_VAR);
fprintf(stderr,"LENGTH_TYPE_IS_EXACT==%d\n",LENGTH_TYPE_IS_EXACT);
fprintf(stdout,"LENGTH_TYPE_IS_EXACT==%d\n",LENGTH_TYPE_IS_EXACT);
}
@


1.151
log
@Made it quieter
@
text
@d6 3
d344 1
a344 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.150 1997/05/16 18:11:41 neto Exp neto $";
d706 2
a707 2
@@ On the other hand, I split these gain variables before I instituted the
idea of an instance epsilon (see below), which might alleviate the
d711 6
a716 4
So now I make the splitting of the gain variables optional,
turned on by defining the symbol |JBMR_REQUEST_SPLIT_GAIN_VAR|.  I call
it a request because it only has useful meaning when the length type is
inexact.
d720 1
a720 1
is a non-zero value when |length_t| is a type in which computations
d722 1
a722 1
It is a zero value
d727 3
a729 1
#if !LENGTH_TYPE_IS_EXACT && defined(JBMR_REQUEST_SPLIT_GAIN_VAR)
a730 2
#else
#define SPLIT_GAIN_VAR 0
@


1.150
log
@Break locks by david and neto.
Include <config.h> and "lkconfig.h"
@
text
@d6 4
d341 1
a341 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.149 1997/05/16 18:09:40 neto Exp neto $";
d498 1
d503 1
@


1.149
log
@Include <config.h> and lkconfig.h
@
text
@d6 3
d337 1
a337 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.148 1997/04/23 21:28:07 neto Exp neto $";
@


1.148
log
@Added elapsed time since last phase change to verbose reporting.
@
text
@d6 3
d323 2
d334 1
a334 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.147 1997/04/23 20:44:56 neto Exp neto $";
@


1.147
log
@In verbose mode, report elapsed time since start of LK phase when
an improvement has been found.
@
text
@d6 4
d329 1
a329 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.146 1997/02/07 16:52:23 neto Exp neto $";
d493 1
d1074 1
a1075 1
		incumbent_len -= best_gain;
d2837 6
a2842 2
	printf("=== improve by " length_t_spec " units",length_t_pcast(best_gain));
	printf("  after %f seconds\n",resource_user_tick());
d2851 10
d3295 2
@


1.146
log
@Made every use of emphpar end with a paragraph break.
@
text
@d6 3
d325 1
a325 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.145 1997/01/21 22:46:47 david Exp david $";
d2832 2
a2833 1
	printf("=== improve by " length_t_spec " units\n",length_t_pcast(best_gain));
d2837 5
@


1.145
log
@Clarified conditional compilation and fixed a bug.
@
text
@d6 3
d322 1
a322 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.144 1997/01/21 21:55:55 david Exp david $";
d1867 1
d2013 1
d2049 1
@


1.144
log
@Added standard copyright notice by including copyrt.w
@
text
@d6 3
d319 1
a319 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.143 1997/01/21 19:34:36 david Exp david $";
d1319 1
a1319 2
#if !SPLIT_GAIN_VAR
# if !LENGTH_TYPE_IS_EXACT 
d1321 3
a1323 1
# else
a1324 3
# endif
#else
			cum_1_pos <= best_gain_with_slop + cum_1_neg
d1326 1
d1437 1
d1439 1
a1439 2
#if !SPLIT_GAIN_VAR 
# if LENGTH_TYPE_IS_EXACT
d1441 3
a1443 1
# else 
a1444 3
# endif
#else
	   cum_2_pos  > best_gain_with_slop + cum_2_neg + cost_phantom
d1449 3
a1451 1
#if !SPLIT_GAIN_VAR
a1452 2
#else
	best_gain = cum_2_pos - cum_2_neg - cost_phantom;
@


1.143
log
@Clarified use of JBMR REQUEST SPLIT GAIN VAR
@
text
@d1 1
d6 3
d316 1
a316 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.142 1997/01/21 19:15:27 david Exp david $";
@


1.142
log
@Fixed setting of SPLIT GAIN VAR
@
text
@d5 3
d312 1
a312 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.140 1997/01/21 00:22:47 david Exp david $";
d468 5
d690 1
a690 1
#if !LENGTH_TYPE_IS_EXACT && JBMR_REQUEST_SPLIT_GAIN_VAR
d1430 1
d1432 1
@


1.141
log
@Added compile time option JBMR\_REQUEST\_SPLIT\_GAIN\_VAR.
The default for floating point is now to not split the gain variables.
However, instance epsilon is still in effect for inexact types.
@
text
@d682 1
a682 1
#if LENGTH_TYPE_IS_EXACT && JBMR_REQUEST_SPLIT_GAIN_VAR
@


1.140
log
@Removed offending pritnf
@
text
@d5 3
d309 1
a309 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.139 1997/01/21 00:21:53 david Exp david $";
d663 32
a694 1
Variable |best_gain| is always assigned the current value of the gain,
a698 3
#if !(LENGTH_TYPE_IS_EXACT)
length_t cum_gain_pos, cum_gain_neg;
#endif
d708 1
a708 6
compile-time constant |LENGTH_TYPE_IS_EXACT| defined by module \module{LENGTH}.
It is a non-zero value when |length_t| is a type in which computations
are exact, \eg\ |length_t| is an integer or rational type.  
It is a zero value
when  there might be a loss of precision, \eg\ when |length_t| is
either |float| or |double|.
d711 1
a711 1
#if LENGTH_TYPE_IS_EXACT
d1038 1
a1038 1
#if LENGTH_TYPE_IS_EXACT
d1059 1
a1059 1
#if LENGTH_TYPE_IS_EXACT
d1141 1
a1141 1
#if LENGTH_TYPE_IS_EXACT
d1282 1
a1282 1
#if LENGTH_TYPE_IS_EXACT
d1290 1
a1290 1
#if !(LENGTH_TYPE_IS_EXACT)
d1297 1
a1297 1
#if LENGTH_TYPE_IS_EXACT
a1298 1
		if ( cum_1 <= best_gain ) 
d1301 11
a1311 1
		if ( cum_1_pos <= best_gain_with_slop + cum_1_neg) 
d1313 1
d1357 1
a1357 1
#if LENGTH_TYPE_IS_EXACT
d1367 1
a1367 1
#if LENGTH_TYPE_IS_EXACT
d1420 8
a1427 3
#if LENGTH_TYPE_IS_EXACT
 const length_t cum_exit_now = cum_2 - cost_phantom;
 if ( cum_exit_now > best_gain ) 
d1429 1
a1429 1
 if ( cum_2_pos  > best_gain_with_slop + cum_2_neg + cost_phantom )
d1431 1
d1433 2
a1434 1
#if LENGTH_TYPE_IS_EXACT
d1438 2
d1442 1
d1479 1
a1479 1
#if LENGTH_TYPE_IS_EXACT
d1557 1
a1557 1
#if LENGTH_TYPE_IS_EXACT
d1878 1
a1878 1
#if LENGTH_TYPE_IS_EXACT
d2212 1
a2212 1
#if LENGTH_TYPE_IS_EXACT
d2424 2
a2425 2
#if LENGTH_TYPE_IS_EXACT
	length_t best_len;
d2427 1
a2427 1
	length_t best_len_pos, best_len_neg;
d2430 4
a2433 9
#if LENGTH_TYPE_IS_EXACT
	for ( i=0, best_len = 0                    ; i<en[3] ; i++ )
#else
	for ( i=0, best_len_pos = best_len_neg = 0 ; i<en[3] ; i++ ) 
#endif

	{
#if LENGTH_TYPE_IS_EXACT
		if ( best_len < e[3][i].gain )
d2435 1
a2435 1
		if ( best_len_pos + e[3][i].gain_neg < best_len_neg + e[3][i].gain_pos )
d2437 1
d2440 1
a2440 1
#if LENGTH_TYPE_IS_EXACT
d2449 1
a2449 1
#if LENGTH_TYPE_IS_EXACT
d2965 1
a2965 1
#if LENGTH_TYPE_IS_EXACT
d2980 1
a2980 1
#if LENGTH_TYPE_IS_EXACT
d3027 1
a3027 1
#if LENGTH_TYPE_IS_EXACT
d3042 1
a3042 1
#if LENGTH_TYPE_IS_EXACT
d3062 1
a3062 1
#if LENGTH_TYPE_IS_EXACT
@


1.139
log
@Report both probe and move depths.
@
text
@d5 3
d306 1
a306 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.137 1997/01/21 00:06:57 david Exp david $";
a2252 1
	pritnf("G:pd=%d gfm=%d\n",probe_depth,generic_flips_made);
@


1.138
log
@Actually count the probe depth, doh!
@
text
@d2250 1
d3153 2
a3154 1
depths[probe_depth]++;
d3169 3
a3171 2
depths = new_arr_of(int,DEPTHS_BOUND);
{int i; for (i=0;i<DEPTHS_BOUND;i++) depths[i]=0;}
d3178 2
a3179 1
free_mem(depths);
d3185 1
a3185 1
static int *depths=NULL;
d3192 1
a3192 1
	for (i=DEPTHS_BOUND-1;depths[i]!=0;i--);
d3194 5
a3198 1
		if ( depths[j] ) printf("%d citydeep %d\n",j,depths[j]);
@


1.137
log
@Added tracking of probe depths.
@
text
@d5 3
d303 1
a303 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.136 1997/01/20 23:49:53 david Exp david $";
d3152 1
@


1.136
log
@Changed max\_probe\_depth to max\_generic\_flips
@
text
@d5 3
d295 1
d300 1
a300 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.135 1997/01/20 23:47:01 david Exp david $";
d460 1
d3077 8
d3087 1
a3087 1
#ifdef JBMR_ALLOW_VERBOSE
d3094 1
a3094 1
#ifdef JBMR_ALLOW_VERBOSE
d3101 2
a3102 2
#ifdef JBMR_ALLOW_VERBOSE
move_depth = 6;
d3108 1
a3108 1
#ifdef JBMR_ALLOW_VERBOSE
d3115 1
a3115 1
#ifdef JBMR_ALLOW_VERBOSE
d3122 1
a3122 1
#ifdef JBMR_ALLOW_VERBOSE
d3126 1
d3129 1
a3129 1
#ifdef JBMR_ALLOW_VERBOSE
d3135 1
a3135 1
#ifdef JBMR_ALLOW_VERBOSE
d3141 1
d3147 2
d3150 1
d3157 32
@


1.135
log
@Fixed the limiting of probe depth.
@
text
@d5 3
d296 1
a296 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.134 1997/01/20 19:32:54 david Exp david $";
d2241 1
a2241 1
if ( generic_flips_made >= max_probe_depth ) {
@


1.134
log
@Optionally limit the probe depth.
@
text
@d4 4
a7 1
{\obeylines$Log:	jbmr.w,v $
d293 1
a293 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.133 97/01/16 13:35:17 neto Exp $";
d2238 5
a2242 1
if ( two_i >= max_probe_depth ) {go_deeper=0; break;}
@


1.133
log
@Get rid of a warning about old\_t when compiling with TABU LINEAR.
@
text
@d5 3
d290 1
a290 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.132 96/12/23 13:07:03 neto Exp $";
d2213 1
d2228 9
@


1.132
log
@New variable best gain with slop.  Saves many additions.
@
text
@d5 3
d287 1
a287 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.131 96/12/20 17:05:13 neto Exp $";
d550 1
d552 1
@


1.131
log
@Fixed typesetting woes by simplifiyng preprocessor stuff. (moved a brace.
).
@
text
@d5 4
d284 1
a284 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.130 96/12/20 17:02:54 neto Exp $";
d999 1
a999 1
		@@<Update the |instance_epsilon| slop value@@>@@;
d1167 6
d1178 2
a1179 1
length_t instance_epsilon;
d1182 10
d1205 1
a1205 5
@@<Initialize the bookkeeping variables@@>=
@@<Update the |instance_epsilon| slop value@@>

@@
@@<Update the |instance_epsilon| slop value@@>=
d1251 1
a1251 1
		if ( cum_1_pos <= best_gain + instance_epsilon + cum_1_neg) 
d1363 1
a1363 1
 if ( cum_2_pos  > best_gain + cum_2_neg + cost_phantom + instance_epsilon )
d1370 1
@


1.130
log
@Fixed TeX typos and a spelling mistake.
@
text
@d5 3
d280 1
a280 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.129 96/12/20 16:57:56 neto Exp $";
d1231 1
a1231 1
		if ( cum_1 <= best_gain ) {
d1234 1
a1234 1
		if ( cum_1_pos <= best_gain + instance_epsilon + cum_1_neg) {
d1236 1
@


1.129
log
@Fixed a tex bug.
@
text
@d5 3
d277 1
a277 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.128 96/12/20 16:41:53 neto Exp $";
d1141 1
a1141 1
Some of my experiments with |length_type==double| did not terminate. 
a1168 1

d1177 1
a1177 1
\hbox{|incumbent_len|} \times \hbox{|LENGTH_MACHINE_EPSILON|}$$.
d1191 1
a1191 1
an eligble list.
@


1.128
log
@Fixed typo in section name (init bookkeeping vars)
@
text
@d5 3
d274 1
a274 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.127 96/12/20 16:32:43 neto Exp $";
d1174 2
a1175 2
$$\hbox{instance_epsilon} = 
\hbox{incumbent_len} \times \hbox{|LENGTH_MACHINE_EPSILON|}$$.
@


1.127
log
@First attempt at incorporating instance\_epsilon
@
text
@d5 3
d271 1
a271 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.126 96/12/20 13:40:39 neto Exp $";
d970 1
a970 1
	@@<Initialize bookkeeping variables@@>@@;
d994 1
a994 1
@@<Initialize bookkeeping variables@@>=
d1154 3
d1177 1
a1177 1
@@<Update the |instance_epsilon| slop value@@>@@;
d3059 1
a3059 1
@@<Initialize bookkeeping variables@@>=
@


1.126
log
@Put the unified gain variables back in.  Make it optional.
@
text
@d5 3
d268 1
a268 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.125 96/12/19 12:12:07 neto Exp $";
d983 1
d1131 48
d1186 1
a1186 1
These are represented by their positive
d1188 1
a1188 1
|cum_2_pos| and |cum_2_neg|, respectively.
d1197 1
d1220 1
a1220 1
		if ( cum_1_pos <= best_gain + cum_1_neg) {
d1331 1
a1331 1
 if ( cum_2_pos  > best_gain + cum_2_neg + cost_phantom )
@


1.125
log
@Fixed a CWEB typo in the rcs log.
@
text
@d5 3
d265 1
a265 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.124 96/12/17 14:50:05 neto Exp $";
d578 5
d621 4
a624 1
length_t cum_gain_pos, cum_gain_neg, best_gain;
d626 19
d968 3
d973 1
d988 3
d992 1
d1070 3
d1074 1
d1147 3
d1151 1
d1153 3
d1157 3
d1162 4
d1168 1
d1211 3
d1216 1
d1220 4
d1226 2
d1274 10
a1283 1
if ( cum_2_pos  > best_gain + cum_2_neg + cost_phantom ) {
d1285 1
d1312 7
d1322 9
a1330 2
	length_t agp = ((const eligible_t *)a)->gain_pos, agn = ((const eligible_t *)a)->gain_neg;
	length_t bgp = ((const eligible_t *)b)->gain_pos, bgn = ((const eligible_t *)b)->gain_neg;
d1334 2
d1400 3
d1405 1
d1721 3
d1726 1
d2055 3
d2060 1
d2252 6
a2257 1
{ int i, best_i=-1; length_t best_len_pos, best_len_neg;
d2259 13
a2271 2
	for ( i=0, best_len_pos = best_len_neg = 0 ; i<en[3] ; i++ ) {
		if ( best_len_pos + e[3][i].gain_neg < best_len_neg + e[3][i].gain_pos ) {
d2273 3
d2278 1
d2282 3
d2287 1
d2798 6
a2803 1
		length_t_pcast(cum_gain_pos-cum_gain_neg), length_t_pcast(best_gain), scheme_id );
d2813 1
d2817 1
a2817 1
	int cg = cum_gain_pos-cum_gain_neg, bg = best_gain; \
d2826 2
a2827 1
	printf("\tcg %d bg %d\n",cg,bg); \
d2831 19
d2859 7
a2865 1
		enbl,t2ip1,t2ip2,length_t_pcast(cum_2_pos-cum_2_neg),e[BL][enbl].scheme_id);
d2875 3
d2883 1
d2895 7
d2910 1
@


1.124
log
@Now it compiles when debugging output is turned on.
Also, fixed a CWEB style infelicity.
@
text
@d5 4
d131 1
a131 1
During backtracking, we must clean up our scheme even though |best_gain>0|
d262 1
a262 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.123 96/12/16 17:02:55 neto Exp $";
@


1.123
log
@Fixed a typo.
Forgot the comparison function for eligible moves; it now handles
the split representation.
@
text
@d5 5
d127 1
a127 1
During backtracking, we must clean up our scheme even though $best_gain>0$
d258 1
a258 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.122 96/12/16 16:38:37 neto Exp $";
d945 4
a948 1
@@
d950 1
d2711 2
a2712 2
		"(== "length_t_spec" - " length_t_spec)"\n",
		length_t_pcast(cum_1_pos-cum1_neg),
d2714 1
a2714 1
		length_t_pcast(cum1_neg) );
d2726 2
a2727 1
		@@<Verbose: indent@@> printf("%d %d "length_t_spec" s%d\n", 
d2730 3
a2732 1
			length_t_pcast(e[3][i].gain), 
@


1.122
log
@First attempt at separating cum\_gain into positive and negative parts.
@
text
@d5 3
d253 1
a253 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.121 96/08/19 18:22:01 neto Exp Locker: neto $";
d1193 1
a1193 1
{const length cost_phantom = cost(t[1],t2ip2);
d1225 5
a1229 2
	length_t diff =((const eligible_t *)a)->gain - ((const eligible_t *)b)->gain; 
	return diff > 0 ? -1 : (diff < 0 ? 1 : 
d1366 1
a1366 1
if ( t2ip1 != t[3] ) { 	
@


1.121
log
@Fixed uninitialized variables.  
generic flips made being uninitialized was a *bug*!
@
text
@d5 4
d250 1
a250 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.120 96/08/16 16:29:59 neto Exp $";
d553 51
a624 6

%We use |possible_gain| as a working variable to compute the
%gain to be had by terminating the search now.
% |length_t possible_gain|;


a625 1
length_t cum_gain, best_gain;
d649 2
a650 1
to be pruned by the 1-tree condition: |best_gain < cum_gain|.
d686 2
a687 1
In terms of our program variables, this is expressed by |cum_gain > best_gain|.
d926 2
a927 1
		cum_gain = t1_l[t1_i];
d1010 2
a1011 1
the scheme ID (if applicable), and the net change in |cum_gain|.
d1016 1
a1016 1
	length_t gain;
d1075 4
a1078 3
respectively, 
and |cum_exit_now| is the cost of adding the phantom edge from |t2ip2| to
|t[1]|.
d1088 2
a1089 1
{ int i, t2ip1, t2ip2, enbl; length_t cum_1, cum_2, cum_exit_now;
d1091 1
d1094 2
a1095 2
		cum_1 = cum_gain - cost(t[two_i],t2ip1);
		if ( cum_1 <= best_gain ) {
d1138 2
a1139 1
cum_2 = cum_1 + cost(t2ip1,t2ip2);
d1143 2
a1144 1
e[BL][enbl].gain = cum_2;
d1183 4
d1190 3
a1192 3
cum_exit_now = cum_2 - cost(t[1],t2ip2);
if ( cum_exit_now > best_gain ) {
	best_gain = cum_exit_now;
d1199 1
d1288 2
a1289 1
	cum_gain = this_move->gain;
d1605 2
a1606 1
	cum_gain = this_move->gain;
d1935 2
a1936 1
	cum_gain = this_move->gain;
d2128 1
a2128 1
{ int i, best_i=-1; length_t best_len;
d2130 2
a2131 2
	for ( i=0, best_len = 0 ; i<en[3] ; i++ ) {
		if ( best_len < e[3][i].gain ) {
d2133 2
a2134 1
			best_len = e[3][i].gain;	
d2138 2
a2139 1
	cum_gain = best_len;
d2650 1
a2650 1
		length_t_pcast(cum_gain), length_t_pcast(best_gain), scheme_id );
d2663 1
a2663 1
	int cg = cum_gain, bg = best_gain; \
d2685 1
a2685 1
		enbl,t2ip1,t2ip2,length_t_pcast(cum_2),e[BL][enbl].scheme_id);
d2695 5
a2699 1
	printf("Terminating |cum_1| "length_t_spec"\n",length_t_pcast(cum_1) );
d2710 1
a2710 1
	for ( i=0, best_len = 0 ; i<en[3] ; i++ ) {
@


1.120
log
@Made it pass all warning flags when "allow verbose" is on.
Added "watch this city"
@
text
@d5 4
d246 1
a246 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.119 96/08/16 13:04:45 neto Exp $";
d255 1
d1668 1
d1956 12
d1969 2
a1970 2
int last_special_two_i;
int generic_flips_made;
d1972 1
d2063 1
a2063 1
{ int i, best_i; length_t best_len;
d2071 1
@


1.119
log
@Added fixincludes.
@
text
@d5 3
d242 1
a242 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.118 96/08/16 12:40:42 neto Exp $";
d2417 2
a2418 2
#if 0
	if ( *dirty == 411 ) { 
d2432 1
a2432 1
#if defined(JBMR_ALLOW_VERBOSE)
a2469 1
	int i;
d2595 1
a2595 1
if ( verbose >= 500 ) {int i;
d2710 1
a2710 1
probe_depth >= two_i+2 || (probe_depth = two_i+2);
d2734 6
@


1.118
log
@Converted putchar to printf.   Otherwise, I'd never get a prototype
for SunOS's \_flusbuf.
@
text
@d5 4
d239 1
a239 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.117 96/08/15 14:35:51 neto Exp $";
d248 1
@


1.117
log
@Fixed a const-related warning.
@
text
@d5 3
d235 1
a235 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.116 96/08/15 14:18:47 neto Exp $";
d2570 1
a2570 1
	for ( i=0;i<(X);i++) {putchar(' ');}\
d2646 1
a2646 1
{ int i; for (i=0;i<two_i;i++) putchar(' '); }
@


1.116
log
@Make it pass more gcc warning flags.
@
text
@d5 3
d232 1
a232 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.115 96/08/15 13:20:57 neto Exp $";
d418 1
a418 1
    return (*(int *)a)-(*(int *)b);
@


1.115
log
@Make it pass -Wall
@
text
@d5 3
d229 1
a229 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.114 96/08/14 13:35:52 neto Exp Locker: neto $";
d506 2
a507 1
int
d1130 1
a1130 1
sort(e[BL],en[BL],sizeof(eligible_t),cmp_eligible);
d1599 2
a1600 1
void
d2274 1
d2277 2
a2278 2
	int a1 =  *((int *)a), a2 = *(((int *)a)+1);
	int b1 =  *((int *)b), b2 = *(((int *)b)+1);
d2377 2
a2378 1
void
@


1.114
log
@Use sort instead of qsort.
@
text
@d5 3
d226 1
a226 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.113 96/08/07 15:33:50 neto Exp $";
d417 1
a417 1
    printf("%x=int %d",a,*(int *)a);
d510 1
d548 3
a550 2
We use |possible_gain| as a working variable to compute the
gain to be had by terminating the search now.
d554 1
a554 1
length_t cum_gain, best_gain, possible_gain;
d596 4
a599 3
The eight-entry (though 1-based) array |nn| is a set of read
cursors into nearest neighbour lists.
This is used to enumerate candidate neighbours.
a600 2
We'll also use |nn_two_i| to enumerate the neighbours of |t[two_i]|.

d602 1
a602 1
int two_i, nn[9], nn_two_i;
d1137 1
a1137 1
	length_t diff =((eligible_t *)a)->gain - ((eligible_t *)b)->gain; 
d2067 1
a2067 1
	int j, low_j, best_is_prefix;
d2411 1
d2413 1
a2713 3
@@
@@<|jbmr_run| variables@@>=
int probes = 0;
@


1.113
log
@Added reasons why pointer-difference tie-breaking would break code
in several places.
@
text
@d5 4
d223 1
a223 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.112 96/08/07 15:18:44 neto Exp $";
d1116 5
d1122 1
a1122 1
qsort(e[BL],en[BL],sizeof(eligible_t),cmp_eligible);
@


1.112
log
@Make qsort optionally preserve the order of equals.
@
text
@d5 3
d219 1
a219 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.111 96/07/29 17:09:07 neto Exp $";
d395 7
d2229 6
d2248 5
@


1.111
log
@Fixed to compile.
@
text
@d5 3
d216 1
a216 1
const char *jbmr_rcs_id = "$Id: jbmr.w,v 1.110 96/07/29 16:19:50 neto Exp $";
d1115 7
a1121 1
	return diff > 0 ? -1 : (diff < 0 ? 1 : 0 );
@


1.110
log
@Added *\_rcs\_id.
Made sure RCS log is activated within this file.
@
text
@d5 4
a204 1
const char jbmr_rcs_id[] = "$Id: jbmr.w,v 1.109 96/07/25 13:30:36 neto Exp $";
d213 1
@


1.109
log
@Changed ALLOW\_VERBOSE to JBMR\_ALLOW\_VERBOSE
@
text
@d2 1
d4 4
a7 1
{\obeylines$Log: jbmr.w,v $
d201 1
a201 1
static char rcsid[] = "$Id: jbmr.w,v 1.108 1996/07/05 18:18:46 david Exp david $";
d223 1
@


1.108
log
@Fixed log. Duh.
@
text
@d3 4
a6 1
{\obeylines$Log:	jbmr.w,v $
d197 1
a197 1
static char rcsid[] = "$Id: jbmr.w,v 1.107 96/06/28 12:18:42 neto Exp $";
d2326 1
a2326 1
@@*Debugging output.  This is turned on only if |ALLOW_VERBOSE| is defined,
d2331 1
a2331 1
#if defined(ALLOW_VERBOSE)
d2340 1
a2340 1
#ifdef ALLOW_VERBOSE
d2364 1
a2364 1
#ifdef ALLOW_VERBOSE
d2373 1
a2373 1
#ifdef ALLOW_VERBOSE
d2383 1
a2383 1
#ifdef ALLOW_VERBOSE
d2393 1
a2393 1
#ifdef ALLOW_VERBOSE
d2405 1
a2405 1
#ifdef ALLOW_VERBOSE
d2415 1
a2415 1
#ifdef ALLOW_VERBOSE
d2425 1
a2425 1
#ifdef ALLOW_VERBOSE
d2449 1
a2449 1
#ifdef ALLOW_VERBOSE
d2458 1
a2458 1
#ifdef ALLOW_VERBOSE
d2467 1
a2467 1
#ifdef ALLOW_VERBOSE
d2476 1
a2476 1
#ifdef ALLOW_VERBOSE
d2485 1
a2485 1
#ifdef ALLOW_VERBOSE
d2498 1
a2498 1
#ifdef ALLOW_VERBOSE
d2520 1
a2520 1
#ifdef ALLOW_VERBOSE
d2531 1
a2531 1
#ifdef ALLOW_VERBOSE
d2541 1
a2541 1
#ifdef ALLOW_VERBOSE
d2559 1
a2559 1
#ifdef ALLOW_VERBOSE
d2568 1
a2568 1
#ifdef ALLOW_VERBOSE
d2578 1
a2578 1
#ifdef ALLOW_VERBOSE
d2600 1
a2600 1
#ifdef ALLOW_VERBOSE
d2607 1
a2607 1
#ifdef ALLOW_VERBOSE
d2614 1
a2614 1
#ifdef ALLOW_VERBOSE
d2621 1
a2621 1
#ifdef ALLOW_VERBOSE
d2628 1
a2628 1
#ifdef ALLOW_VERBOSE
d2635 1
a2635 1
#ifdef ALLOW_VERBOSE
d2641 1
a2641 1
#ifdef ALLOW_VERBOSE
d2647 1
a2647 1
#ifdef ALLOW_VERBOSE
@


1.107
log
@Moved some TeX definitions to webdefs.w
@
text
@d4 3
d194 1
a194 1
static char rcsid[] = "$Id: jbmr.w,v 1.106 96/06/24 16:18:01 neto Exp $";
@


1.106
log
@Fixed comment that CWEB was interpreting.
@
text
@a1 5
\def\cost{\hbox{\it cost}}
\def\emphpar#1{{\medskip\narrower\noindent\relax #1\medskip}}
\def\centrepar#1{{\medskip\noindent\hbox{}\hfill\relax#1\relax\hfill{}\hbox{}%
\medskip}}
\def\book#1{{\sl #1}}
d4 3
d191 1
a191 1
static char rcsid[] = "$Id: jbmr.w,v 1.105 96/06/20 16:11:58 neto Exp $";
@


1.105
log
@Use a more math-like typeset name for t2ip1 and t2ip2
@
text
@d9 3
d159 1
a159 1
%@@s two_i TeX
d193 1
a193 1
static char rcsid[] = "$Id: jbmr.w,v 1.104 96/06/19 14:12:31 neto Exp $";
@


1.104
log
@Finished adding splay TABU stuff.  It's all-or-nothing, though.
It could use some experimental work to determine the right cut-off.
Also, try the LEDA dictoinaries.
@
text
@d9 5
d151 6
d190 1
a190 1
static char rcsid[] = "$Id: jbmr.w,v 1.103 96/06/04 12:41:58 neto Exp $";
@


1.103
log
@More TABU stuff.
@
text
@d9 3
d179 1
a179 1
static char rcsid[] = "$Id: jbmr.w,v 1.102 96/06/03 15:36:34 neto Exp $";
d433 5
d440 1
d445 1
d1978 1
a1980 1
	@@<Add to the tabu structure@@>@@;
d2140 2
a2141 1
that?  Hmmm.
d2144 2
a2145 2
#ifdef TABU_LINEAR
#ifdef TABU_JBMR
d2156 1
a2156 1
#elsif defined(TABU_Papadimitriou)
d2159 1
a2159 1
{ errorif(1,"Need one of TABU_JBMR or TABU_Papadimitriou defined"); }
d2187 1
a2187 1
#ifdef TABU_SPLAY
d2198 1
a2198 1
#ifdef TABU_SPLAY
d2200 1
a2200 2
cmp_pair(
cmp_int(const void *a, const void *b) {
d2223 9
a2231 1
@@ The linear check needs no setup or teardown.
d2233 6
d2242 3
d2246 4
a2249 1
@@
d2251 3
d2255 6
d2262 46
d2313 1
a2313 1
#ifdef ALLOW_VERBOSE
@


1.102
log
@More tabu stuff.
@
text
@a2 1
\def\ie{\hbox{\it i.e.}}
d9 3
d176 1
a176 1
static char rcsid[] = "$Id: jbmr.w,v 1.101 96/05/31 17:07:05 neto Exp $";
d1877 2
a1878 1
@@ We use a loop to check the tabu condition.  This is a linear search 
d1916 5
a1920 1
But first we'll check the feasibility.
d1922 2
d2064 1
a2064 2
defined two tabu rules on new edges:

a2065 1

a2066 1

d2083 1
a2083 1
see the paper {\sl How easy is local search?} of Johnson,
d2101 2
a2102 1
known, for one edge to be checked per choice of |t2ip1|.  We'll see.
d2107 2
a2108 3
In this  program, the usage pattern is as follows:

\def\q{\hskip3em\relax}
d2110 2
a2111 2
repeat \{\br
\q repeat \{\br
d2114 1
a2114 1
\q\}\br
d2116 1
a2116 1
\}\br
d2150 1
d2162 1
a2162 1
case, we will be using a splay tree here.  These have nice working
d2172 2
d2175 1
a2175 1
@@<Set |is_tabu| appropriately@@>=
d2177 1
a2177 8
	int i;
	for ( i=2, is_tabu = 0; i < two_i ; i+= 2 ) {
		if ( (t2ip1 == t[i] && t2ip2 == t[i+1]) 
			|| (t2ip1 == t[i+1] && t2ip2 == t[i]) ) {
			is_tabu = 1;
			break;
		}
	}
d2179 43
@


1.101
log
@Added some measurements regarding tabu check in the generic phase of
the search.
Began to parameterize the code regarding tabu check.
@
text
@d5 2
d10 5
d174 1
a174 1
static char rcsid[] = "$Id: jbmr.w,v 1.100 96/05/29 11:13:12 neto Exp $";
d1831 1
d1846 1
d1903 1
a1903 1
102875 non-trivial generic probes, 
a1914 2
@@d LINEAR_JBMR_TABU_CHECK 1

d1919 1
a1919 10
#if LINEAR_JBMR_TABU_CHECK
	int i;
	for ( i=2, is_tabu = 0; i < two_i ; i+= 2 ) {
		if ( (t2ip1 == t[i] && t2ip2 == t[i+1]) 
			|| (t2ip1 == t[i+1] && t2ip2 == t[i]) ) {
			is_tabu = 1;
			break;
		}
	}
#endif
d1926 1
d1961 1
d2053 3
d2057 122
a2178 1
@@* Debugging output.  This is turned on only if |ALLOW_VERBOSE| is defined,
@


1.100
log
@This version works.  
Needs improvement:
	command-line switches
	faster tabu check
	allow Papadimitriou tabu rule
	faster preprocessing
	different candidate lists
@
text
@d8 9
d167 1
a167 1
static char rcsid[] = "$Id: jbmr.w,v 1.47 96/05/28 11:52:53 neto Exp $";
d1845 5
a1849 2
We also need to know when generic flips have been made.  This is used when
we attempt to unroll them.
d1874 9
a1882 2
the order of 6 to 8.  But both Lin and Kernighan, and JBMR both report
initially having up to $N/4$ cities involved in the early stages.
d1884 15
d1906 2
d1911 3
a1913 1
	int i, is_tabu;
d1921 1
d1943 1
a1943 1
the best move.  (This
@


1.47
log
@Added a fflush
@
text
@d8 3
d158 1
a158 1
static char rcsid[] = "$Id: jbmr.w,v 1.46 96/05/24 17:44:11 neto Exp $";
@


1.46
log
@Added probe statistics.
@
text
@d8 3
d155 1
a155 1
static char rcsid[] = "$Id: jbmr.w,v 1.45 96/05/23 14:49:36 neto Exp $";
d2341 1
@


1.45
log
@Added fflushes everywhere, and a hook to examine a particular city
in detail.
This version does the full LK now.  It hasn't crashed yet.
@
text
@d8 5
d152 1
a152 1
static char rcsid[] = "$Id: jbmr.w,v 1.43 96/05/23 11:46:44 neto Exp $";
d831 1
d1112 1
d1134 1
d1428 1
d1475 1
d1755 1
d1783 1
d1811 1
d1953 1
d2005 1
d2073 1
d2280 65
@


1.44
log
@Fixed generation of t2ip2.  Doh!
@
text
@d2002 1
d2011 11
d2026 5
d2035 1
d2044 1
d2054 1
d2066 1
d2076 1
d2086 1
d2108 1
d2119 1
d2128 1
d2137 1
d2146 1
d2157 1
d2179 1
d2192 1
d2202 1
d2220 1
d2229 1
d2238 1
d2261 1
@


1.43
log
@Fixed up the showing of the t array.
@
text
@d8 3
d147 1
a147 1
static char rcsid[] = "$Id: jbmr.w,v 1.42 96/05/22 17:22:09 neto Exp $";
d1829 2
a1830 2
	if ( t[two_i] == tour_prev(t[1]) ) t2ip2 = tour_next(t[two_i]);
	else t2ip2 = tour_prev(t[two_i]);
@


1.42
log
@Removed a redundant test for |best\_scheme\_id| == 13.
Added |length\_t\_pcast| where necessary.  (Ooops!)
@
text
@d8 4
d144 1
a144 1
static char rcsid[] = "$Id: jbmr.w,v 1.40 96/05/22 16:34:08 neto Exp $";
a1475 1
@@<Verbose: show |t|@@>@@;
d2051 1
d2070 1
d2072 4
a2075 6
		if ( i > 1 ) {
			if ( i%2 ) {
				c -= cost(t[i],t[i-1]);
			} else {
				c += cost(t[i],t[i-1]);
			}
d2079 1
a2079 1
	b -= cost(t[1],t[two_i]);
a2080 1
	if ( b < 0 ) {putchar('-'); b=-b;}
@


1.41
log
@Fixed up Log lines for TeX.
@
text
@d1924 1
a1924 1
if ( best_scheme_id == 13 ) {
d1995 1
a1995 1
	printf("=== improve by " length_t_spec " units\n",best_gain);
d2008 1
a2008 1
@@<Verbose: announce start of generic search@@>=
d2011 1
a2011 1
	printf("Start generic search\n");
d2016 1
a2016 1
@@<Verbose: announce generic flip made@@>=
d2018 2
a2019 2
if ( verbose >= 175 ) {
	printf("Generic flips made: %d\n", generic_flips_made);
d2023 1
d2025 1
a2025 1
@@<Verbose: announce generic flips remain after rollback@@>=
d2028 1
a2028 1
	printf("Generic flips remain after rollback: %d\n", generic_flips_made);
a2031 1

d2039 1
a2039 1
		best_gain, best_exit_a, best_exit_b,best_scheme_id);
d2077 1
a2077 1
	printf(length_t_spec" ",c);
d2079 1
a2079 1
	printf(length_t_spec"\n",b);
d2123 1
a2123 1
		cum_gain, best_gain, scheme_id );
d2155 2
a2156 1
	printf("%d: %d %d "length_t_spec" s%d\n",enbl,t2ip1,t2ip2,cum_2,e[BL][enbl].scheme_id);
d2165 1
a2165 1
	printf("Terminating |cum_1| "length_t_spec"\n",cum_1 );
d2179 1
a2179 1
			e[3][i].gain, 
@


1.40
log
@Fixed announcement of generic rollback.
@
text
@d8 3
d12 1
a12 1
Added a forgotten #endif
d16 1
a16 1
if |ALLOW_VERBOSE| is defined.
d140 1
a140 1
static char rcsid[] = "$Id: jbmr.w,v 1.39 96/05/22 15:49:08 neto Exp $";
@


1.39
log
@Added a forgotten #endif
@
text
@d8 3
d137 1
a137 1
static char rcsid[] = "$Id: jbmr.w,v 1.37 96/05/22 15:39:12 neto Exp $";
d2013 1
a2013 1
@@<Verbose: announce generic flip made@@>@@;
d2028 1
d2080 2
d2083 1
a2083 1
@@<Verbose: announce generic flip made@@>=
d2086 1
a2086 1
	printf("Generic flips made %d\n",generic_flips_made);
a2094 8
}
#endif

@@
@@<Verbose: announce |tour_flip_arb(a,b,c,d)|@@>=
#ifdef ALLOW_VERBOSE
if ( verbose >= 350 ) {
	printf("tour_flip_arb(%d,%d,%d,%d)",a,b,c,d);
@


1.38
log
@Forgot a verbose section, and fixed up a name.
@
text
@d2082 1
@


1.37
log
@Make debugging output rely on value of |verbose|, and only compiled in
if |ALLOW_VERBOSE| is defined.
@
text
@d8 4
d134 1
a134 1
static char rcsid[] = "$Id: jbmr.w,v 1.36 96/05/22 14:36:46 neto Exp $";
d1322 1
a1322 1
		@@<Verbose: show |base_scheme[6]@@>@@;
d1891 1
a1891 1
	generic_flips_made = 1; 
d2044 1
d2077 7
d2087 1
a2087 1
	printf("Rollback flip(t%d t%d t%d t%d)\n",1,j,j-1,j-2);
@


1.36
log
@Runon comment!!!
Terminated properly now.
@
text
@d8 4
d130 1
a130 1
static char rcsid[] = "$Id: jbmr.w,v 1.34 96/05/22 13:38:10 neto Exp $";
a728 1
@@<Debug: print the tour@@>@@;
d732 1
a732 1
	printf("Search for an improvement starting at city %d\n",*dirty);
d754 1
a754 1
		printf("==  improve by " length_t_spec " units\n",best_gain);
d908 1
a908 1
@@<Debug: show current position@@>@@;
d913 1
a913 1
@@<Debug: show terminating |cum_1|@@>@@;
d960 1
a960 1
@@<Debug: output candidate pair@@>@@;
d1008 1
a1008 2
printf("--");
	@@<Debug: output new |best_gain|@@>@@;
d1162 1
a1162 1
@@<Debug: indent@@>@@; printf("base_scheme5 == %d\n",base_scheme[5]);
d1318 1
a1318 1
@@<Debug: indent@@>@@; printf("base_scheme6 == %d\n",base_scheme[6]);
d1461 2
a1462 2
printf("Implement scheme %d\n",scheme_id);
@@<Debug: show |t|@@>@@;
d1478 1
a1478 1
printf("tour_flip_arb(%d,%d,%d,%d)",a,b,c,d);
d1481 1
a1481 1
printf(" case a\n");
d1484 1
a1484 1
printf(" case b\n");
d1780 2
a1781 1
generic_flips_made = 0; printf("Start generic search\n");
d1875 1
a1875 1
@@<Debug: go deeper@@>@@;
d1887 2
a1888 1
	generic_flips_made = 1; printf("Generic flips made\n");
d1933 1
d1935 1
a1935 1
printf("U Flip t%d t%d t%d t%d\n",1,j,j-1,j-2);
d1938 2
a1939 2
	generic_flips_made = low_j > last_special_two_i;
printf("Generic flips remain: %s\n", generic_flips_made ? "Yes" : "No");
d1970 1
a1970 2
printf("Unrolling the scheme %d changes\n",scheme_id);
@@<Debug: show |t|@@>@@;
d1978 3
a1980 1
@@* Debugging output.
d1982 6
a1987 2
@@<Debug: indent@@>=
{ int i; for (i=0;i<two_i;i++) putchar(' '); }
d1989 7
a1995 5
@@ Here, |t[two_i]| is the last thing added.
@@<Debug: show current position@@>=
@@<Debug: indent@@>@@;
printf("%d %d "length_t_spec" "length_t_spec" s%d\n", t[two_i-1], t[two_i],
	cum_gain, best_gain, scheme_id );
d1998 4
a2001 16
@@<Debug: show terminating |cum_1|@@>=
@@<Debug: indent@@>@@;
printf("Terminating |cum_1| "length_t_spec"\n",cum_1 );

@@ Show the candidate list.
@@<Debug: go deeper@@>=
{ int i; 
	@@<Debug: indent@@>@@; printf("go deeper candidates begin\n");
	for ( i=0, best_len = 0 ; i<en[3] ; i++ ) {
		@@<Debug: indent@@> printf("%d %d "length_t_spec" s%d\n", 
			e[3][i].t2ip1, 
			e[3][i].t2ip2, 
			e[3][i].gain, 
			e[3][i].scheme_id );
	}
	@@<Debug: indent@@>@@; printf("go deeper candidates end\n");
d2003 1
a2004 1

d2006 4
a2009 14
@@<Module subroutines@@>=
#define put_city(X) \
{ \
	int i;\
	int cg = cum_gain, bg = best_gain; \
	for ( i=0;i<(X);i++) {putchar(' ');}\
	printf("t%d == %d p=%d n=%d",(X),t[(X)],tour_prev(t[(X)]),tour_next(t[(X)]));\
	if (X>1) { \
		int c = cost(t[(X)-1],t[X]); \
		printf(" c(t%d,t%d)=%d",(X)-1,(X),c); \
		c = cost(t[(X)],t[1]); \ 
		printf(" c(t%d,t1)=%d",(X),c); \
	} \
	printf("\tcg %d bg %d\n",cg,bg); \
d2011 1
d2014 4
a2017 4
@@<Debug: output candidate pair@@>=
{int i;
	@@<Debug: indent@@>@@;
	printf("%d: %d %d "length_t_spec" s%d\n",enbl,t2ip1,t2ip2,cum_2,e[BL][enbl].scheme_id);
d2019 1
d2022 5
a2026 3
@@<Debug: output new |best_gain|@@>=
{int i;
	@@<Debug: indent@@>@@;
d2030 1
d2032 16
d2049 4
a2052 2
@@<Debug: show |t|@@>=
{int i;
d2069 1
d2072 123
@


1.35
log
@Change base_scheme[5]==8 check to use 4365 instead of 1265.
@
text
@d1296 2
a1297 1
			and legality follows.
@


1.34
log
@During backtracking, we must clean up our scheme even though $best_gain>0$
because that may be due to some other scheme.
Also, add some debugging output for generic flips.
@
text
@d8 5
d126 1
a126 1
static char rcsid[] = "$Id: jbmr.w,v 1.33 96/05/21 13:55:57 neto Exp $";
d1283 1
a1283 1
		if ( tour_inorder(t[1],t[2],t2ip2,t2ip1) ) { /* 1265 */
d1285 13
a1297 10
			/* Legality: First, |{6,5}!={1,2}| because 
			1265 and |6!=5| make |6!=1|, so the only danger is if
			|6==2|; but this is disallowed because |{3,4}| intervenes,
			making |6| come no closer to 2 than 4, but the stupid check
			ensures that |5!=3|, so |6>4|.  Second, |{6,5}!={4,3}|
			by the same reasoning as at the end of the first argument.
			So we need only check feasibility.  The pairs are: 52,16.
			But these are disallowed by the reasoning in the first part
			of the legality check.  So there is nothing to check. */
		} else {	/* !1265 */
d1301 9
a1309 10
				we must disallow |{6,5}=={1,2} and |{6,5}!={4,3}|.
				First |{5,6}!={1,2}| because |!1265| implies 
				|!1265| implies that |(5,6)| is oriented the same
				way as |(1,2)| (because |!1254| and |!1234| show that
				|{3,4}| intervenes between 1 and 5), and |!1265| also	
				shows that |5!=1|.
				Second, |{5,6}!={4,3}| because |(4,3)| and |(5,6) are
				both oriented in the same way as |(1,2)|, yet |5!=4|	
				by construction.  So legality---as far as we can tell---
				is preserved.  */
d1613 1
a1613 1
	case 9:	/* |!1234&&!1254&&!1265| */
@


1.33
log
@Refine the case 1.2 legality test for t6.
Added some Case marker comments.
@
text
@d8 4
d121 1
a121 1
static char rcsid[] = "$Id: jbmr.w,v 1.32 96/05/21 13:30:11 neto Exp $";
d1397 1
a1397 1
		@@<If necessary, implement an improving 3-change@@>@@;
d1427 13
a1439 5
@@<If necessary, implement an improving 3-change@@>=
if ( best_gain > 0 && more_backtracking && 
		scheme_num_cities[best_scheme_id] == 6 ) {
	if ( best_exit_a == t[5] && best_exit_b == t[6] ) {
		@@<Unroll all the generic changes.@@>@@;
a1441 3
		t[5] = best_exit_a; t[6] = best_exit_b;
		scheme_id = best_scheme_id;
		@@<Implement |scheme_id|@@>@@;
a1442 2
	@@<Mark changed cities as dirty@@>@@;
	more_backtracking = 0;
d1722 1
a1722 1
	@@<If necessary, implement an improving 4-change@@>@@;
d1735 12
a1746 5
@@<If necessary, implement an improving 4-change@@>=
if ( best_gain > 0 && more_backtracking && 
		scheme_num_cities[best_scheme_id] == 8 ) {
	if ( best_exit_a == t[7] && best_exit_b == t[8] ) {
		@@<Unroll all the generic changes.@@>@@;
a1748 3
		t[7] = best_exit_a; t[8] = best_exit_b;
		scheme_id = best_scheme_id;
		@@<Implement |scheme_id|@@>@@;
a1749 1
	more_backtracking = 0;
d1770 1
a1770 1
generic_flips_made = 0;
d1876 1
a1876 1
	generic_flips_made = 1;
d1926 1
@


1.32
log
@Fixed the inorder query in the reverse direction.
@
text
@d8 3
d117 1
a117 1
static char rcsid[] = "$Id: jbmr.w,v 1.30 96/05/21 12:24:30 neto Exp $";
d1222 1
a1222 1
			base_scheme[6] = 0;
d1229 1
a1229 1
			base_scheme[6] = 1;
d1240 2
a1241 2
		base_scheme[6] = 2;
		is_illegal = tour_inorder(t[1],t[2],t2ip1,t2ip2); 
d1252 1
a1252 1
			base_scheme[6] = 5;
d1265 1
a1265 1
			base_scheme[6] = 7;
d1275 1
a1275 1
			base_scheme[6] = 8;
d1286 1
a1286 1
			base_scheme[6] = 9;
d1579 1
a1579 1
			base_scheme[8] = 2;
@


1.31
log
@Fixed mistake in analysis of scheme 11 that lead to bad flips.
@
text
@d387 5
a391 1
	else return tour_between(b,d,c);
d739 1
a739 1
		printf("**  improve by " length_t_spec " units\n",best_gain);
d993 1
a993 1
printf("->\r");
d1270 1
a1270 1
	case 8: 
@


1.30
log
@Fixed log comments.
All initial 3-changes are checked for feasibilty before we commit to
adding them.
For 4-changes, we perform the feasibility checks that are possible
with cities 1-6 before picking 7.
Added legality checks for 4-changes.
Gave intuitive-style "proofs" as to why the performed checks are necessary
and sufficient.
@
text
@d8 10
d114 1
a114 1
static char rcsid[] = "$Id: jbmr.w,v 1.29 96/05/16 15:42:54 neto Exp $";
d659 3
a661 4
1,8,6,7,
1,5,7,8,
6,2,5,7,
3,4,5,2 },
d673 1
a673 1
static int scheme_max[14] = { 8,12,16,12,4,16,12,8,8,12,16,16,12,0 };
d1245 1
a1245 1
			base_scheme[6] = 5; printf("Foobar");
d1348 1
a1348 1
Scheme 11: 18,15,26,57,25,17,68\hfil\break
d1658 1
a1658 1
static int scheme_feas_check[14][14] = {
d1670 1
a1670 1
{1,8,1,5,2,6,5,7,2,5,1,7,6,8},	/* Scheme 11 */
d1675 1
a1675 1
static int scheme_feas_n[14] = {0,0,10,6,0,8,6,0,0,6,10,14,6,0};
@


1.29
log
@Fixed stupidity with scheme 2 dating back to analysis time.
@
text
@d8 3
d15 1
a15 1
Enforce 7!=3 in scheme 2.
d18 1
a18 1
Fixed one place where |base_scheme[6]| wasn't properly being set.
d21 1
a21 1
Made base_scheme an array. Does this work?
d26 1
a26 1
(Caught a bug: need to restore old values of "base_scheme" for later
d45 1
a45 1
Made |a| the last city in |tour_inorder(a,b,c,d)|.  This is how
d104 1
a104 1
static char rcsid[] = "$Id: jbmr.w,v 1.28 96/05/16 15:31:15 neto Exp $";
d1159 14
a1172 14
Here's a question about C compilers. I've stated the tabu condition in
the positive sense.  That is, disallow conditions encapsulated in the
formula $F$.  Then I use it as |!F|.  Now, C uses short-circuiting semantics
for its logical boolean operators |||| and |&&|.  That means that the operands
are evaluated left to right, and as soon as the final value is known, then
evaluation terminates.  For example, this allows 
the following test to always proceed
without a divide by zero error:
|x==0 || y==4/x|.
Now, is the C compiler forced (say, by the ANSI standard) to 
push the negation down so that the short-circuiting
semantics of the embedded operators are always exposed?   I think so$\ldots$
See sections 7.5.4 and 7.7 in Harbison and Steele's 
\book{C: A Reference Manual}.
d1177 1
d1179 7
a1185 4
Now, the |switch| statement looks funny because all the |tour_inorder| calls
are the same.  But each branch of the switch performs different sanity checks,
and records the results in |is_illegal|.  These aren't tabu restrictions,
but just ensure that we won't try something illegal later on.
d1187 8
d1197 1
a1197 1
if ( !( 
d1203 3
a1205 2
	case 0: 
		if ( tour_inorder(t[1],t[2],t2ip2,t2ip1) ) {
d1207 5
d1214 7
a1220 1
			is_illegal = t2ip1 == t[3];
a1222 2
	case 5: base_scheme[6] = tour_inorder(t[1],t[2],t2ip2,t2ip1) ? 5 : 7; break;
	case 8: base_scheme[6] = tour_inorder(t[1],t[2],t2ip2,t2ip1) ? 8 : 9; break;
d1226 7
d1234 51
d1292 1
a1292 1
#endif
d1330 1
a1330 1
Scheme 2: 36,13,28,26,38,18\hfil\break
d1348 2
a1349 1
schemes 0, 1, 7, and 8.
d1354 2
a1355 17
{@@+ int completes_tour;
	e[BL][enbl].scheme_id = base_scheme[6];
	switch ( base_scheme[6] ) {
	case 0: completes_tour = t[2] != t2ip1 && t[1] != t2ip2; break;
	case 1: completes_tour = t[2] != t2ip2 && t[1] != t2ip1 
				&& t[4] != t2ip2 && t[1] != t2ip2; break;
	case 7: completes_tour = t[1] != t[4] && t[1] != t2ip2; break;
	case 8: completes_tour = t2ip1 != t[2] && t[1] != t2ip2; break;
	case 2: 
	case 5: 
	case 9: 
		completes_tour = 0; break;
	default: errorif(1,"Non-exhaustive switch: %d", base_scheme[6] );
	}
	if ( completes_tour ) {
		@@<Set |best_gain| if this move is better@@>@@;
	}
d1529 4
a1537 3
Scheme 9 requires |8!=1|, but this is part of the feasibility check, so
we don't have to waste time here to do it.  We
make that the first pair to be tested in the feasibility entry for scheme 9.
d1539 12
d1564 1
a1564 1
			is_illegal = t2ip1 == t[3];
d1567 2
d1574 2
d1579 2
d1583 3
a1585 3
	case 9: 
		if ( tour_inorder(t[1],t[2],t2ip1,t[4]) ) {
			if ( tour_inorder(t[1],t[2],t2ip2,t2ip1) ) {
d1587 6
a1592 1
			} else {
d1595 3
d1599 16
a1614 2
		} else {
			base_scheme[8] = tour_inorder(t[4],t[3],t2ip1,t2ip2) ? 11 : 12; 
@


1.28
log
@Added missing initial flip to scheme 2 (transcribing problem).
@
text
@d8 3
d101 1
a101 1
static char rcsid[] = "$Id: jbmr.w,v 1.27 96/05/16 15:25:20 neto Exp $";
d593 1
a593 1
5,4,7,6,
d595 1
a595 1
8,7,6,3,
d1542 1
a1542 1
{3,6,1,3,2,8,2,6,3,8,1,8,4,7},	/* Scheme 2 */
d1556 1
a1556 1
static int scheme_feas_n[14] = {0,0,14,6,0,8,6,0,0,6,10,14,6,0};
@


1.27
log
@Enforce 7!=3 in scheme 2.
@
text
@d8 3
d98 1
a98 1
static char rcsid[] = "$Id: jbmr.w,v 1.26 96/05/16 15:10:02 neto Exp $";
d590 1
d658 1
a658 1
static int scheme_max[14] = { 8,12,12,12,4,16,12,8,8,12,16,16,12,0 };
d1539 1
a1539 1
{3,6,1,3,2,8,2,6,3,8,1,8},	/* Scheme 2 */
d1553 1
a1553 1
static int scheme_feas_n[14] = {0,0,12,6,0,8,6,0,0,6,10,14,6,0};
@


1.26
log
@Fixed one place where base_scheme[6] wasn't properly being set.
@
text
@d8 3
d17 1
a17 1
(Caught a ubug: need to restore old values of "base_scheme" for later
d40 1
a40 1
Fixed a missing indirection error on constraints for t[7].
d95 1
a95 1
static char rcsid[] = "$Id: jbmr.w,v 1.25 96/05/16 15:01:20 neto Exp $";
d1472 8
a1479 3
	case 2: base_scheme[8] = tour_inorder(t[1],t[2],t2ip1,t2ip2) ? 2 : 3; 
printf("base_scheme[8] == %d, %d %d %d %d %d\n",base_scheme[8],t[1],t[2],t2ip1,t2ip2, enbl);
break;
@


1.25
log
@Made base_scheme an array. Does this work?
@
text
@d8 3
d92 1
a92 1
static char rcsid[] = "$Id: jbmr.w,v 1.24 96/05/16 13:40:09 neto Exp $";
d1188 4
a1191 1
	case 2: is_illegal = tour_inorder(t[1],t[2],t2ip1,t2ip2); break;
d1194 1
a1195 1
	if ( !is_illegal ) {
@


1.24
log
@Optimized scheme 3 feasibility check (now legality checks are finished sooner.)
Defensive switches: add default clause to every switch.
(Caught a ubug: need to restore old values of "base_scheme" for later
backtracking.)
@
text
@d8 6
d89 1
a89 1
static char rcsid[] = "$Id: jbmr.w,v 1.23 96/05/16 12:58:26 neto Exp $";
d658 6
a663 2
intermediate variable |base_scheme|, which is as tight a lower bound on the
final value of |scheme_id| as we can manage given the current information.
d671 1
a671 1
int scheme_id, base_scheme;
d1115 2
a1116 2
	case 0: base_scheme = tour_inorder(t[1],t[2],t2ip1,t[3]) ? 0 : 2; break;
	case 4: base_scheme = tour_inorder(t[1],t[2],t2ip1,t[4]) ? 5 : 8; break;
d1119 1
d1174 1
a1174 1
	switch( base_scheme ) {
d1177 1
a1177 1
			base_scheme = 0;
d1179 1
a1179 1
			base_scheme = 1;
d1183 2
a1184 2
	case 5: base_scheme = tour_inorder(t[1],t[2],t2ip2,t2ip1) ? 5 : 7; break;
	case 8: base_scheme = tour_inorder(t[1],t[2],t2ip2,t2ip1) ? 8 : 9; break;
d1186 1
a1186 1
	default: errorif(1,"Non-exhaustive switch: %d",base_scheme);
d1188 1
d1198 1
a1198 1
value in |base_scheme|.
d1245 1
a1245 1
As a reminder, upon entering this code, the value of |base_scheme| is
d1255 2
a1256 2
	e[BL][enbl].scheme_id = base_scheme;
	switch ( base_scheme ) {
d1262 5
a1266 1
	default: completes_tour = 0;
d1402 1
a1402 1
	switch( base_scheme = e[1][ec[1]].scheme_id ) {
d1406 2
a1407 1
	default: errorif(1,"Got to 4-change in base scheme %d", base_scheme); break;
d1462 3
a1464 3
	switch( base_scheme ) {
	case 2: base_scheme = tour_inorder(t[1],t[2],t2ip1,t2ip2) ? 2 : 3; 
printf("base_scheme == %d, %d %d %d %d %d\n",base_scheme,t[1],t[2],t2ip1,t2ip2, enbl);
d1468 1
a1468 1
			base_scheme = 5;
d1470 1
a1470 1
			base_scheme = 6; 
d1477 1
a1477 1
				base_scheme = 9;
d1479 1
a1479 1
				base_scheme = 10; 
d1483 1
a1483 1
			base_scheme = tour_inorder(t[4],t[3],t2ip1,t2ip2) ? 11 : 12; 
d1486 1
a1486 1
	default: errorif(1,"Non-exhaustive switch: %d",base_scheme);
d1497 1
a1497 1
@@ The possible values of |base_scheme| coming into this section
d1506 2
a1507 2
sc = &scheme_feas_check[base_scheme][0];
sn = scheme_feas_n[base_scheme];
d1543 1
a1543 1
	e[BL][enbl].scheme_id = base_scheme;
@


1.23
log
@Comment about scheme 11.
@
text
@d8 3
d83 1
a83 1
static char rcsid[] = "$Id: jbmr.w,v 1.22 96/05/16 12:47:18 neto Exp $";
d1107 1
d1175 1
d1446 3
a1448 1
	case 2: base_scheme = tour_inorder(t[1],t[2],t2ip1,t2ip2) ? 2 : 3; break;
d1469 1
d1505 1
a1505 1
{3,6,3,8,1,8},	/* Scheme 3 */
@


1.22
log
@Fixed scheme 10.
@
text
@d8 3
d80 1
a80 1
static char rcsid[] = "$Id: jbmr.w,v 1.21 96/05/16 12:36:15 neto Exp $";
d499 4
a502 2
specifically, in schemes 1 and 8.
THINK ABOUT THIS MORE CAREFULLY IN THE t[7] case.
@


1.21
log
@Fixed scheme 9, including an errant last move in the sequence of lflips.
@
text
@d8 3
d77 1
a77 1
static char rcsid[] = "$Id: jbmr.w,v 1.20 96/05/16 12:03:39 neto Exp $";
d1447 6
a1452 1
			base_scheme = tour_inorder(t[1],t[2],t2ip2,t2ip1) ? 9 : 10; 
@


1.20
log
@Fixed scheme 6.
@
text
@d8 3
d74 1
a74 1
static char rcsid[] = "$Id: jbmr.w,v 1.19 96/05/16 11:55:45 neto Exp $";
d492 3
a494 1
initial  2/3/4-change.  THINK ABOUT THIS MORE CAREFULLY IN THE t[7] case.
d605 1
a605 1
1,2,8,3 },
d1419 4
d1490 1
a1490 1
{5,8,3,8,1,3,2,8},	/* Scheme 9 */
d1497 1
a1497 1
static int scheme_feas_n[14] = {0,0,12,6,0,8,6,0,0,8,10,14,6,0};
@


1.19
log
@Fixed scheme 1 (see notes)
@
text
@d8 3
d71 1
a71 1
static char rcsid[] = "$Id: jbmr.w,v 1.18 96/05/15 14:55:21 neto Exp Locker: neto $";
d1422 1
a1422 1
	int infeasible_4_change;
d1425 8
a1432 1
	case 5: base_scheme = tour_inorder(t[1],t[2],t2ip2,t2ip1) ? 5 : 6; break;
d1441 5
a1445 3
	@@<Define |infeasible_4_change|@@>@@;
	if ( !infeasible_4_change ) {
		@@<Update |best_gain| and |e[BL]|.@@>@@;
@


1.18
log
@Made |a| the last city in |tour_inorder(a,b,c,d)|.  This is how
I use it.
@
text
@d8 4
d68 1
a68 1
static char rcsid[] = "$Id: jbmr.w,v 1.17 96/05/15 14:28:10 neto Exp $";
d1132 3
a1134 4
are the same.  There are no deep reasons for this: that's just how
the combinatorics work out.
But I prefer to keep this general structure so that I can
easily check the resulting |base_scheme| values against my notes.
d1142 1
d1144 8
a1151 1
	case 0: base_scheme = tour_inorder(t[1],t[2],t2ip2,t2ip1) ? 0 : 1; break;
d1154 1
a1154 1
	case 2: break;
d1156 1
a1156 1
	if ( base_scheme != 2 || tour_inorder(t[1],t[2],t2ip2,t2ip1) ) {
@


1.17
log
@Fixed a missing indirection error on constraints for t[7].
@
text
@d8 3
d64 1
a64 1
static char rcsid[] = "$Id: jbmr.w,v 1.16 96/05/15 14:00:11 neto Exp $";
d331 1
a331 1
|b|, do we reach |c| no later than |d|?''.
d336 2
a337 2
	if ( tour_next(a) == b ) return tour_between(a,c,d);
	else return tour_between(a,d,c);
@


1.16
log
@Print the tour when neighbour conditions not met.
@
text
@d8 3
d61 1
a61 1
static char rcsid[] = "$Id: jbmr.w,v 1.15 96/05/15 13:54:06 neto Exp $";
d1357 1
a1357 1
	if ( tour_inorder(i1,i2,t2ip1,i4) ) {
@


1.15
log
@Even more debugging output.
@
text
@d8 3
d58 1
a58 1
static char rcsid[] = "$Id: jbmr.w,v 1.14 96/05/15 13:17:34 neto Exp $";
d645 1
a645 1
@@<Print the tour@@>@@;
d1314 2
a1315 1
		printf("Neighbour conditions not met\n");
d1816 1
a1816 1
@@<Print the tour@@>=
@


1.14
log
@More debugging output.
@
text
@d8 3
d55 1
a55 1
static char rcsid[] = "$Id: jbmr.w,v 1.13 96/05/14 17:49:26 neto Exp $";
d826 4
a829 1
		if ( cum_1 <= best_gain ) break;
d1303 1
a1303 1
printf("tour_flip_arb(%d,%d,%d,%d)\n",a,b,c,d);
d1306 1
d1309 1
d1311 6
d1739 5
d1791 1
a1791 1
@@
d1794 1
d1796 7
d1805 4
a1808 1
	printf("\n");
@


1.13
log
@Added debugging output.
Somehow I'm not undoing an unsuccessful scheme.
@
text
@d8 4
d52 1
a52 1
static char rcsid[] = "$Id: jbmr.w,v 1.12 96/05/14 17:20:56 neto Exp $";
d614 5
a618 2
We will determine the final value of |scheme_id| by performing the case
analysis as in my notes.  
d620 4
a623 2
Now, it is quite tricky to do the case analysis
using shared code (this is my third rewrite!).   MOVE THIS
d626 1
a626 1
int scheme_id;
d665 1
a665 1
		printf("  improve by " length_t_spec " units\n",best_gain);
d819 1
d1003 1
a1003 8
	if ( best_scheme_id == 4 ) {
		@@<Unroll all the changes@@>@@;
		t[3] = best_exit_a; t[4] = best_exit_b;
		scheme_id = 4;
		@@<Implement |scheme_id|@@>@@;
		@@<Mark changed cities as dirty@@>@@;
		more_backtracking = 0; 
	}
d1006 16
a1076 2
@@ @@<|jbmr_run| variables@@>=
int base_scheme;
d1527 2
a1528 2
	} else { /* End of the search. */
		@@<If necessary, revert to the best generic gain@@>@@;
d1613 1
d1628 18
d1650 1
a1650 1
@@<If necessary, revert to the best generic gain@@>=
d1674 1
d1694 8
a1701 1
@@ The last piece is just unrolling the initial 2/3/4-change.
d1703 2
a1704 1
{	int j, *s = scheme[scheme_id];
d1710 1
d1715 26
d1760 1
a1760 1
	for ( i=0;i<two_i;i++) {putchar(' ');}
d1767 1
a1767 1
	for ( i=0;i<best_two_i;i++) {putchar(' ');}
a1794 1

@


1.12
log
@ID to Id
@
text
@d7 4
a10 1
$Log:	jbmr.w,v $
d12 2
a13 1
Replacd RCS Header with Id.
d48 1
a48 1
static char rcsid[] = "$Id$";
d858 1
d906 2
d1263 2
d1266 1
a1266 1
		tour_flip_arb(s[i],s[i+1],s[i+2],s[i+3]);
d1660 2
d1686 24
d1718 1
a1718 1
		if ( i%15 == 14 ) printf("\n");
@


1.11
log
@Replacd RCS Header with Id.
@
text
@d7 3
a9 1
$Log$
d11 1
d44 1
a44 1
static char rcsid[] = "$ID$";
@


1.10
log
@More RCS log stuff.
@
text
@d41 1
a41 1
static char rcsid[] = "$Header: /tsa/a0/neto/graph/tsp/lk/RCS/jbmr.w,v 1.9 96/05/14 17:18:07 neto Exp $";
@


1.9
log
@Added RCS stuff.
@
text
@d7 1
a7 1
\$Log\$
d41 1
a41 1
static char rcsid[] = "$Header$";
@


1.8
log
@Documentation changes.  Fixed bad reference to tour_flip_arb
@
text
@d7 2
d41 1
@


1.7
log
@Removed the old code.
It actually compiles with only the ANSI C long long warning.
!
@
text
@d7 1
a7 1
@@*The Lin-Kernighan algorithm.
d9 2
a10 1
Bentley, McGeoch and Rothberg description of their implementation.
d86 1
a86 1
@@*Initialization.
d409 1
a409 1
There are three kinds of constraints on the cities that we choose:
d412 4
a415 2
greater than the improvement represented by the best tour gain so far.
In terms of our program variables, |cum_gain > best_gain|.  This is
d418 2
a419 1
deep $\lambda$-change.
d423 1
a423 1
2.~The JBMR edge condition says 
d452 7
d1022 8
a1029 8
(An algorithm that never asks stupid questions is called {\sl parsimonious}.
This concept was invented by INSERT REFERENCE, and is discussed by Knuth
in section 15 of his short book {\sl Axioms and Hulls}.  It's a nice idea,
and I'm applying it here for the sake of efficiency, and perhaps efficacy.  
I'm hoping that keeping 
the interaction with the abstract tour data type to a minimum will both
speed things up, and as a long shot, improve the chances that we'll have 
less contention once this program is ported to a parallel setting.)
d1255 2
a1256 1
@@ The generic tour flipping routine |tour_flip(a,b,c,d)| requires that
d1275 2
a1276 1
@@  While we're in the groove of taking care of all these special cases, let's
d1280 3
a1282 3
It turns out that there is only one
segment, depending on which of the base schemes we're in, to which |t[7]| 
may belong.  The required conditions are as follows:
d1284 3
a1286 3
Base scheme 2: inorder(t[1],t[2],t[7],t[3])\hfil\break
Base scheme 5: inorder(t[6],t[5],t[7],t[4])\hfil\break
Base scheme 9: inorder(t[1],t[2],t[7],t[5])
d1590 1
a1590 1
	tour_arb_flip(t[1],t[two_i],t[two_i+1],t[two_i+2]);
@


1.6
log
@Completed initial recoding to do lookahead.  Will now remove the
old code.
@
text
@d338 2
a339 1
values between 0 and 12, inclusive for the initial 2/3/4-changes.  
d502 1
a502 1
static int scheme[13][16] =@@+{@@;
d576 1
a576 1
5,2,3,4 }
d578 2
d582 2
a583 2
static int scheme_max[13] = { 8,12,12,12,4,16,12,8,8,12,16,16,12 };
static int scheme_num_cities[13] = { 6,6,8,8,4,8,8,6,6,8,8,8,8 };
d1379 1
a1379 1
static int scheme_feas_check[13][14] = {
d1392 2
a1393 1
{5,8,2,5,1,8}	/* Scheme 12 */
d1396 1
a1396 1
static int scheme_feas_n[] = {0,0,12,6,0,8,6,0,0,8,10,14,6};
d1457 3
a1459 2
Now we're ready to code the greedy portion of the search.  That is, at this
level and deeper, we proceed without backtracking.   
d1461 1
a1461 1
To keep our code
d1463 2
a1464 1
next available number.   
d1472 1
d1476 1
d1487 1
d1535 2
a1536 2
		if ( (t2i1p1 == t[i] && t2ip2 == t[i+1]) 
			|| (t2i1p1 == t[i+1] && t2ip2 == t[i]) ) {
d1568 2
a1569 2
	for ( i=0, best_len = 0 ; i<en[BL] ; i++ ) {
		if ( best_len < e[BL][i].cum_gain ) {
d1571 1
a1571 1
			best_len = cum_gain;	
d1575 2
a1576 2
	t[two_i+1] = e[BL][best_i].t2ip1;
	t[two_i+2] = e[BL][best_i].t2ip2;
d1638 1
a1638 1
@@
a1668 526
@@
==========
After that, we continually seek to improve the current sequence by adding
to its end.  

We'll need to  know when to stop the tabu search.  This portion of the
search is non-backtracking.  That is, we never go back and try a different
alternative within this portion of the code.  We use the variable
|go_deeper| to indicate when we should continue looking.

Note that |c| will always be defined by the time we reach the |while|
test.  This is true because |nn_bound>0|.

@@<Search depth-first starting at |t[two_i]|@@>=
printf("---\n");
@@<Effect the changes |t[1]| through |t[two_i]|@@>@@;
{ length_t c; int tt_w_p, go_deeper;
do {
	go_deeper = 1;
	@@<Make sure |t[two_i+2]| is valid@@>@@;
    for ( nn_two_i = 0; nn_two_i < nn_bound ; nn_two_i++ ) {
		t[two_i+1] = nn_list[t[two_i]][nn_two_i];
		put_city(two_i+1);
		c = cost(t[two_i],t[two_i+1]);
		if ( cum_gain - c <= best_gain ) { go_deeper = 0; break; }@@;

		/* Now select the neighbour of |t[two_i+1]| */
		tt_w_p = tour_prev(t[two_i+1]);
		if ( tour_inorder(t[1],t[two_i],tt_w_p,t[two_i+1]) ) t[two_i+2] = tt_w_p;
		else t[two_i+2] = tour_next(t[two_i+1]);
		put_city(two_i+2);

		@@<|continue| if |(t[two_i+1],t[two_i+2])| is tabu@@>@@;

		/* Commit to this choice for |t[two_i+1]| and |t[two_i+2]|. */
		cum_gain += cost(t[two_i+1],t[two_i+2]) - c;
		tour_flip_arb(t[1],t[two_i],t[two_i+1],t[two_i+2]);
		two_i += 2;
		@@<Compute |possible_gain| and maybe update |best_gain|@@>@@;
		break;
	}
} while ( go_deeper );
}
@@<Revert to the best gain.@@>@@;


@@ We search for a candidate for |t[3]| by scanning the neighbour list of
|t[2]|, in order from nearer to farther.  The choice of |t[3]| must meet
the 1-tree condition, \ie, that $c(t_1,t_2)>c(t_2,t_3)$.  

In particular, 
this rules out the possibility of $t_3 == t_1$  because 
the cost function is symmetric.  But we don't explicitly
check for this case because it will already be trapped in the test for
the 1-tree condition, and adding the extra test will just slow down 
every iteration.  That is, it is redundant, complicates the code, and
slows things down.

The JBMR tabu rule is ``Never delete an added edge.''.  
At this stage, there are no added edges, so we can skip  this check.

@@<Search for an improving sequence beginning with |t[1],t[2]|@@>=
for ( nn[2] = 0; nn[2] < nn_bound && more_backtracking ; nn[2]++ ) {
	length_t c_23;
	t[3] = nn_list[t[2]][nn[2]];
	c_23 = cost(t[2],t[3]);
	put_city(3);
	if ( c_23 >= cum_gain ) break;
	else {
		cum_gain -= c_23;
		put_city(3);
		@@<Search for an improving sequence beginning with |t[1],t[2],t[3]|@@>@@;
		cum_gain += c_23;
	}
}

@@ Now we look for a candidate for |t[4]| amongst the neighbours of |t[3]|.

We use a greedy criterion: we prefer the farther of the two neighbours.

Remember that we never delete an added edge.  And the only edge that has
been added so far is |t[2],t[3]|, so we need only disallow |t[4]==t[2]|.

@@<Search for an improving sequence beginning with |t[1],t[2],t[3]|@@>=
{
	int t3_n[2],t3_i;
	length_t t3_l[2];
	t3_n[0] = tour_prev(t[3]);
	t3_n[1] = tour_next(t[3]);
	t3_l[0] = cost(t3_n[0],t[3]);
	t3_l[1] = cost(t3_n[1],t[3]);
	if ( t3_l[0] < t3_l[1] ) {
		int tmp; length_t tmp_l;
		tmp = t3_n[0]; t3_n[0] = t3_n[1]; t3_n[1] = tmp;
		tmp_l = t3_l[0]; t3_l[0] = t3_l[1]; t3_l[1] = tmp_l;
	}

	for ( t3_i = 0; t3_i < 2 && more_backtracking ; t3_i++ ) {
		t[4] = t3_n[t3_i];
		put_city(4);
		if ( t[4] != t[2] ) {	/* Never delete an added edge. */
			
			cum_gain += t3_l[t3_i];
			put_city(4);
			@@<Search for an improving sequence beginning with |t[1],t[2],t[3],t[4]|@@>@@;
			cum_gain -= t3_l[t3_i];
		}
	}
}


@@ The search from |t[4]| is much like the search from |t[2]|.

The only wrinkle is the the possible 3-changes (and 4-changes)
are dependent upon the ordering of |t[1],t[2],t[3],t[4]| around the
current tour.

If the order is 1243, then these first four cities define a legal 2-change.
In this case, we must prune accordingly, hence the updating of |possible_gain|.

@@<Search for an improving sequence beginning with |t[1],t[2],t[3],t[4]|@@>=
two_i = 4;
if ( tour_inorder(t[1],t[2],t[3],t[4]) ) {
#define CASE1/**/
	@@<Search |t[1],t[2],t[3],t[4]|, order important@@>@@;
#undef CASE1/**/
} else {
#define CASE2/**/	
	@@<Compute |possible_gain| and maybe update |best_gain|@@>@@;
	@@<Search |t[1],t[2],t[3],t[4]|, order important@@>@@;
#undef CASE2/**/
}

@@ This code fragment possibly updates |best_gain|.

@@<Compute |possible_gain| and maybe update |best_gain|@@>=
possible_gain = cum_gain - cost(t[two_i],t[1]);
if ( possible_gain > best_gain ) {
	best_gain = possible_gain;
	best_two_i = two_i;
}

@@ I'm using |#ifdef| to separate these cases.  I hope it isn't too hairy
to think about.

We always want to satisfy the 1-tree condition, \ie,
|cum_gain > best_gain|.  We quit this loop as soon as we encounter the
first edge that violates this condition.  Because the nearest neighbour
list for a given city is in non-decreasing order, this test is just right.

@@<Search |t[1],t[2],t[3],t[4]|, order important@@>=
for ( nn[4] = 0; nn[4] < nn_bound && more_backtracking ; nn[4]++ ) {
	length_t c_45;
	t[5] = nn_list[t[4]][nn[4]];
	c_45 = cost(t[4],t[5]);
	put_city(5);
	if ( cum_gain - c_45 <= best_gain ) break;
	else {
		cum_gain -= c_45;
		put_city(5);
#ifdef CASE1/**/
		@@<Search |t[1],t[2],t[3],t[4],t[5]|, order 1234@@>@@; 
#endif
#ifdef CASE2/**/
		@@<Search |t[1],t[2],t[3],t[4],t[5]|, order 1243@@>@@;
#endif
		cum_gain += c_45;
	}
}



@@  Beware |t[1]==t[5]|. (???April)

The JBMR tabu condition is as follows:
|(t[5] == t[4] && t[6] == t[5]) || (t[5] == t[5] && t[6] == t[4])
||(t[5] == t[2] && t[6] == t[3]) || (t[5] == t[3] && t[6] == t[2])|.
However, note that |t[5]==t[5]| is redundant.  Furthermore,
the test |(t[5] == t[4] && t[6] == t[5])| always fails because 
|t[5]| is always chosen to be different from |t[4]|; we want to add the
edge |(t[5],t[4])|, and hence |t[5]| appeared on |nn_list[t[4]]|.  
So we can skip that disjunct altogther.
The final tabu condition becomes:
 | (t[6] == t[4]) ||(t[5] == t[2] && t[6] == t[3]) || (t[5] == t[3] && 
t[6] == t[2])|.

This code splits between cases 1.1 and 1.2.  The 1.1 case is handled
elsewhere.  

In the 1.2 case, we need to pick city 6 so that order 1265 holds.
Once the 6th city has been picked, we must find city 7 so that
order 1273 holds.  We use code parameterized using |i1|, |i2|, and |i4|.  
The same code is used in two other places.

@@<Search |t[1],t[2],t[3],t[4],t[5]|, order 1234@@>=
if ( tour_inorder(t[1],t[2],t[5],t[3]) ) { /* Case 1.1 */
#define CASE11/**/
	@@<|t[6]| may be either neighbour of |t[5]|@@>@@;
#undef CASE11/**/
} else {	/* Case 1.2 */
#define CASE12/**/
	int t5p = tour_prev(t[5]);
	if ( tour_inorder(t[1],t[2],t5p,t[5]) ) t[6] = t5p;
	else t[6] = tour_next(t[5]);
	put_city(6);
	if ( (t[6]==t[4]) 
	|| (t[5] == t[2] && t[6]==t[3]) || (t[5] == t[3] && t[6]==t[2]) ) {
		/* Never delete an added edge. */
	} else {
		int i1 = t[1], i2=t[2], i4=t[3];	/* Inorder constraint cities. */
		length_t c_56 = cost(t[5],t[6]);
		cum_gain += c_56;
		put_city(6);
		@@<Search |t[7]| with |t[1],t[2],t[3],t[4],t[5],t[6]|, order important@@>@@;
		cum_gain -= c_56;
	}
#undef CASE12/**/
}

@@ We prefer |t[6]| to be the farther of the two neighbours of |t[5]|.
This code is much like the code for selecting |t[4]|.

This code is only used in case 1.1. 

@@<|t[6]| may be either neighbour of |t[5]|@@>=
{
	@@<Set up neighbours of |t[5]|@@>@@;
	for ( t5_i=0; t5_i<2 && more_backtracking; t5_i++ ) {
		t[6] = t5_n[t5_i];
		put_city(6);
		@@<|continue| if |t[6],t[5]| has been added@@>@@;
		scheme_id = tour_inorder(t[1],t[2],t[6],t[5]) ? 0 : 1;
		@@<Search with this $t[1]\ldots t[6]$@@>@@;
	}
}


@@ 
@@<Set up neighbours of |t[5]|@@>=
int t5_n[2], t5_i; 
length_t t5_l[2];
t5_n[0] = tour_prev(t[5]);
t5_n[1] = tour_next(t[5]);
t5_l[0] = cost(t5_n[0],t[5]);
t5_l[1] = cost(t5_n[1],t[5]);
if ( t5_l[0] < t5_l[1] ) {
	length_t tmp_l;
	int tmp = t5_n[0]; t5_n[0] = t5_n[1]; t5_n[1] = tmp;
	tmp_l = t5_l[0]; t5_l[0] = t5_l[1]; t5_l[1] = tmp_l;
}

@@ I add braces around this |if| construct to make sure I don't 
capture an |else| anywhere.

@@<|continue| if |t[6],t[5]| has been added@@>=
{
if ( (t[6]==t[4])
	|| (t[5] == t[2] && t[6]==t[3]) || (t[5] == t[3] && t[6]==t[2]) ) 
	continue; /* Never delete an added edge. */
}

@@  This segment is used in many places where, given the first six cities,
we want to start the 
the generic
depth-first search for the rest of the $\lambda$-change.

By the time we reach this point in the program, |scheme_id| has already
been set.

@@<Search with this $t[1]\ldots t[6]$@@>=
two_i = 6;
cum_gain += t5_l[t5_i];
put_city(6);
@@<Compute |possible_gain| and maybe update |best_gain|@@>@@;
@@<Search depth-first starting at |t[two_i]|@@>@@;
cum_gain -= t5_l[t5_i];


@@ We need to find a neighbour of |t[6]|.  I have generalized this segment
so it can be used in three places.  The neighbour |t[7]| must satisfy
|tour_inorder(i1,i2,t[7],i4)|.

@@<Search |t[7]| with |t[1],t[2],t[3],t[4],t[5],t[6]|, order important@@>=
for ( nn[6] = 0; nn[6] < nn_bound && more_backtracking; nn[6]++ ) {
	length_t c_67;
	t[7] = nn_list[t[6]][nn[6]];
	put_city(7);
	c_67 = cost(t[6],t[7]);
	if ( cum_gain - c_67 <= best_gain ) break;
	else if ( tour_inorder(i1,i2,t[7],i4) ) {
		cum_gain -= c_67;
		put_city(7);
		@@<|t[8]| may be either neighbour of |t[7]|@@>@@;
		cum_gain += c_67;
	}
}

@@ This is much like the search for the |t[6]| case, but the tabu
test is a little more involved.

Again, we prefer to break the longer existing link.  This preference is
expressed in the original LK paper, at the top of page 505.

@@<|t[8]| may be either neighbour of |t[7]|@@>=
{
	int t7_n[2], t7_i; 
	length_t t7_l[2];
	t7_n[0] = tour_prev(t[7]);
	t7_n[1] = tour_next(t[7]);
	t7_l[0] = cost(t7_n[0],t[7]);
	t7_l[1] = cost(t7_n[1],t[7]);
	if ( t7_l[0] < t7_l[1] ) {
		length_t tmp_l;
		int tmp = t7_n[0]; t7_n[0] = t7_n[1]; t7_n[1] = tmp;
		tmp_l = t7_l[0]; t7_l[0] = t7_l[1]; t7_l[1] = tmp_l;
	}

	for ( t7_i=0; t7_i<2 && more_backtracking; t7_i++ ) {
		t[8] = t7_n[t7_i];
		put_city(8);
		if ( (t[8]==t[6])
		|| (t[7] == t[4] && t[8]==t[5]) || (t[7] == t[5] && t[8]==t[4])
		|| (t[7] == t[2] && t[8]==t[3]) || (t[7] == t[3] && t[8]==t[2]) )
			continue; /* Never delete an added edge. */
		else {
			two_i = 8;
			cum_gain += t7_l[t7_i];
			put_city(8);
			@@<Compute |possible_gain| and maybe update |best_gain|@@>@@;
#ifdef CASE12/**/
			scheme_id = tour_inorder(t[1],t[2],t[7],t[8]) ? 2 : 3;
#endif
#ifdef CASE211/**/
			scheme_id = tour_inorder(t[1],t[2],t[8],t[7]) ? 5 : 6;
#endif
#ifdef CASE222/**/
			if ( tour_inorder(t[1],t[2],t[7],t[4]) ) {
				scheme_id = tour_inorder(t[1],t[2],t[8],t[7]) ? 9 : 10;
			} else {
				scheme_id = tour_inorder(t[4],t[3],t[7],t[8]) ? 11 : 12;
			}
#endif
			@@<Search depth-first starting at |t[two_i]|@@>@@;
			cum_gain -= t7_l[t7_i];
		}
	}
}

@@ Now we handle the other major case, where |tour_inorder(t[1],t[2],t[4],t[3])|
holds.  Fortunately, much of the machinery at the leaves has already been
constructed.  

See my notes of March 7 and April 22 for the case analysis on this.

The last case is quite hairy, so I'll replicate the |t[6]| iteration code here.

@@<Search |t[1],t[2],t[3],t[4],t[5]|, order 1243@@>=
if ( tour_inorder(t[1],t[2],t[5],t[4]) ) {
#define CASE21/**/
	@@<Set up neighbours of |t[5]|@@>@@;
	for ( t5_i=0; t5_i<2 && more_backtracking; t5_i++ ) {
		t[6] = t5_n[t5_i];
		put_city(6);
		@@<|continue| if |t[6],t[5]| has been added@@>@@;
		if ( tour_inorder(t[1],t[2],t[6],t[5]) ) {
#define CASE211/**/
			int i1=t[6], i2=t[5], i4=t[4];
			@@<Search |t[7]| with |t[1],t[2],t[3],t[4],t[5],t[6]|, order important@@>@@;
#undef CASE211/**/
		} else {
#define CASE212/**/
			scheme_id = 7;
			@@<Search with this $t[1]\ldots t[6]$@@>@@;
#undef CASE212/**/
		}
	}
#undef CASE21/**/
} else {
#define CASE22/**/
	@@<Set up neighbours of |t[5]|@@>@@;
	for ( t5_i=0; t5_i<2 && more_backtracking; t5_i++ ) {
		t[6] = t5_n[t5_i];
		put_city(6);
		@@<|continue| if |t[6],t[5]| has been added@@>@@;
		if ( tour_inorder(t[1],t[2],t[6],t[5]) ) {
#define CASE221/**/
			scheme_id = 8;
			@@<Search with this $t[1]\ldots t[6]$@@>@@;
#undef CASE221/**/
		} else {
#define CASE222/**/
			int i1=t[1], i2=t[2], i4=t[5];
			@@<Search |t[7]| with |t[1],t[2],t[3],t[4],t[5],t[6]|, order important@@>@@;
#undef CASE222/**/
		}
	}
#undef CASE22/**/
}


@@*Generic depth-first LK search.
Here's the inner loop of Lin-Kernighan, but without all that backtracking
baggage.

Now, the case analysis we did to get here required that the tour remain
unchanged.  The first thing to do is effect the changes that are embodied
in the vector $t[1]\ldots t[two\_i]$ and the selector |scheme_id|.

If the initial segment is an improving 2-change, then the
rest of the sequence ought to be constrained by its improvement.   

After that, we continually seek to improve the current sequence by adding
to its end.  

We'll need to  know when to stop the tabu search.  This portion of the
search is non-backtracking.  That is, we never go back and try a different
alternative within this portion of the code.  We use the variable
|go_deeper| to indicate when we should continue looking.

Note that |c| will always be defined by the time we reach the |while|
test.  This is true because |nn_bound>0|.

@@<Search depth-first starting at |t[two_i]|@@>=
printf("---\n");
@@<Effect the changes |t[1]| through |t[two_i]|@@>@@;
{ length_t c; int tt_w_p, go_deeper;
do {
	go_deeper = 1;
	@@<Make sure |t[two_i+2]| is valid@@>@@;
    for ( nn_two_i = 0; nn_two_i < nn_bound ; nn_two_i++ ) {
		t[two_i+1] = nn_list[t[two_i]][nn_two_i];
		put_city(two_i+1);
		c = cost(t[two_i],t[two_i+1]);
		if ( cum_gain - c <= best_gain ) { go_deeper = 0; break; }@@;

		/* Now select the neighbour of |t[two_i+1]| */
		tt_w_p = tour_prev(t[two_i+1]);
		if ( tour_inorder(t[1],t[two_i],tt_w_p,t[two_i+1]) ) t[two_i+2] = tt_w_p;
		else t[two_i+2] = tour_next(t[two_i+1]);
		put_city(two_i+2);

		@@<|continue| if |(t[two_i+1],t[two_i+2])| is tabu@@>@@;

		/* Commit to this choice for |t[two_i+1]| and |t[two_i+2]|. */
		cum_gain += cost(t[two_i+1],t[two_i+2]) - c;
		tour_flip_arb(t[1],t[two_i],t[two_i+1],t[two_i+2]);
		two_i += 2;
		@@<Compute |possible_gain| and maybe update |best_gain|@@>@@;
		break;
	}
} while ( go_deeper );
}
@@<Revert to the best gain.@@>@@;

@@ Let's tackle the last step first.  
During the search we may have gone too far.  In these cases, we should
undo all the extraneous changes back to the point where only the changes
embodied in |t[1]|$\ldots$|t[best_two_i]| remain.

If no gain was found, then all the changes should be reversed.
@@<Revert to the best gain.@@>=
if ( best_gain > 0 ) {
	more_backtracking = 0;
	@@<Mark changed cities as dirty@@>@@;
	if ( best_two_i == 4 ) {	/* This is the 2-change. */
		@@<Unroll all the changes@@>@@;
		tour_flip_arb(t[1],t[2],t[3],t[4]);
	} else {
		@@<Unroll the generic changes from |two_i| back to |best_two_i|@@>@@;
	}
} else {	/* Reverse all changes. */
	@@<Unroll all the changes@@>@@;
}

@@
@@<Unroll all the changes@@>=
best_two_i = scheme_num_cities[scheme_id]; /* this must go */
@@<Unroll the generic changes from |two_i| back to |best_two_i|@@>@@;
@@<Unroll the scheme changes@@>@@;


@@ To unroll the changes, we do the above in reverse order.
@@<Unroll the generic changes from |two_i| back to |best_two_i|@@>=
{
	int j;
	for ( j=two_i ; j>best_two_i ; j-=2 ) {
printf("U Flip t%d t%d t%d t%d\n",1,j,j-1,j-2);
		tour_flip_arb(t[1],t[j],t[j-1],t[j-2]);
	}
}


@@ The following fragment for checks for a tabu move.
A move is tabu if it deletes an already-added edge.

We don't include the ``phantom edge'' in this comparison.

We do this in reverse order because |(a,b)| will already share
one of it endpoints with the last added edge.  The only difficulty is
making sure that we begin the loop with |i| equal to an even index.

@@<|continue| if |(t[two_i+1],t[two_i+2])| is tabu@@>=
{ int i, ttip1 = t[two_i+1], ttip2 = t[two_i+2], tabu = 0;
for ( i=two_i; i >= 2 ; i -=2 ) {
	if ( (ttip1 == t[i] && ttip2==t[i+1]) 
		|| (ttip2 == t[i] && ttip1==t[i+1]) ) {
		tabu = 1; 
		break;
	}
}
if ( tabu ) continue;
}

@@ We effect the changes found up to |t[two_i]| in sequential order.
Not that this section is used only twice, and that in each case,
|two_i >= 4|

@@<Effect the changes |t[1]| through |t[two_i]|@@>=
{
	int j;
	for ( j=2 ; j<two_i ; j+=2 ) {
printf("E Flip t%d t%d t%d t%d\n",1,j,j+1,j+2);
		tour_flip_arb(t[1],t[j],t[j+1],t[j+2]);
	}
}

@


1.5
log
@Now using Lookahead as in section 2B of LK paper.  I haven't started
the greedy search yet.
@
text
@d4 2
a5 2
\def\emphpar#1{{\medskip\narrower\relax #1\medskip}}
\def\book#1{\sl #1}
d408 1
a408 1
\emphpar{
d415 1
d417 1
d422 1
d424 1
d430 1
d432 1
d440 1
d442 1
d444 2
a445 1
are checked as they are generated, just like for the other two conditions.}
d590 1
a590 1
using shared code (this is my third rewrite!).  
d727 1
a727 1
eligible_t e[4][];
d968 4
a971 1
		tour_flip_arb(t[1],t[2],best_exit_a,best_exit_b);
d976 9
d1020 1
a1020 1
	switch( e[0][en[0]].scheme_id ) {
d1057 1
a1057 1
$$|x==0 || y==4/x|$.
d1060 1
a1060 1
semantics of the embedded operators are always exposed?   I think so$\LDOTS$
d1125 1
a1125 1
\emphpar{\noindent
d1152 1
a1152 1
	en[BL][enbl] = base_scheme;
d1182 2
a1183 2
		@@<Implement |this_move->scheme_id|@@>@@;
#define BL_PREV 1
a1184 1
#undef BL_PREV 1
d1208 6
a1213 3
best gain discovered so far.  So to ensure that the best sequence is a 
prefix of the latest deep search, we need only check |best_exit_a| and
|best_exit_b| against |t[5]| and |t[6]|, respectively.
d1219 1
a1219 1
		@@<Unroll all the generic changes@@>@@;
d1222 3
a1224 2
		this_move->scheme_id = best_scheme_id; /* Other fields are invalid! */
		@@<Implement |this_move->scheme_id|@@>@@;
d1226 1
d1234 3
a1236 3
@@<Implement |this_move->scheme_id|@@>=
{@@+int i, n=scheme_max[this_move->scheme_id], *s = &scheme[this_move->scheme_id][0];
	for (i=0;i<n;i++) {
d1241 19
d1267 1
a1267 1
\emphpar{
d1270 1
a1270 1
Base scheme 9: inorder(t[1],t[2],t[7],t[5])\hfil\break
a1271 1

a1277 1
@@
d1282 1
a1282 1
	switch( base_scheme = e[1][en[1]].scheme_id ) {
d1288 1
a1288 1
	if ( tour_inorder(i1,i2,t21p1,i4) ) {
d1301 3
a1303 3
\emphpar{ 
|(t[7] == t[6] && t[8] == t[7]) || (t[7] == t[7] && t[8] == t[6])|@@;
|||(t[7] == t[4] && t[8] == t[5]) || (t[7] == t[5] && t[8] == t[4])|@@;
d1312 3
a1314 2
|(t[8] == t[6])|@@;
|||(t[7] == t[4] && t[8] == t[5]) || (t[7] == t[5] && t[8] == t[4])|@@;
d1344 1
a1344 1
			base_scheme = tour_inorder(t[4],t[3],t2ip1,t2ip8) ? 11 : 12; 
d1355 1
a1355 1
@@ The possible values of |this_move->scheme_id| coming into this section
d1376 3
a1378 3
static int scheme_feas_check[][] = {
{},	/* Scheme 0; not used */
{},	/* Scheme 1; not used */
d1381 1
a1381 1
{},	/* Scheme 4; not used */
d1384 2
a1385 2
{},	/* Scheme 7; not used */
{},	/* Scheme 8; not used */
d1390 1
a1390 1
}
d1422 2
a1423 2
	@@<Implement |this_move->scheme_id|@@>@@;
#define BL_PREV 2
a1425 1
#undef
d1442 1
a1442 1
		@@<Unroll all the generic changes@@>@@;
d1445 3
a1447 2
		this_move->scheme_id = best_scheme_id; /* Other fields are invalid! */
		@@<Implement |this_move->scheme_id|@@>@@;
d1458 1
a1458 2
next available number.   However, |BL_PREV| is set to the level from
which we came.   
d1462 1
a1462 1
flips we perform here are all of a regular form involving only |t[1]|,
d1467 1
d1473 3
a1475 3
		
	} else {
		@@<Revert to the best gain, but not if a 2-change@@>@@;
d1485 3
d1490 1
d1514 2
a1515 1
So the quadratic behaviour for large $N$ is actually fatal.   So I {\it
d1519 2
d1523 14
a1536 1
{int i;
d1538 7
d1547 114
d1703 1
a1703 1
@@<Revert to the best gain@@>@@;
d2112 1
a2112 1
@@<Revert to the best gain@@>@@;
d2120 1
a2120 1
@@<Revert to the best gain@@>=
d2131 1
a2131 1
	@@<Unroll all changes@@>@@;
d2135 1
a2135 1
@@<Unroll all changes@@>=
a2150 7
@@
@@<Unroll the scheme changes@@>=
{	int j, *s = scheme[scheme_id];
	for ( j=scheme_max[scheme_id]-4;j>=0;j-=4) {
		tour_flip_arb(t[s[j]],t[s[j+3]],t[s[j+2]],t[s[j+1]]);
	}
}
a2186 59

@@ The generic tour flipping routine |tour_flip(a,b,c,d)| requires that
|a == tour_next(b)| and |d==tour_next(c)|.  This isn't always convenient.
So I've defined the following procedure to allow either that
condition or the condition 
|a == tour_prev(b)| and |d==tour_prev(c)|.

@@<Module subroutines@@>=
void
tour_flip_arb(int a, int b, int c, int d) {
	if ( a == tour_next(b) && d == tour_next(c) ) {
		tour_flip(a,b,c,d);
	} else if ( a == tour_prev(b) && d == tour_prev(c) ) {
		tour_flip(b,a,d,c);
	} else {
		errorif(1,"Neighbour conditions not met.");
	}
}

@@ This cities which have had their edges changed by a tour improvement
should be marked dirty.
@@<Mark changed cities as dirty@@>=
{ int i;
	for ( i=1; i<=best_two_i ; i++ ) {
		dict_insert(dirty_set,dirty_work+t[i]);
	}
}

@@
@@<Module subroutines@@>=
#define put_city(X) \
{ \
	int i;\
	int cg = cum_gain, bg = best_gain; \
	for ( i=0;i<(X);i++) {putchar(' ');}\
	printf("t%d == %d p=%d n=%d",(X),t[(X)],tour_prev(t[(X)]),tour_next(t[(X)]));\
	if (X>1) { \
		int c = cost(t[(X)-1],t[X]); \
		printf(" c(t%d,t%d)=%d",(X)-1,(X),c); \
		c = cost(t[(X)],t[1]); \ 
		printf(" c(t%d,t1)=%d",(X),c); \
	} \
	printf("\tcg %d bg %d\n",cg,bg); \
}

@@
@@<Print the tour@@>=
{ int i, c,cn;
	printf("Tour: 0");
	for ( i=0, c=0; i<n ; i++ ) {
		errorif( c == 0 && i > 0, "Not a tour");
		cn = tour_next(c);
		printf(" %d",cn);
		c = cn;
		if ( i%15 == 14 ) printf("\n");
	}
	printf("\n");
	errorif( c != 0, "Not a tour");
}
@


1.4
log
@Middle of changes to bring about the April22 analysis.
@
text
@d2 4
d15 3
d42 1
d67 2
a68 1
@@ Up front, we know we'll need interfaces to
d154 1
a154 1
@@ Cleaning up this portion is just deallocation.
d182 1
a182 1
Ok.  Here's the big enchillada.
d241 7
d275 1
a275 1
by Johnson and McGeoch.  Allocating 100 entries is a good compromise 
d279 1
a279 1
t_max_alloc = 100;
d317 2
d320 23
a342 3
along this sequence.  Note that |best_gain| and |cum_gain| are
not directly comparable.  The gain recorded in |best_gain| is
effected by the changes recorded in |t[1]| through |t[best_two_i]|.
d344 1
a344 1
We maintain the invariant that  |best_two_i<4 == (best_gain == 0)|.
a348 1
Positive values mean greater gains.
a349 1

d352 1
a352 1
int best_two_i;
d354 1
d358 5
a362 2
tabu search, and false otherwise.  This is used to escape from
various loops in this search.
d364 1
a364 1
Now, |more_backtracking| will almost be synonymous with |best_gain>=0|.  
d367 1
a367 1
segment of the |t| list is an improving (valid) 2-change, then |best_gain>=0|
d379 4
d389 3
a391 1
an index in to the |t| array that points to the active endpoint.
d393 2
a394 1
The eight-entry array |nn| is a set of cursors into nearest neighbour lists.
d407 3
a409 3
There are three kinds of constraints on the cities that we choose.

@@ First, the LK condition says that the cumulative 1-tree gain must be
d416 1
a416 1
@@ Second, the JBMR edge condition says 
d418 2
a419 2
will be checked as we generate the first 6 (or 8) cities in the |t| sequence,
and as we generate the deep portion of the $\lambda$-change.
d421 2
a422 1
@@ Third, the specified edge changes must be feasible.  That is, there must
d436 1
a436 1
are checked as they are generated, just like for the other two conditions.
d446 2
a447 1
(Maybe faster because the branches are easier to predict.)
d481 7
a487 1
scheme |s|.  The last entry of scheme |s| is in |scheme_max[s]-1|.
d489 1
a489 1
numbers is documented in the comments.
d571 1
d575 1
a575 1
be shared with other processes.
d581 1
a581 8
using shared code (this is my third rewrite!).  As knowledge of the
cases is accumulated, I will define compile-time identifiers 
|CASE|$nnnnn$, where
the $nnnnn$ segment corresponds to the case numbering.
For example,
constant |CASE22212| corresponds to case 2.2.2.1.2.
This design allows us to use common code while keeping the
cases separate.
d593 2
a594 1
tour neighbour of |t[1]|.
d608 1
d610 2
a611 2
		int tmp = t1_n[0]; t1_n[0] = t1_n[1]; t1_n[1] = tmp;
		tmp_l = t1_l[0];  t1_l[0]=t1_l[1]; t1_l[1]=tmp_l;
d614 1
a614 2
	best_gain = 0; best_two_i = 0;
	more_backtracking = 1; scheme_id = -1;
d620 1
a620 1
		@@<Search for an improving sequence beginning with |t[1],t[2]|@@>@@;
d628 894
d1638 2
a1639 1
#else
d1776 3
d1805 1
a1805 1
#ifdef CASE12
d1808 1
a1808 1
#ifdef CASE211
d1811 7
d1834 1
a1834 1
#define CASE21
d1841 1
a1841 1
#define CASE211
d1844 1
a1844 1
#undef CASE211
d1846 1
a1846 1
#define CASE212
d1849 1
a1849 1
#undef CASE212
d1852 1
a1852 1
#undef CASE21
d1854 1
a1854 1
#define CASE22
d1861 2
a1862 1
#define CASE221
d1864 1
a1864 1
#undef CASE221
d1866 1
a1866 3

		if ( tour_inorder(t[4],t[3],t[5],t[6]) 
		  && tour_inorder(t[4],t[3],t[5],t[1]) ) {
d1869 1
d1872 1
a1872 1
#undef CASE22
d1885 1
a1885 4
rest of the sequence ought to be constrained by its improvement.  After
all, the rest of the sequence 
should check 
ought to set |best_gain|.
d1928 1
d1930 7
d1940 9
a1948 2
} else best_two_i = 2;	/* For the sole purpose of unrolling the tour changes. */
@@<Unroll the changes from |two_i| back to |best_two_i|@@>@@;
d1950 25
a2008 9
@@ To unroll the changes, we do the above in reverse order.
@@<Unroll the changes from |two_i| back to |best_two_i|@@>=
{
	int j;
	for ( j=two_i ; j>best_two_i ; j-=2 ) {
printf("U Flip t%d t%d t%d t%d\n",1,j,j-1,j-2);
		tour_flip_arb(t[1],t[j],t[j-1],t[j-2]);
	}
}
@


1.3
log
@Initial implementation of LK.  This is buggy.
@
text
@d238 3
a240 3
In general, edge |(t[2i+1],t[2i+2])| is the $i$'th edge removed, and
|(t[2(i+1)],t[2(i+1)+1])| is the $i$'th edge added.  
Edge |
d245 1
a245 2
This array 1-based and is treated as a growable array that only grows by single
elements.
d254 5
a258 2
@@ The common case is for the |t| array to be
small. The average number of entries is roughly 6 --- see the chapter
d276 1
a276 1
if ( two_i+2 >= t_max_alloc ) {
d279 1
a279 1
	} while ( two_i+1 >= t_max_alloc );
d288 1
a288 1
|b|, do we reach |c| before |d|?''.
d298 1
a298 1
path} following 
d301 6
a306 5
We'll also record, in |best_gain|, the gain made by the best {\it tour}
tour along this sequence.  Note that |best_gain| and |cum_gain| are
not directly comparable.  |best_two_i| is the last city to be changed 
in the best initial portion of the sequence so far; it is always 
even.    We maintain the invariant that  |best_two_i<4 == (best_gain == 0)|.
d350 1
a350 1
We'll also use |nn_two_i| to enumerate the neighbours of |t[2*i]|.
d355 184
a538 1
@@
a541 3
See my notes of March 7 for an explanation of the case analysis involved
in cycling through all the possible 3-changes (and sometimes 4-changes).

d547 1
d564 1
a564 1
	more_backtracking = 1;
d582 3
a584 2
In particular,
this rules out the possibility of $t_3 == t_1$.  But we don't explicitly
d591 1
a591 1
At this stage, there are no added edges, so we can skip  the tabu check.
d649 3
d655 1
a655 1
#define JBMR_ORDER1234
d657 1
a657 1
#undef JBMR_ORDER1234
d659 1
d662 1
d677 1
a677 1
This is the first occurence of the 1-tree test.  We always want 
d692 2
a693 2
#ifdef JBMR_ORDER1234
		@@<Search |t[1],t[2],t[3],t[4],t[5]|, order 1234@@>@@;
d703 1
a703 1
@@  Beware |t[1]==t[5]|.
d705 3
a707 5
In the second ordering, there is only one legal choice for |t[6]|.

The tabu check would be as follows:
$$ | (t[5] == t[4] && t[6] == t[5]) || (t[5] == t[5] && t[6] == t[4])
||(t[5] == t[2] && t[6] == t[3]) || (t[5] == t[3] && t[6] == t[2])| $$
d711 2
a712 1
edge |(t[5],t[4])|.  So we can skip that disjunct altogther.
d714 2
a715 2
$$ | (t[6] == t[4]) ||(t[5] == t[2] && t[6] == t[3]) || (t[5] == t[3] && 
t[6] == t[2])| $$.
d717 2
d720 5
d726 2
a727 1
if ( tour_inorder(t[1],t[2],t[5],t[3]) ) {
d729 3
a731 1
} else {
d733 1
a733 1
	if ( tour_inorder(t[3],t[4],t5p,t[5]) ) t[6] = t5p;
a735 1
	errorif( !tour_inorder(t[3],t[4],t[6],t[5]),"Bug!");
d747 1
d753 2
d762 1
d767 1
d792 8
a799 1
@@
d810 1
a810 1
so it can be used in two places.  The neighbour |t[7]| must satisfy
d857 6
d873 1
a873 1
See my notes of March 7 for the case analysis on this.
d879 1
d886 1
d889 1
d891 2
d894 1
d897 1
d899 1
d905 6
a914 2
		} else {
			@@<Search with this $t[1]\ldots t[6]$@@>@@;
d917 1
d921 2
a922 1
@@ Here's the inner loop of Lin-Kernighan, but without all that backtracking
d927 1
a927 1
in the vector $t[1]\ldots t[two\_i]$.
d1012 1
d1022 1
d1063 6
d1070 15
@


1.2
log
@My implementation of the Johnson Bentley McGeoch and Rothberg implementation
of the Lin Kernighan algorithm.
@
text
@a34 1
@@<Module types@@>@@;
d192 1
d232 3
a234 2
@@ See the section entitled ``The Lin-Kernighan inner loop'' in the chapter
by Johnson and McGeoch for a full explanation.
d236 8
a243 3
Briefly, (and using notation stolen from that section), 
we look for a sequence of 2-opt moves in which, at each stage,
one of the edges being broken is $(t_1,t_{2i})$.
d245 4
a248 2
Also, the 1-tree obtained by adding $(t_{2i},t_{2i+1})$ must be shorter
than the best tour seen so far.
a249 2
However, we never consider deleting a previously added edge. We maintain
a dictionary for this purpose.
a250 2
We maintain the set of improving moves in an ordered dictionary |moves|
indexed by the subscript |i| as in the second paragraph of this section.
d253 1
a253 1
dict_t *moves;
d255 4
a258 3
@@ A move is just a specification of two edges to delete and two edges to
add.  I specify these in the same way that |tour_flip| wants them.  But to
keep them in order, I also store an index.
d260 3
a262 5
@@<Module types@@>=
typedef struct {
	int ordinal;
	int a, b, c, d;
} move_t;
a263 4
@@ 
@@<|jbmr_run| variables@@>=
int num_moves;

d265 2
a266 5
@@<Module subroutines@@>=
static int
cmp_moves(const void *a, const void *b) {
    return (((move_t *)a)->ordinal)-(((move_t *)b)->ordinal);
}
d268 11
a278 4
static void 
prn_move(void *p) {
	move_t *m = (move_t *)p;
    printf("move{ord=%d (%d %d %d %d)}",m->ordinal,m->a,m->b,m->c,m->d);
a280 1
@@ We'd like to have a move allocator and deallocator.
d282 5
a286 1
We may want to do more here if profiling shows that it would help.
d289 4
a292 9
move_t *
new_move(int ordinal,int a, int b, int c, int d) {
	move_t *r = new_of(move_t);
	r->ordinal = ordinal;
	r->a = a;
	r->b = b;
	r->c = c;
	r->d = d;
	return r;
d295 3
a297 4
void *
del_move(void *p) {
	free_mem(p);
}
d299 5
d305 2
a306 1
@@ We allocate the |moves| set on each call to |jbmr_run|.
d308 1
a308 3
@@<Allocate |jbmr_run| sets and arrays@@>=
moves = dict_create(cmp_moves,prn_move);
num_moves = 0;
d310 1
a310 1
@@ We need a set of added edges.  
d312 2
a313 1
dict_t *added_set;
d315 37
d353 2
a354 2
@@<Allocate |jbmr_run| sets and arrays@@>=
added_set = dict_create(cmp_edges,prn_edge);
d356 2
a357 1
@@ We need the edge comparison and printing functions.
d359 3
a361 1
Edges will always be stored in lexicographic order.
d363 15
a377 4
@@<Module types@@>=
typedef struct {
	int from, to;
} edge_t;
d379 36
a414 8
@@  We need to define the comparison and printing routines.
@@<Module subroutines@@>=
static int
cmp_edges(const void *a, const void *b) {
	int aa = ((edge_t*)a)->from;
	int ba = ((edge_t*)b)->from;
	if ( aa < ba ) return -1;
	else if ( aa > ba ) return 1;
d416 4
a419 3
		int ab = ((edge_t*)a)->to;
		int bb = ((edge_t*)b)->to;
		return ab-bb;
d423 32
a454 3
static void 
prn_edge(void *a) {
    printf("%x = edge{%d %d}",a,((edge_t *)a)->from,((edge_t *)a)->to);
d458 131
d590 32
a621 1
@@<Search for an improving sequence starting at |*dirty|@@>=
d623 28
a650 1
	printf("Search for an improvement starting at city %d\n",*dirty);
d653 3
d657 1
a657 3
@@ We'll need an array to remember the sequence of cities in the LK change.
I follow the notation introduced by Lin and Kernighan and use a 1-based
array named |t|.
d659 1
a659 8
For example, |t[1]| is the anchor to the Hamiltonian path, and |(t[1],t[2])|
is the first edge removed, and  |(t[2],t[3])| is the first edge added.
In general, edge |(t[2i+1],t[2i+2])| is the $i$'th edge removed, and
|(t[2(i+1)],t[2(i+1)+1])| is the $i$'th edge added.  
Edge |
|(t[2i],t[1])| is always a ``phantom'' edge, \ie, it is the edge which 
completes the Hamiltonian path to a Hamiltonian cycle, but is never drawn
in the descriptions of the LK algorithm.
d661 172
@


1.1
log
@Initial revision
@
text
@d19 10
d35 1
a36 1
@@<Global variables@@>@@;
a46 1
#include <assert.h>
d75 288
@
