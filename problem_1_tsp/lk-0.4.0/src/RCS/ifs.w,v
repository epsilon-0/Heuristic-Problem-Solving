head	1.19;
access;
symbols
	zero-four-zero:1.19;
locks
	neto:1.19; strict;
comment	@ @;


1.19
date	98.07.16.21.58.55;	author neto;	state Exp;
branches;
next	1.18;

1.18
date	97.09.27.18.06.44;	author neto;	state Exp;
branches;
next	1.17;

1.17
date	97.08.15.20.18.25;	author neto;	state Exp;
branches;
next	1.16;

1.16
date	97.05.16.20.41.22;	author neto;	state Exp;
branches;
next	1.15;

1.15
date	97.02.19.17.50.35;	author neto;	state Exp;
branches;
next	1.14;

1.14
date	97.02.18.20.05.53;	author neto;	state Exp;
branches;
next	1.13;

1.13
date	97.02.18.19.16.16;	author neto;	state Exp;
branches;
next	1.12;

1.12
date	97.02.10.21.53.01;	author neto;	state Exp;
branches;
next	1.11;

1.11
date	97.02.10.21.22.29;	author neto;	state Exp;
branches;
next	1.10;

1.10
date	97.02.10.21.01.16;	author neto;	state Exp;
branches;
next	1.9;

1.9
date	97.02.10.20.57.06;	author neto;	state Exp;
branches;
next	1.8;

1.8
date	97.02.07.23.45.40;	author neto;	state Exp;
branches;
next	1.7;

1.7
date	97.02.07.22.55.40;	author neto;	state Exp;
branches;
next	1.6;

1.6
date	97.02.07.22.52.29;	author neto;	state Exp;
branches;
next	1.5;

1.5
date	97.02.07.22.36.39;	author neto;	state Exp;
branches;
next	1.4;

1.4
date	97.02.07.22.25.39;	author neto;	state Exp;
branches;
next	1.3;

1.3
date	97.02.07.20.44.03;	author neto;	state Exp;
branches;
next	1.2;

1.2
date	97.02.07.19.33.49;	author neto;	state Exp;
branches;
next	1.1;

1.1
date	97.02.07.18.43.15;	author neto;	state Exp;
branches;
next	;


desc
@Generate TSP data in TSPLIB format from iterated function systems.
@


1.19
log
@Added the LGPL notice in each file.
@
text
@



\noindent Copyright \copyright 1994, 1995, 1996, 1997, 1998 David Neto
\smallskip

\noindent 
   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Library General Public
   License as published by the Free Software Foundation; either
   version 2 of the License, or (at your option) any later version.
\smallskip

\noindent 
   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.
\smallskip

\noindent   
   You should have received a copy of the GNU Library General Public
   License along with this library; if not, write to the
   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA  02111-1307, USA.
\smallskip

\noindent   
   You may contact David Neto via email at {\tt netod@@@@acm.org}, or with
   greater latency at
\smallskip
\noindent{\obeylines
     Department of Computer Science
     University of Toronto
     10 King's College Rd.
     Toronto, Ontario
     M5S 3G4
     Canada
}
\medskip


\noindent\hbox{}\hrule\hbox{}\penalty-1000
\vskip0.5cm\relax



@@i webdefs.w

\def\mybr{\hbox{}\hfill\hbox{}\penalty-10000\relax}
\def\myverb#1{\noindent{\tt\obeyspaces\relax #1}}

% Started coding: Fri Feb  7 11:13:57 EST 1997
%from the sier.w skeleton I had already created.
{\obeylines
$Log: ifs.w,v $
Revision 1.18  1997/09/27 18:06:44  neto
Fixed RCS log behaviour.

 Revision 1.17  1997/08/15  20:18:25  neto
 Added Index major section.

 Revision 1.16  1997/05/16  20:41:22  neto
 Include <config.h>

 Revision 1.15  1997/02/19  17:50:35  neto
 Fixed the min to max for bound on number of throwaway steps.

 Revision 1.14  1997/02/18  20:05:53  neto
 Checked the section 3.8.2 of Barnsley.  I was right.

 Revision 1.13  1997/02/18  19:16:16  neto
 Added second tropical fish --- with more concentration.

 Revision 1.12  1997/02/10  21:53:01  neto
 Small formatting improvements.

 Revision 1.11  1997/02/10  21:22:29  neto
 Use psfig instead of psbox.
 psbox trashes the TOC somehow.  psfig does not.

 Revision 1.10  1997/02/10  21:01:16  neto
 Improved index entry for Barnsley.

 Revision 1.9  1997/02/10  20:57:06  neto
 Light editing, and added tropical fish.

 Revision 1.8  1997/02/07  23:45:40  neto
 Added a couple of figures.
 Formatting is still stinky.

 Revision 1.4  1997/02/07  22:25:39  neto
 Finished initial coding.  Need to compile and read for English.

 Revision 1.3  1997/02/07  20:44:03  neto
 More typeing.\

 Revision 1.2  1997/02/07  19:33:49  neto
 More writing and editing.

 Revision 1.1  1997/02/07  18:43:15  neto
 Initial revision

}

@@*Introduction.
This program generates geometric 
traveling salesman problem (TSP) data based on 
Iterated Function Systems (IFS).
See the development in Michael F.~Barnsley's {\sl Fractals Everywhere}, 
@@^Barnsley, Michael Fitzgerald@@>
Academic
Press, 1988, or in Kenneth Falconer's 
{\sl Fractal Geometry: Mathematical Foundations and Applications}, John Wiley
and Sons, 1990.
@@^Falconer, Kenneth@@>

The TSP data is output in the TSPLIB format.  For a description of this simple
data exchange format,
consult the online TSPLIB world wide web home pages at
{\tt http://www.iwr.uni-heidelberg.de:80/iwr/}\penalty-500
{\tt comopt/soft/TSPLIB95/TSPLIB.html}.
A description of an older version of the data set and format
specification is contained in Gerhard Reinelt,
``{TSPLIB} --- A Traveling Salesman Problem Library'',
{\sl ORSA Journal on Computing}, {\bf 3} (4), 1991, pp.~376--384.

@@ Heuristics, by their  very
nature, are often poorly understood.  Their asymptotic behaviour
may be very bad in the worst case but very good in practice.  
For example, although the 
Lin-Kernighan heuristic for the traveling salesman problem (TSP) 
has very bad worst case inputs, they are not encountered
in practice.   

Another example is the simplex method for solving
linear programs. There is  an infinite family of inputs that force
the simplex method 
to take an exponential number of steps.  However, despite the
availability of guaranteed-polytime methods for solving linear programs,
the simplex method is
often the method of choice because {\it in  practice\/} bad inputs for simplex 
are rarely encountered.

To understand why this kind of behaviour occurs, especially with heuristics,
we need empirical studies.    
Experiments complement the usual
``worst case'' and ``average case'' analyses, and help to fill out our
knowledge in the ``in practice''  domain.

@@ Generating varied data is fundamental to empirical studies of 
algorithms in general 
and of heuristics in particular.
It is important to use data from real applications, if available.  After
all, we'd like to solve real problems.  
But in anticipation of new (or proprietary) applications, we should also 
use artificially generated data from a wide variety of distributions.
Arguments about techniques or algorithms are more convincing when
derived from experience with many classes of data.

%%%inspire more confidence in the performance of heuristics, such
%%%as the Lin-Kernighan heuristic, or in proposed modifications to heuristics,
%%%such as my declustering transformation based on minimum spanning
%%%trees. (What a {\it terrible\/} name!)


With this computer program, I hope to generate a class of interesting TSP 
data based on iterated function systems.  
Iterated function systems can be used to generate point sets with
rich structure at many levels.  These point sets are popularly known
as ``fractals''.  In the introduction to {\sl Fractal Geometry}, Falconer
gives the following fuzzy description of a fractal:
@@^Falconer, Kenneth@@>

\medskip
\hrule
\emphpar When we refer to a set $F$ as a fractal, therefore, we will typically
have the following in mind.

\itempar{\emphitem{i}$F$ has a fine structure, 
\ie, detail on arbitrarily small scales.}
\itemskip
\itempar{\emphitem{ii}$F$ is too irregular to be described in 
traditional geometrical language.}
\itemskip
\itempar{\emphitem{iii}Often $F$ has some 
form of self-similarity, perhaps approximate or statistical.}\itemskip
\itempar{\emphitem{iv}Usually, 
the `fractal dimension' of $F$ (defined in some way)
is greater than its topological dimension.}\itemskip
\itempar{\emphitem{v}In most cases of 
interest $F$ is defined in a very simple way, 
perhaps recursively.}
\smallskip
\hrule
\medskip

For my present purposes, 
irregularity, item \emphitemnum{ii}, is useful because real life data often 
have
peculiar structure.
Self-similarity and simple characterization, items \emphitemnum{iii} 
and \emphitemnum{v}, 
are useful because they often allow programs that generate fractal data to
be short and efficient.
Item \emphitemnum{iv} is less important because the TSP is 
defined over finite data sets ---we will sample a finite number of
points from each fractal--- so (fractal) dimensionality does not come into
play.  

Similarly, because we take only finite samples, detail on arbitrarily
small scales, item \emphitemnum{i}, is less important.  
However, we must also be aware that this is a characteristic of fractal
data, although it might not appear with smaller point set samples.
% balls into bins... how often do we repeat a sequence?
In particular, detail on extremely small scales might lead to numerical
problems.  I've already encountered numerical nastiness with million-city
{\it uniform\/} geometric  TSP instances, and the problem is potentially
much worse with fractally generated data.   More importantly perhaps
is that real-life data for certain applications 
might not have detail on such a fine scale.  
The
peculiar behaviour emphasized by fractal data sets should be discounted
in these contexts.   Alternatively, one might post-process this fractal
data to get rid of the finer detail.

@@ This is a literate C program created with the help of the CWEB system.
The program is broken up into named sections, with automatically generated
numbers and cross-references.  Each section is elaborated in this text at a 
time appropriate for a person to understand what is going on. We are not
at the mercy of the compiler.

The outline of the program is as follows:

@@c
#include <config.h>
#include <stdio.h>
#include <stdlib.h>
@@<Other includes@@>@@;
@@#
@@<Type definitions@@>@@;

int main(int argc, char**argv) {
	@@<|main| variables@@>@@;
	@@<Process the command-line arguments@@>@@;
	@@<Read in the iterated function system@@>@@;
	@@<Output the preamble@@>@@;
	@@<Generate the data@@>@@;
	return 0;
}

@@  There are three mandatory command line parameters.  

The first parameter is a
seed for the pseudo-random number generator.  
It may be varied so that different data sets may be generated
from the same IFS.
I use the random number generator presented by Donald Knuth in
@@^Knuth, Donald Ervin@@>
{\sl The Stanford GraphBase}.  This generator is portable, fast, and freely
available.
The seed is a |long| integer stored in the variable |seed| and
is used to initialize 
the random number generator with the call |gb_init_rand(seed)|.

The second parameter is |n|, the number of data points to be generated.   
We vary the data set size drawn from a given IFS
to study
the scaling properties of our algorithms.

The third parameter is an instance name.

@@<Process the command-line arguments@@>=
long seed;
int n;
char *name;
if ( argc != 4 ) {
	fprintf(stderr,
		"Usage: %s <seed> <n> <name>\n",argv[0]);
	exit(1);
}
seed=atol(argv[1]);
n=atoi(argv[2]);
if ( n < 10 ) {
	fprintf(stderr,"Need at least 10 cities; only %d specified.\n",n);
	exit(2);
}
name=argv[3];
gb_init_rand(seed);

@@ We need the interface to the random number generator.
@@<Other includes@@>=
#include "gb_flip.h"	

@@ We generate data in the TSPLIB format.  This simple format allows us
to name the instance and provide a comment.  In this case, the comment
consists of the name of this program and its parameters.

Because this program generates two-dimensional Euclidean data, 
the cost function type is fixed as |EUC_2D|.  A TSP-solving program 
is free to ignore this declaration and use
any cost function on the coordinate space.  However, such 
usage should
always be reported as nonstandard, so that we don't compare
apples to oranges.

@@<Output the preamble@@>=
printf("NAME: %s\n",name);
printf("TYPE: TSP\n");
printf("COMMENT: %s %s %s %s\n",argv[0],argv[1],argv[2],argv[3]);
printf("DIMENSION: %d\n",n);
printf("EDGE_WEIGHT_TYPE: EUC_2D\n");
printf("NODE_COORD_SECTION\n");

@@ It will be helpful to have a data type describing points.  Since
we are working in two dimensions, a |point_t| is a vector of two floating
point numbers.  Since we may want to move to more dimensions later,
we parameterize everything with a compile-time constant |DIMENSIONS|.

@@d DIMENSIONS 2
@@<Type definitions@@>=
typedef double point_t[DIMENSIONS];

@@*Iterated functions systems.
An iterated function system is a (finite) collection of contractive maps.
This program deals only with the subclass of IFS over affine maps.
This subclass is still rich enough to encompass a wide range of 
fractals (see Barnsley).
@@^Barnsley, Michael Fitzgerald@@>

An affine map $(A,v)$ is a linear map, represented by a matrix $A$, 
together with
an offset vector $v$.  
Its action on a vector $u$ is $u \mapsto Au + v$.
An affine map $(A,v)$ is \term{contractive\/} if it shrinks volumes, or
equivalently, if $\size{\det(A)}<1$.


Let's define |affine_t| to be an affine transformation type.  It consists
of the array part |A| and  the vector part |v|.

@@<Type definitions@@>=
typedef struct { double A[DIMENSIONS][DIMENSIONS], v[DIMENSIONS];} affine_t;

@@
The IFS is specified on the standard input stream as a number |n_ifs|
followed by |n_ifs| affine maps.  We use |n_ifs| in allocating arrays
and in counting loops.  

The algorithm to sample from the fractal requires that
a weight be associated with each map.  
The weights are stored
in the array |weight|.
These are normalized and then
used to flip a biased coin, as we'll see.   
To implement biased coin-flipping, we use a second array, |cum_norm_weight|.
Entry |cum_norm_weight[i]| is the sum of the normalized weights of maps
0 through $i$.

Array  |map| stores the affine maps.  

@@<|main| variables@@>=
int n_ifs;
double *weight, *cum_norm_weight;
affine_t *map;

@@ We're now ready see how to read in the data.  Once we know how many
maps to expect, we allocate the arrays.    
Then we read each map and associated weight.

Each map is specified by the matrix part $A$ in row-major order 
(\ie, the column number changes
faster than the row number), followed by the vector part $v$, followed
by the map's  weight.  

The input is in freeform format, meaning whitespace may be use liberally.


@@<Read in the iterated function system@@>=
if ( 1!=scanf(" %d",&n_ifs))
	{fprintf(stderr,"IFS does not specify n_ifs, number of maps\n");exit(3);}
if ( n_ifs < 1)
	{fprintf(stderr,"Need a positive number of maps: n_ifs=%d\n",n_ifs);exit(4);}
weight=malloc(sizeof(double)*n_ifs);
cum_norm_weight=malloc(sizeof(double)*n_ifs);
map=malloc(sizeof(affine_t)*n_ifs);
if (weight==NULL||cum_norm_weight==NULL||map==NULL) 
	{fprintf(stderr,"Couldn't allocate arrays\n");exit(5);}
{ int i,j,k;
for (i=0;i<n_ifs;i++) {  /* Read map $i$. */
	for ( j=0; j<DIMENSIONS; j++) /* Read array part $A$. */
		for ( k=0; k<DIMENSIONS; k++)
			if ( 1!=scanf(" %lf",&map[i].A[j][k]) )
				{fprintf(stderr,"Couldn't read map %d array entry (%d,%d)\n",i,j,k);
				exit(6);}
	for ( j=0; j<DIMENSIONS; j++) /* Read vector part $v$. */
		if ( 1!=scanf(" %lf",&map[i].v[j]) )
			{fprintf(stderr,"Couldn't read map %d vector entry (%d)\n",i,j);
			exit(7);}
	if ( 1!=scanf(" %lf",&weight[i]) )
		{fprintf(stderr,"Couldn't read map %d weight\n",i);
		exit(8);}
}
}

@@ To generate the data, we play the ``Chaos Game'' on the IFS.  
This notion is fully 
developed in Barnsley's book;  he provides BASIC code for this
@@^Barnsley, Michael Fitzgerald@@>
in section 3.8.2.  

The implementation is quite simple.  
We start anywhere on the plane
and repeatedly apply a map at random, chosen according to their relative
weightings.  Wherever we land, we plot a point.  To get rid of the noise
introduced by the our arbitrary starting location, we skip plotting
the first few points.
The points very quickly converge to the strange attractor for the system, 
if one exists.

% density, etc.

Point |u| is the current location in space.  We start it at the origin.

@@<Generate the data@@>=
@@<Set up the biased coin@@>@@;
{int i; point_t u;
for (i=0;i<DIMENSIONS;i++) u[i]=0.0;
@@<Prime the chaos game@@>@@;
@@<Play the chaos game, with output@@>@@;
printf("EOF\n");
}

@@ Flipping a biased coin requires that we be able to invert the
cumulative probability distribution.  But first we'll have to 
find the cumulative probability distribution.  We compute that here,
and store it in |cum_norm_weight|.

I expect that number of maps will be small ---fewer than 20--- 
so it will be fine to do
a linear scan of |cum_norm_weight| to invert the cumulative distribution 
function.
@@^assumptions@@>

@@<Set up the biased coin@@>=
{int i; double total_weight=0.0, sum_weight=0.0;
for (i=0;i<n_ifs;i++)
	total_weight += weight[i];
if ( total_weight < 1e-10 )
	{fprintf(stderr,"Total weight %f is too small (less than 1e-10)\n",total_weight); exit(9);}
for (i=0;i<n_ifs;i++) {
	sum_weight+=weight[i];
	cum_norm_weight[i] = sum_weight/total_weight;
}
}

@@ To flip the biased coin, we generate a number in the uniform distribution
over $[0,1)$, and then invert the cumulative distribution.

The pseudo-random number generator provided by the Stanford GraphBase
@@^Stanford GraphBase@@>
in its raw form only provides integers in the range $0$ through $2^{31}-1$.
We normalize it to a floating point number in the range $[0,1)$ by dividing
by $2^{31}$, being careful about automatic type conversions.


If the number of maps is large, this linear  scan ought to be converted to
a binary search.

@@d two_to_the_31 ((double)0x80000000)

@@<Set |next_map| to the next biased coin flip@@>=
{
const double fair_toss=gb_next_rand()/two_to_the_31;
int i;
for (i=0;i<n_ifs && cum_norm_weight[i] < fair_toss ;i++)
	;	/* Empty body */
if ( i==n_ifs ) i--; /* Just in case |fair_toss==1.0|.  Impossible? */
next_map=i;
}



@@  
We take 2000 steps to flush out the noise caused by starting at the origin.
The number of steps we should really take is something like
$${m \over  {- \log_2 \max_i\! \size{\det(A_i)}}},$$
where $m$ is the number of bits of mantissa in type |double|; 
$m=53$ on all machines implemtenting arithmetic to the IEEE-754 floating
point standard.
@@^IEEE-754 floating point standard@@>
Two thousand
should be safe for now, though maybe I should compute this bound.

It might also be a good idea to check that every affine map in the IFS
is actually contractive.  We could give a warning if this isn't the case.
Maybe in the future.

@@<Prime the chaos game@@>=
{int i;
for (i=0;i<2000;i++) {
	@@<Take a step@@>@@;
}
}

@@ To take a step, we flip the biased coin, and move |u| accordingly.
We need a temporary variable |u_prime| so we don't prematurely
stomp on the components of |u|.
@@<Take a step@@>=
{int d,i; point_t u_prime;
@@<Set |next_map| to the next biased coin flip@@>@@;
for (d=0;d<DIMENSIONS;d++) {
	u_prime[d]=map[next_map].v[d];
	for (i=0;i<DIMENSIONS;i++)
		u_prime[d]+=map[next_map].A[d][i] * u[i];
}
for (d=0;d<DIMENSIONS;d++) u[d]=u_prime[d];
}

@@ We need to declare |next_map|.
@@<|main| variables@@>=
int next_map;

@@  Now we get to the meat of the matter.  Fortunately, the code
to play the chaos game with output is already written, save for the
bookkeeping.

We output each point with lots of unwarranted precision.  But
this data is intended for computer's eyes only, so it doesn't really
matter.

@@<Play the chaos game, with output@@>=
{int i,d;
for (i=0;i<n;i++) {
	@@<Take a step@@>@@;
	printf("%7d",i+1);	/* City numbers are 1-based in TSPLIB. */
	for (d=0;d<DIMENSIONS;d++)
		printf(" %25f",u[d]);
	printf("\n");
}
}

@@ There is one small system-dependent annoyance to take care of.
The include files for some operating systems don't define full
prototypes  for some important functions like |fprintf|.  Versions
of SunOS and IRIX have this problem.  These kinds of problems are fixed in
the file \file{fixincludes.h}, defined elsewhere.
@@^system dependencies@@>

@@<Other includes@@>=
#include "fixincludes.h"


@@*Sample input and output.
So what kind of data does this program produce?  Let's look at some examples.

@@ The fern is probably the most famous IFS.  It consists of only four maps,
yet is remarkably beautiful.  
Its specification, taken from Barnsley's book, looks like this:\mybr
@@^Barnsley, Michael Fitzgerald@@>
\myverb{4\mybr
 0     0     0    0.16 0 0    0.01\mybr
 0.85  0.04 -0.04 0.85 0 1.6  0.85\mybr
 0.2  -0.26  0.23 0.22 0 1.6  0.07\mybr
-0.15  0.28  0.26 0.24 0 0.44 0.07}

This is the output with seed 42 and 10000 samples:
\medskip
\input psfig.sty
\centerline{\psfig{figure=fern.eps}}\par


@@ Here are some systems I cobbled together in just a few minutes' fiddling
with this generator program.

The first one has two major clouds and sweeping radiating lines.
This is its input file:\mybr
\myverb{5\mybr
 0.95  0.05  0.05  1.05  0.02   0.001 0.5\mybr
-0.50 -0.20  0.10 -0.80 -0.20  -0.05 0.2\mybr
 0.38 -0.02  0.13  0.24  0.015 -0.05 0.1126\mybr
 0.01  0.05  0.03  0.05  0.015 -0.06 0.001\mybr
 0.1  0 0 1.5  -0.01 0 0.05}

Here are the first 3000 points generated using seed 42.
\medskip
\centerline{\psfig{figure=nicecloud.eps}}\par

This second one reminds me of a pair of tropical fish swimming from left
to right.  This is its data:\mybr
\myverb{9\mybr
0.000 -.3333 1 0  -0.3333 0 1\mybr
0.000 -.3333 1 0  0.3333 0 1\mybr
0.2  0 0 0.2 0 0 .5\mybr
0.15  .2 -.2 0.15 0 0 1\mybr
0.3333  0 0 0.7 -0.3333 0 1\mybr
-0.2  0.2 0 0.3333 0.7 0 1\mybr
0.6  0 0 0.3333 -0.5 .4 1\mybr
0.3333  0 0 0.3333 0.3333 .3333 1\mybr
0.25  0 0.1 0.3333 -0.25 -.4333 1}


\vbox{Here is its output: 10000 points with seed 42.
\medskip
\centerline{\psfig{figure=tropicalfish.eps}}\par}

By increasing the relative weight of the third map from $0.5$ to 10, we
emphasize the clustering of the eye and its related spots.
This is the new data:\mybr
\myverb{9\mybr
0.000 -.3333 1 0  -0.3333 0 1\mybr
0.000 -.3333 1 0  0.3333 0 1\mybr
0.2  0 0 0.2 0 0 10\mybr
0.15  .2 -.2 0.15 0 0 1\mybr
0.3333  0 0 0.7 -0.3333 0 1\mybr
-0.2  0.2 0 0.3333 0.7 0 1\mybr
0.6  0 0 0.3333 -0.5 .4 1\mybr
0.3333  0 0 0.3333 0.3333 .3333 1\mybr
0.25  0 0.1 0.3333 -0.25 -.4333 1}

\vbox{Here is its output: 10000 points with seed 42.
\medskip
\centerline{\psfig{figure=tropicalfisheye.eps}}\par}


@@*Index.
@


1.18
log
@Fixed RCS log behaviour.
@
text
@d1 48
a48 1
@@i copyrt.w
d58 3
@


1.17
log
@Added Index major section.
@
text
@d9 5
a13 1
{\obeylines$Log: ifs.w,v $
@


1.16
log
@Include <config.h>
@
text
@d10 3
d572 2
@


1.15
log
@Fixed the min to max for bound on number of throwaway steps.
@
text
@d10 3
d180 1
@


1.14
log
@Checked the section 3.8.2 of Barnsley.  I was right.
@
text
@d10 3
d427 7
a433 3
$${m \over  {- \log_2 \min_i\! \size{\det(A_i)}}},$$
where $m$ is the number of bits of mantissa in type |double|.  Two thousand
should be safe, though maybe I should compute this bound.
@


1.13
log
@Added second tropical fish --- with more concentration.
@
text
@d10 3
d347 1
a347 1
in section 3.8.2.  (CHECK THE SECTION)
@


1.12
log
@Small formatting improvements.
@
text
@d10 3
d50 1
a50 1
\& Sons, 1990.
d503 1
a503 1
@@ Here are two IFS I cobbled together in just a few minutes' fiddling
d506 1
a506 2
The first one has two major clouds, and has sweeping lines radiating
from it.
d520 1
a520 4
to right.


This is its data:\mybr
d530 1
a530 2
0.25  0 0.1 0.3333 -0.25 -.4333 1\mybr
0.3333  0 0 0.3333 0.3333 -.3333 1}
d533 1
a533 1
\vbox{And this is its output: 10000 points with seed 42.
d536 18
@


1.11
log
@Use psfig instead of psbox.
psbox trashes the TOC somehow.  psfig does not.
@
text
@d5 1
a5 1
\def\myverb#1{{\tt\obeyspaces\relax #1}}
d10 4
d484 1
a484 1
@@ Probably the most famous IFS is the fern.  It consists of only four maps,
d488 1
a488 3

\myverb{
4\mybr
d505 2
a506 4
This is its input file:

\myverb{
5\mybr
d511 1
a511 2
 0.1  0 0 1.5  -0.01 0 0.05
}
d520 3
a522 3
This is its data:
\myverb{
9\mybr
d532 1
a532 2
0.3333  0 0 0.3333 0.3333 -.3333 1\mybr
}
d535 1
a535 1
And this is its output: 10000 points with seed 42.
d537 1
a537 1
\centerline{\psfig{figure=tropicalfish.eps}}\par
@


1.10
log
@Improved index entry for Barnsley.
@
text
@a5 1
%\input psbox
d10 3
d494 2
a495 1
\centerline{\psbox{fern.eps}}
d516 1
a516 1
\centerline{\psbox{nicecloud.eps}}
d539 1
a539 1
\centerline{\psbox{tropicalfish.eps}}
@


1.9
log
@Light editing, and added tropical fish.
@
text
@d11 3
d37 1
a37 1
@@^Barnsley, Michael {F.}@@>
d254 1
a254 1
@@^Barnsley, Michael {F.}@@>
d334 1
a334 1
@@^Barnsley, Michael {F.}@@>
a479 1

d481 1
@


1.8
log
@Added a couple of figures.
formatting is a still stinky.
@
text
@d4 3
a6 2
\def\mybr{\penalty-1000\relax}
\input psbox
d11 4
a99 1
\smallskip
d124 1
a124 1
pecular structure.
d135 1
a135 1
small scales (item \emphitemnum{i}) is less important.  
d143 2
a144 2
is that real-life for certain applications 
data might not have detail on such a fine scale.  
d147 2
a148 1
in these contexts.
d256 1
a256 1
Its action on a vector $u$ is $Au + v$.
d268 2
a269 2
The IFS is specified on the standard input stream as a number $n_ifs$
followed by $n_ifs$ affine maps.  We use |n_ifs| in allocating arrays
d312 1
a312 1
for (i=0;i<n_ifs;i++) {
d336 1
a336 1
and repeatedly apply a random map at random, chosen according to their relative
d409 1
a409 1
$${m \over  {- \log_2 \min_i\! \size{det(A_i)}}},$$
d465 1
a465 1
the file \file{fixincludes.h}.
d472 2
a473 2
@@*Pretty pictures.
So what kind of data do this program output?  Let's look at some examples.
d478 3
a480 3
Its input file looks like this:
\centrepar{%
\obeylines
d482 4
a485 5
 0     0     0    0.16   0 0    0.01\mybr
 0.85  0.04 -0.04 0.85   0 1.6  0.85\mybr
 0.2  -0.26  0.23 0.22   0 1.6  0.07\mybr
-0.15  0.28  0.26 0.24   0 0.44 0.07
}
d487 1
a487 1
This is the output with seed 42 and 8000 samples:
d492 1
a492 1
@@ Here is an IFS I put together in after about 15 minutes of playing around
a493 2
It was originally intended to look a bit like the continental United States.
I suppose my skills with these things can only get better.
d495 5
a499 3
Here is its input file:
\centrepar{%
\obeylines
d508 1
a508 1
This is the output with seed 42 and 3000 samples:
d511 24
@


1.7
log
@Now it compiles.
@
text
@d4 3
d475 5
a479 5
\verb|
4
 0     0     0    0.16   0 0    0.01
 0.85  0.04 -0.04 0.85   0 1.6  0.85
 0.2  -0.26  0.23 0.22   0 1.6  0.07
d481 6
a486 1
|}
d488 4
a491 1
This is the output with seed 42 and 10000 samples.
d493 14
@


1.6
log
@After first attempt at compiling.
@
text
@a152 1
#include <math.h>
d367 1
a367 1
	cum_norm_weight = sum_weight/total_weight;
@


1.5
log
@Fixed some scanf bugs after reading the code.
Added some index entries.
@
text
@d306 3
a308 3
	for ( j=0; j<DIMENSION; j++) /* Read array part $A$. */
		for ( k=0; k<DIMENSION; k++)
			if ( 1!=scanf(" %f",&map[i].A[j][k]) )
d311 2
a312 2
	for ( j=0; j<DIMENSION; j++) /* Read vector part $v$. */
		if ( 1!=scanf(" %f",&map[i].v[j]) )
d315 1
a315 1
	if ( 1!=scanf(" %f",&weight[i]) )
d361 1
a361 1
{int i; total_weight=0.0, sum_weight=0.0;
d453 30
@


1.4
log
@Finished initial coding.  Need to compile and read for English.
@
text
@d7 3
d26 1
d31 1
d88 1
d174 1
d244 1
d289 1
a289 1
by its weight.  
d298 1
a298 1
	{fprintf(stderr,"n_ifs must be positive: given %d\n",n_ifs);exit(4);}
d308 1
a308 1
			if ( 1!=scanf(" %f",map[i].A[j][k]) )
d312 1
a312 1
		if ( 1!=scanf(" %f",map[i].v[j]) )
d315 1
a315 1
	if ( 1!=scanf(" %f",weight[i]) )
d324 1
d379 1
a379 1
by $2^31$, being careful about automatic type conversions.
d382 1
a382 1
If the number of maps is large, this linear  scan can be converted to
d402 1
a402 1
$$-{m \over  {\log_2 \min_i \size{det(A_i)}}},$$
d447 1
a447 1
	printf("%7d",i+1);	/* City number, 1-based. */
d449 1
a449 1
		printf(" %25f\n",u[d]);
@


1.3
log
@More typeing.\
@
text
@d7 3
d153 1
a244 5
In two dimensions, an affine map may be specified by six real numbers:
the four components of the matrix and the two components of the offset vector.
The algorithm we use to sample the fractal  requires 
that a real-valued positive weight be associated
with each affine map.
d247 1
a247 1
of the array part |a| and  the vector part |v|.
d250 76
a325 1
typedef struct { double a[DIMENSIONS][DIMENSIONS], v[DIMENSIONS];} affine_t;
d327 1
d329 1
a329 4
The IFS is specified on the standard input stream as an number $n_ifs$
followed by $n_ifs$ affine maps.
----
Here is the code that reads in the IFS.
a330 1
------
d332 3
a334 3
{ int i;
point_t *corner, here={0.0,0.0};
@@<Locate the corners@@>@@;
d340 20
a359 7

@@
@@<Locate the corners@@>=

if ( (corner = malloc(sizeof(point_t)*corners)) == NULL ) {
	fprintf(stderr,"Couldn't allocate an array of %d corners\n",corners);
	exit(1);
a360 4
{ const double shift=rotation*M_PI/180; /* |rotation| $2\pi / \times 180 $ */
for ( i=0;i<corners;i++ ) {
	corner[i][0] = RADIUS * cos( M_PI*2*((double)i)/corners + shift);
	corner[i][1] = RADIUS * sin( M_PI*2*((double)i)/corners + shift);
d362 24
d388 12
a399 3
@@  We take 500 steps to flush out the noise caused by starting at the origin.
If we ever have floating point numbers with more than 500 bits of mantissa,
then we should lengthen this priming stage.
d402 2
a403 1
for (i=0;i<500;i++) {
d406 1
d408 25
a433 1
@@
d435 1
d438 4
a441 1
	printf("%7d %24.19f %24.19f\n",i+1,here[0],here[1]);
a442 6

@@  Yes, it's this easy.
@@<Take a step@@>=
{const int c=gb_unif_rand(corners);
here[0] = (1-shrinkfactor) * here[0] + shrinkfactor * corner[c][0];
here[1] = (1-shrinkfactor) * here[1] + shrinkfactor * corner[c][1];
a443 8







#include "fixincludes.h"  /* Fix interface problems on some operating systems.*/
@


1.2
log
@More writing and editing.
@
text
@d7 3
d145 3
a147 3

#include "fixincludes.h"  /* Fix interface problems on some operating systems.*/
#include "gb_flip.h"	/* We need the {\sl Stanford GraphBase\/} random number generator. */
d195 4
d219 9
d229 2
a230 2
An iterated function system is a collection of contractive maps.
This program deals only with the subclass of affine maps.
d238 1
a238 1
An affine mape is contractive if it shrinks volumes, or
d241 19
a259 1
@@
a261 1
typedef double point_t[2];
d307 8
@


1.1
log
@Initial revision
@
text
@d6 4
a9 1
{\obeylines$Log$
d72 1
a72 1
based on iterated function systems.  
d124 11
a134 3
is that real-life data might not be detailed on such a fine scale.  

@@  
d136 1
a136 1
The program outline is as follows:
d143 2
a144 2
#include "fixincludes.h"
#include "gb_flip.h"
d149 1
a149 1
	@@<Output a preamble@@>@@;
d154 2
a155 1
@@  We have three mandatory command line parameters.  
d157 1
a157 2
seed for the random number generator.  
This is a |long| integer stored in the variable |seed|.  
d160 11
d172 1
a172 3
The second parameter is  the number of data points to be generated.   Varying
the data set size is useful for studying the scaling properties of 
programs.  
d176 1
a176 2

double rotation, shrinkfactor;
d178 1
a178 1
if ( argc != 7 ) {
d180 1
a180 1
		"Usage: %s <seed> <cities> <corners> <shrinkfactor> <rotation> <name>\n",argv[0]);
d184 3
a186 3
cities=atoi(argv[2]);
if ( cities < 10 ) {
	fprintf(stderr,"Need at least 10 cities; only %d specified.\n",cities);
d189 1
a189 4
corners=atoi(argv[3]);
shrinkfactor=atof(argv[4]);
rotation=atof(argv[5]);
name=argv[6];
d192 13
a204 2
@@
@@<Output a preamble@@>=
d207 2
a208 3
printf("COMMENT: %s %s %s %s %s %s %s\n",
		argv[0],argv[1],argv[2],argv[3],argv[4],argv[5],argv[6]);
printf("DIMENSION: %d\n",cities);
d212 12
a223 6
@@
An iterated function system is a collection of contractive affine maps.
An affine map is a linear map, represented by a matrix, together with
an offset vector.  It is contractive if volumes shrink under the map, or
equivalently, if the absolute value of the determinant of the linear part
is less than 1.
d263 1
a263 1
for (i=0;i<cities;i++) {
@
