head	1.159;
access
	david
	neto;
symbols
	zero-four-zero:1.159;
locks
	neto:1.159;


1.159
date	98.07.16.21.58.55;	author neto;	state Exp;
branches;
next	1.158;

1.158
date	98.02.13.21.16.55;	author neto;	state Exp;
branches;
next	1.157;

1.157
date	97.10.25.21.44.06;	author neto;	state Exp;
branches;
next	1.156;

1.156
date	97.10.25.19.49.11;	author neto;	state Exp;
branches;
next	1.155;

1.155
date	97.10.18.15.23.37;	author neto;	state Exp;
branches;
next	1.154;

1.154
date	97.10.18.14.40.25;	author neto;	state Exp;
branches;
next	1.153;

1.153
date	97.10.18.14.31.05;	author neto;	state Exp;
branches;
next	1.152;

1.152
date	97.10.17.21.48.51;	author neto;	state Exp;
branches;
next	1.151;

1.151
date	97.10.17.20.47.35;	author neto;	state Exp;
branches;
next	1.150;

1.150
date	97.09.27.18.06.44;	author neto;	state Exp;
branches;
next	1.149;

1.149
date	97.08.15.20.18.25;	author neto;	state Exp;
branches;
next	1.148;

1.148
date	97.05.16.18.11.41;	author neto;	state Exp;
branches;
next	1.147;

1.147
date	97.01.21.21.55.55;	author david;	state Exp;
branches;
next	1.146;

1.146
date	97.01.21.17.42.14;	author david;	state Exp;
branches;
next	1.145;

1.145
date	97.01.17.21.15.44;	author neto;	state Exp;
branches;
next	1.144;

1.144
date	96.12.13.15.08.17;	author neto;	state Exp;
branches;
next	1.143;

1.143
date	96.12.02.15.26.06;	author neto;	state Exp;
branches;
next	1.142;

1.142
date	96.11.11.16.36.44;	author neto;	state Exp;
branches;
next	1.141;

1.141
date	96.09.03.15.14.03;	author neto;	state Exp;
branches;
next	1.140;

1.140
date	96.08.16.13.04.53;	author neto;	state Exp;
branches;
next	1.139;

1.139
date	96.08.16.12.42.26;	author neto;	state Exp;
branches;
next	1.138;

1.138
date	96.08.15.14.20.27;	author neto;	state Exp;
branches;
next	1.137;

1.137
date	96.08.15.12.54.30;	author neto;	state Exp;
branches;
next	1.136;

1.136
date	96.07.30.17.15.34;	author neto;	state Exp;
branches;
next	1.135;

1.135
date	96.07.30.13.03.33;	author neto;	state Exp;
branches;
next	1.134;

1.134
date	96.07.30.12.59.52;	author neto;	state Exp;
branches;
next	1.133;

1.133
date	96.07.29.17.08.56;	author neto;	state Exp;
branches;
next	1.132;

1.132
date	96.07.29.16.19.56;	author neto;	state Exp;
branches;
next	1.131;

1.131
date	96.07.26.16.19.54;	author neto;	state Exp;
branches;
next	1.130;

1.130
date	96.07.26.15.41.44;	author neto;	state Exp;
branches;
next	1.129;

1.129
date	96.07.26.13.44.55;	author neto;	state Exp;
branches;
next	1.128;

1.128
date	96.07.26.13.21.36;	author neto;	state Exp;
branches;
next	1.127;

1.127
date	96.07.26.12.45.03;	author neto;	state Exp;
branches;
next	1.126;

1.126
date	96.07.25.14.02.54;	author neto;	state Exp;
branches;
next	1.125;

1.125
date	96.07.25.12.09.27;	author neto;	state Exp;
branches;
next	1.124;

1.124
date	96.07.24.15.57.27;	author neto;	state Exp;
branches;
next	1.123;

1.123
date	96.07.24.15.48.46;	author neto;	state Exp;
branches;
next	1.122;

1.122
date	96.07.24.13.51.38;	author neto;	state Exp;
branches;
next	1.121;

1.121
date	96.07.15.22.28.48;	author david;	state Exp;
branches;
next	1.120;

1.120
date	96.07.15.21.18.21;	author david;	state Exp;
branches;
next	1.119;

1.119
date	96.07.15.18.33.24;	author david;	state Exp;
branches;
next	1.118;

1.118
date	96.07.15.16.00.08;	author david;	state Exp;
branches;
next	1.117;

1.117
date	96.07.15.15.23.55;	author david;	state Exp;
branches;
next	1.116;

1.116
date	96.07.05.21.02.33;	author david;	state Exp;
branches;
next	1.115;

1.115
date	96.07.05.20.34.02;	author david;	state Exp;
branches;
next	1.114;

1.114
date	96.07.05.20.31.31;	author david;	state Exp;
branches;
next	1.113;

1.113
date	96.07.05.17.13.32;	author david;	state Exp;
branches;
next	1.112;

1.112
date	96.07.04.20.07.38;	author david;	state Exp;
branches;
next	1.111;

1.111
date	96.06.28.14.00.54;	author neto;	state Exp;
branches;
next	1.110;

1.110
date	96.06.28.12.58.29;	author neto;	state Exp;
branches;
next	1.109;

1.109
date	96.06.26.12.15.42;	author neto;	state Exp;
branches;
next	1.108;

1.108
date	96.06.26.12.08.19;	author neto;	state Exp;
branches;
next	1.107;

1.107
date	96.06.26.12.05.44;	author neto;	state Exp;
branches;
next	1.6;

1.6
date	96.06.26.12.02.28;	author neto;	state Exp;
branches;
next	1.5;

1.5
date	96.06.26.11.38.41;	author neto;	state Exp;
branches;
next	1.4;

1.4
date	96.06.26.11.36.29;	author neto;	state Exp;
branches;
next	1.3;

1.3
date	96.06.25.17.10.15;	author neto;	state Exp;
branches;
next	1.2;

1.2
date	96.06.25.16.41.37;	author neto;	state Exp;
branches;
next	1.1;

1.1
date	96.06.24.17.16.26;	author neto;	state Exp;
branches;
next	;


desc
@K-d search structure.  See Bentley's work.
@


1.159
log
@Added the LGPL notice in each file.
@
text
@


\noindent Copyright \copyright 1994, 1995, 1996, 1997, 1998 David Neto
\smallskip

\noindent 
   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Library General Public
   License as published by the Free Software Foundation; either
   version 2 of the License, or (at your option) any later version.
\smallskip

\noindent 
   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.
\smallskip

\noindent   
   You should have received a copy of the GNU Library General Public
   License along with this library; if not, write to the
   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA  02111-1307, USA.
\smallskip

\noindent   
   You may contact David Neto via email at {\tt netod@@@@acm.org}, or with
   greater latency at
\smallskip
\noindent{\obeylines
     Department of Computer Science
     University of Toronto
     10 King's College Rd.
     Toronto, Ontario
     M5S 3G4
     Canada
}
\medskip


\noindent\hbox{}\hrule\hbox{}\penalty-1000
\vskip0.5cm\relax



@@i webdefs.w
@@i types.w



{\obeylines
$Log: kdtree.w,v $
Revision 1.158  1998/02/13 21:16:55  neto
Made prototypes and function declarations match w.r.t. const.
,

Revision 1.157  1997/10/25 21:44:06  neto
Finished coding quadrant stuff (I think). Must compile and test.

Revision 1.156  1997/10/25 19:49:11  neto
Compact the code.

Revision 1.155  1997/10/18 15:23:37  neto
I had missed a swapint conversion.  Now it compiles.

Revision 1.154  1997/10/18 14:40:25  neto
Added E2 supports()

Revision 1.153  1997/10/18 14:31:05  neto
Made all floats into doubles.
Checked for CEIL 2D compliance, and added comments in key places.
Minor editing.

Revision 1.152  1997/10/17  21:48:51  neto
Removed CUTDIMEN and THISDIMEN kludge by recasting the coord 2d structure
as an array instead of two named fields.

Revision 1.151  1997/10/17  20:47:35  neto
Move short fields to end of E2 node struct.

Revision 1.150  1997/09/27 18:06:44  neto
Fixed RCS log behaviour.

Revision 1.149  1997/08/15  20:18:25  neto
Added Index major section.

Revision 1.148  1997/05/16  18:11:41  neto
Break locks by david and neto.
Include <config.h> and "lkconfig.h"

Revision 1.147  1997/01/21  21:55:55  david
Added standard copyright notice by including copyrt.w

Revision 1.146  1997/01/21  17:42:14  david
Make showing of partitioning optional.

Revision 1.145  1997/01/17  21:15:44  neto
Fixed a printing leak.

Revision 1.144  96/12/13  15:08:17  neto
Mention hypot

Revision 1.143  96/12/02  15:26:06  neto
Added copyright notice.

Revision 1.142  96/11/11  16:36:44  neto
fixed a spelling mistake.

Revision 1.141  96/09/03  15:14:03  neto
Macro for ML programming language name.

Revision 1.140  96/08/16  13:04:53  neto
Added fixincludes.

Revision 1.139  96/08/16  12:42:26  neto
Converted putchar to printf.  Otherwise, I'd never get a prototype
for SunOS' \_flusbuf.

Revision 1.138  96/08/15  14:20:27  neto
Fixed the prototype for E2\_rnn

Revision 1.137  96/08/15  12:54:30  neto
Make it pass -Wall

Revision 1.136  96/07/30  17:15:34  neto
Fixed editing bug with respect to recurse if not hidden in E2\_rnn.

Revision 1.135  96/07/30  13:03:33  neto
Fixed to compile.

Revision 1.134  96/07/30  12:59:52  neto
Added KD\_BUILD\_SMALLEST\_SEGMENT\_FIRST

Revision 1.133  96/07/29  17:08:56  neto
Fixed to compile.

Revision 1.132  96/07/29  16:19:56  neto
Added *\_rcs\_id.
Made sure RCS log is activated within this file.

Revision 1.131  96/07/26  16:19:54  neto
Report experiments with hidden bit.

Revision 1.130  96/07/26  15:41:44  neto
Added KD\_NO\_HIDDEN\_RNN\_TEST

Revision 1.129  96/07/26  13:44:55  neto
Added compile-time-option KD\_NO\_HIDDEN\_BIT

Revision 1.128  96/07/26  13:21:36  neto
Recurse in rnn ony if not hidden.

Revision 1.127  96/07/26  12:45:03  neto
Don't be preachy about recursing on largest last.

Revision 1.126  96/07/25  14:02:54  neto
Fixed some minor editing of english.
Replaced INFINITY by a computed (floating point!) upper bound.
Isolated debugging output and made it subject to verbose value and
compile-time choices.

Revision 1.125  96/07/25  12:09:27  neto
More info to catch dsj1000 bug.

Revision 1.124  96/07/24  15:57:27  neto
Removed 117 debugging output.
Made bbox checkig optional.

Revision 1.123  96/07/24  15:48:46  neto
Fixed the bbox bug.  I wasn't updating the boboounding box
on the b and c elemnts that were swapped.

Revision 1.122  96/07/24  13:51:38  neto
More debugging outupt for failure kcase on lin318

Revision 1.121  1996/07/15  22:28:48  david
Simplified the code a bit.
It fails on lin318.tsp

Revision 1.120  1996/07/15  21:18:21  david
Bounding box every 1/kd\_bucket\_skip fraction, not 1-that fraction.
Big bug removed: bounding box initialization during Dutch National Flag
problem is now fixed.  (Had max's at infinity instead of effectively
negative infinity.)
Factored the nn search in a bucket.  The general case now is free
from checking that it doesn't return the seed.  It should be faster.
Added PostScript debugging output to draw the buckets.

Revision 1.119  1996/07/15  18:33:24  david
Fixed a name of a section.
Fixed bucket search for nearer neighbour.

Revision 1.118  1996/07/15  16:00:08  david
Compiles now.  I had to add |f.i.| to many of the field names.
I also had to add $E2\_nn\_dist$ back in for the bounding box test.

Revision 1.117  1996/07/15  15:23:55  david
Give up on FRNN, ball searching for now.
We don't need them for Greedy / MF heuristic.

Revision 1.116  1996/07/05  21:02:33  david
Continued a bit on fixed radius nearest neighbours.
Added more about stack overflow.  Referenced Peyton Jones' Implementing
Functional Languages.

Revision 1.115  1996/07/05  20:34:02  david
I forgot to mention the move to using only squared distances in
nearest neighbour search.

Revision 1.114  1996/07/05  20:31:31  david
Changed $E2\_tree$ to $E2\_root$.
Implemented $unhide\_all$ and $hide\_all$.
Got started on comments about fixed radius nearest neighbour.

Revision 1.113  1996/07/05  17:13:32  david
Added some index references to people.
changed is\_internal to is\_bucket.
Worked on nearest neighbours computation.

Revision 1.112  1996/07/04  20:07:38  david
Clarify comments in first part of the document.
Make the recursive building more CWEB-like.
Finished the hiding/unhiding part, but I haven't tried compiling it.

Revision 1.111  96/06/28  14:00:54  neto
Added comments about persistence.
Fixed too-long-line for cweave.
Worked on hiding/unhiding
Added to nn.

Revision 1.110  96/06/28  12:58:29  neto
Ensure theat recursing won't break the stack.
Start work on nearest neighbour query.

Revision 1.109  96/06/26  12:15:42  neto
Made coord a static variable.

Revision 1.108  96/06/26  12:08:19  neto
Be careful with macro parameters.  Parenthesize them.

Revision 1.107  96/06/26  12:05:44  neto
This file was added after I went to 100 and above.

Revision 1.6  96/06/26  12:02:28  neto
Fixed my in-file log.  (I edited, saved, and committed the revision,
but didn't reload before the next commit...)

Revision 1.5  96/06/26  11:38:41  neto
Removed some printing clutter.

Revision 1.4  96/06/26  11:35:41  neto
Most importantly, I fixed the construction bug.  The code that was
moving equal elements to the middle did not handle the left end properly.
It was 0-based instead of being based at the real lower end: lo.

I added comments about what to do with an empty bucket, and why.

I added better paranoid checking diagnostics.

Revision 1.3  96/06/25  17:10:15  neto
Added missing break.
Fixed a swap.  Duh.
More precise output.

Revision 1.2  96/06/25  16:41:37  neto
Fixed typo in med3 computation.
Added better debugging output for paranoid.
Fails paranoid check on lin105.tsp

Revision 1.1  96/06/24  17:16:26  neto
Initial revision

}

@@s near void
@@s far int

@@*$k$-dimensional search structures.
Many geometrical algorithms can be made to run faster in practice if we
use a $k$-dimensional search structure.  Bentley (INSERT REFERENCE) has
@@^Bentley, Jon Louis@@>
shown this to be true of many algorithms related to the TSP.  

Bentley (INSERT REFERENCE) uses a $k$-d search tree over 
\term{semi-dynamic point sets}@@^semi-dynamic point sets@@>:
these are sets of points where all the points are known in advance,
and individual points may be hidden and unhidden from the queries.  

Bentley actually describes the hiding and unhiding as \term{deletion} and 
\term{undeletion}.
But as the points still remain in the structure and may be recovered, I
prefer the concept of hiding; it seems a more accurate description of
what is going on.  This is related in some ways to the notion of
persistency.
In general, we say a data structure is \term{(fully) persistent}
@@^persistence, full@@>
if we can completely recover the visible part of any of 
its old states; we say it is 
\term{partially persistent} if we may query any of its old states, but
@@^persistence, partial@@>
may update only its latest state.  Persistency 
is a hot topic in data structures, and has led to some interesting
and intuitive new algorithms (INSERT REFERENCE).
@@^Tarjan, Robert Endre@@>
@@^Sleator@@>

This module implements $k$-d trees for semi-dynamic point sets.

Actually, only one tree at a time is supported by this module.  
This is all I need (so far)
in the TSP application.  This scheme is also simpler to implement,
and it saves a lot of
parameter passing time (or indirection time) as compared with fully 
object-oriented code.  Besides, the code that Bentley describes
for his experiments in (INSERT REFERENCE) only supports one tree at a time.
%Some of his parameters and maybe even conclusions might change if he
%wrote fully object-oriented code.
%%%% Is that true?  Check C++ meaning for |static| storage class specifier
%%%% for a class member.

The outline of this module is as follows:

@@c
#include <config.h>
#include "lkconfig.h"
@@<System headers@@>@@;
@@<Early module headers@@>@@;
@@<Module headers@@>@@;

@@<Early module type definitions@@>@@;
@@<Module type definitions@@>@@;
@@<Module variables@@>@@;
@@<Global variables@@>@@;
@@<Module subroutines@@>@@;
@@<Subroutines@@>@@;
const char *kdtree_rcs_id = "$Id: kdtree.w,v 1.158 1998/02/13 21:16:55 neto Exp neto $";

@@ The exported interface is contained in the \file{kdtree.h} header file,
which has the following form.

@@(kdtree.h@@>=
extern const char *kdtree_rcs_id;
@@<Exported variables@@>@@;
@@<Exported subroutines@@>@@;

@@ To ensure consistency between the interface and the implementation,
we include our own header.
@@<Module headers@@>=
#include "kdtree.h"

@@*Interface.  
This section presents the interface to the $k$-d tree as specified by
Bentley. I have altered the names of the procedures to fit within my
naming scheme for modules.  
@@^Bentley, Jon Louis@@>

Currently this module only supports 2-dimensional point
sets with the Euclidean metric.
The names of the procedures all begin with $E2$ to reflect this fact.

The interface is as follows:

|void E2_create(tsp_instance_t *tsp)| 
creates a tree based on the TSP instance |tsp|.  
The structure is defined
in the \module{READ} module.

|void E2_destroy()| destroys the search tree.

|void E2_hide(int i)| hides point |i| from future queries (until the
next |unhide| operation).

|void E2_unhide(int i)| makes point |i| visible to future queries (until the
next |hide| operation).

|void E2_hide_all(void)| hides all points.  

|void E2_unhide_all(void)| hides all points.

|int E2_nn(int i)| returns the index of an unhidden point that is nearest
to point |i|, but is not |i| itself. If there is none, $-1$ is returned.

|int E2_nn_quadrant(int i, int q)| returns the index of an unhidden point 
in relative quadrant $q$ that is nearest
to point |i|, and is not |i| itself. If there is none, $-1$ is returned.
For example, quadrant 1 relative to point |i| is the set of all points
to the northeast of |i|.

|void E2_frnn(int i, double rad, void (*proc)(int j))| is 
a 
\term{fixed-radius nearest neighbour search}@@^fixed-radius nearest neighbour search@@>.
It calls |proc| on all points |j| that lie within |rad| units of point |i|.

The following two procedures are used to implement 
\term{sphere of influence}@@^sphere of influence@@>
computations.

|void E2_set_radius(int i, double r)| sets the radius of the 
active sphere around
point |i| to |r| units.

|void E2_ball_search(int i, void (*proc)(int j))| calls |proc| on every
point |j| in whose active sphere point |i| lies.
% The girl the boy the dog bit hit cried.
Get that?  Let's try it a different way:  this procedure determines which
points |j| have point |i| somewhere within their own (|j|'s) 
active sphere; it calls
|proc| on every such |j|.


@@<Exported subroutines@@>=
void E2_create(tsp_instance_t *tsp);
void E2_destroy(void);
void E2_hide(int i);
void E2_unhide(int i);
void E2_hide_all(void);
void E2_unhide_all(void);
int E2_nn(int i);
int E2_nn_quadrant(int i, const int q);
void E2_frnn(int i, double rad, void (*proc)(int j));
void E2_set_radius(int i, double r);
void E2_ball_search(int i, void (*proc)(int j));


@@ It is also useful to know when a 2-d trees may be used with a particular
TSP instance.
@@<Exported subroutines@@>=
int E2_supports(tsp_instance_t *tsp);


@@  These routines support TSP instances with |EUC_2D| and |CEIL_2D| cost
functions.
@@<Subroutines@@>=
int 
E2_supports(tsp_instance_t *tsp) 
{
	switch(tsp->edge_weight_type) {
	case EUC_2D:
	case CEIL_2D:
		return 1;
	default:
		return 0;
	}
}


@@ We need the interface to the \module{READ} module.  In turn,
it needs the \module{LENGTH} module.
@@<Early module headers@@>=
#include "length.h"
#include "read.h"

@@* $k$-d trees.
A $k$-d search tree is a tree over some set of points in $k$-dimensional
real-space, together with the partitioning properties given in the following
paragraphs.

Each internal node
of the tree is associated with one of the $k$ dimensions, called |cutdimen|,
and also has a real-valued
|cutvalue|.  All points in the subtree rooted at the |lo_child| have their
|cutdimen|-dimension value being no greater than |cutvalue|, and all
points in the subtree rooted at the |hi_child| have their value no less
than |cutvalue|.  

Each external node of the tree, known as a \term{bucket}@@^bucket@@>, contains all
the points that simultaneously satisfy all 
the constraints in the internal nodes on
the path from the bucket to the root.  
These are stored as indices |lo| and |hi| into |perm|, which itself is
an array holding a permutation of the point names.  The points in
that bucket are |perm[lo]| through |perm[hi-1]|.

There are other embellishments to the data structure, be we are ready to
start defining it now.

The short fields are placed at the end so all the other fields are 
word-aligned.  This may speed things up on some architectures.

@@<Module type definitions@@>=
typedef struct E2_node_s {
	@@<Other common fields@@>@@;
	union {
		struct {
			int cutdimen;
			double cutvalue;
			struct E2_node_s *lo_child, *hi_child;
			@@<Other internal node fields@@>@@;
		} i;
		struct {
			int lo, hi;
			@@<Other external node fields@@>@@;
		} e;
	} f;
	char is_bucket;
	@@<Other common short fields@@>@@;
} E2_node_t;


@@  The permutation array |perm| is visible to everyone because we might make
use of it elsewhere.

For example, I have an idea that we might get better performance if
we reorganize the data according to a space-filling curve.  
This would move together in memory those points which are close together
geographically.  I have some notions on a particular curve to follow,
and have a hunch that it provides an optimal layout, given the kind
of access pattern that Lin-Kernighan exhibits.  This would be a very
nice theorem to prove.  It's ``future work''.

I briefly mentioned this reorganization idea during my Qualifying Oral exam.
But I didn't speculate on optimality$\ldots$

@@<Global variables@@>=
int *perm;


@@ The maximum number of points allowed
in a bucket,
recorded in the variable
|kd_bucket_cutoff|,
is chosen to be a small positive integer.
Bentley found that
a value of 5 works well.  
@@^Bentley, Jon Louis@@>

Now, a cutoff of 5 works well on Bentley's implementation, which
constitutes a machine (a VAX-8550),
a compiler, and his program, \etc.
Should we use a different value 
on a modern RISC machine with a different
compiler and memory architecture?  
We may want to experiment with this value, which is why
we put it in a variable and not in a compile-time constant.
However, we use a default value of 5.

@@<Global variables@@>=
int kd_bucket_cutoff=5;

@@
@@<Exported variables@@>=
extern int kd_bucket_cutoff;




@@ Now, Bentley showed that bottom-up accesses are much faster in practice
@@^Bentley, Jon Louis@@>
than top-down searches.
In particular, his implementation performs
an all-nearest-neigbhours computation on
a point-set uniform in a square using
bottom-up accesses in
linear time, \ie, constant amortized time per lookup.  
He presents
some theoretical arguments as to why things should turn out this way.

In addition, Bentley's implementation takes only linear time to 
compute a 
nearest-neighbour tour on such distributions.
Finding such a tour
is more involved than all-nearest-neighbours because, first,
one
hides each point as it acquires a neighbour, and second, at the end of the
computation the unhidden points are likely to be far away both in the
Euclidean metric and in the tree.

In contrast, a top-down search takes at least logarithmic time on average:
one must traverse the path from the root to the bucket containing
the point.  In a tree whose arity is bounded by a constant,
the average depth of an item is at least logarithmic in the number of items.

The upshot is that we put a parent pointer in each node.

@@<Other common fields@@>=
struct E2_node_s *parent;


@@ We need a way to hide entire subtrees at a time.  This is done by
setting the |hidden| field to a true value.
An invariant we must maintain is that if a node is hidden,
then its children (if any) are also hidden.

@@<Other common short fields@@>=
#if !defined(KD_NO_HIDDEN_BIT)
char hidden;
#endif


@@ In a bottom-up search that hopes visit a sub-logarithmic number of nodes, 
we need to know when to stop climbing the tree.  This is done by checking
against a description of the bounding box of that subtree.

For example, if we desire a nearest neighbour to $i$ that we know is
within $r$ units (say, because we already have another neighbour that
is $r$ units away from $i$), then we stop once the ball of radius $r$
centred around point $i$ is fully contained by the bounding box
of the subtree.

Bentley's experiments show that things actually run faster if we only
@@^Bentley, Jon Louis@@>
occasionally compare to this box.  For speed, he suggests comparing
only at every third level in the tree.   


In terms of defining our data structure, if we compare only occasionally,
then we should store only occasionally as well.   One possible
scheme is at each level store a pointer to the corresponding bounding box;
a missing bounding box would be recorded as a |NULL| pointer.
We can store a $k$-dimensional bounding box in $2k$ words, 
and a pointer is stored in one word.
Assuming that memory allocator space overhead is negligible and that
we store a bounding box for every $s$ nodes (this is 
simpler than analysing every $s$ {\it levels}---why?),
this scheme uses $s+2k$ words where the obvious scheme would use $2sk$.
For the 2-d case and one bounding box every
three nodes, the clever scheme uses 11 words 
(two |NULL| box pointers, one valid box pointer, and one box structure)
for every 24 words 
(three box structures)
in the
original scheme.

This analysis assumes that the coordinate
type and the pointer type take the same amount of space.
Using |double| and ordinary \CEE/ pointers, this is valid 
on most 32-bit architectures.  
(Will Microsoft's |near| and |far| pointers
@@^Microsoft@@>
disappear by the time you read this?  Probably.)
I think things change on 64-bit architectures and higher, but I'm willing
to sweat the difference.

So let's go with the clever scheme.  In particular, a pointer to
a possible bounding box gets placed in each node.
Question: would I save any space if I placed them only in internal nodes?

@@<Other common fields@@>=
E2_box_t *bbox;

@@ Of course, we need a definition of a 2-d box.
@@<Early module type definitions@@>=
typedef struct {
	double xmin,xmax,ymin,ymax;
} E2_box_t;

@@ The space analysis we've done assumes that the per-box
space
overhead of the memory allocator is negligible.  This isn't the case
if we use the general purpose |malloc| and |free| routines, and
by extension, the |new_of| routine that uses them.  However, we can
make the per-box space overhead as small as we like by using the pool-oriented
allocator of module \module{POOL} and picking a suitably large
minimum block size.

@@d new_box() ((E2_box_t *)pool_alloc(box_pool))
@@d free_box(P) pool_free(box_pool,(P))


@@ Of course, we need the interface to \module{POOL}.
@@<Module headers@@>=
#include "pool.h"


@@ I'll use a global variable to keep track of the number of levels
to skip between bounding boxes.  This allows us to experiment with
different values, for example by setting it via a command-line option.
The default is Bentley's suggestion of every third level.
@@^Bentley, Jon Louis@@>

@@<Global variables@@>=
int kd_bbox_skip=3;

@@
@@<Exported variables@@>=
extern int kd_bbox_skip;

@@*The opportunity of equal elements.
Bentley experimented with various point-set distributions and discovered
@@^Bentley, Jon Louis@@>
that his implementation of $k$-d trees behaved pretty much the same way
as on sets where the points were drawn uniformly over the unit square.

When he used a simple partitioning method,
there was one glaring exception to this is rule: the ``spokes'' distribution
forced his program to touch four times as many tree nodes.  
A 2-d spokes distribution has half the points with $x=1/2$
and with $y$ chosen uniformly from $[0,1]$, and the other half of the
points with $y=1/2$ and $x$ chosen uniformly from $[0,1]$; this results
in a large ``plus'' sign: $+$.

In the $k$-d search tree 
paper, Bentley's fix (see section 7) 
was to use a more elaborate partitioning algorithm
based on a theorem of Bentley and Shamos INSERT REFERENCE (and also
described by Preparata and Shamos INSERT REFERENCE) that guarantees
the existence of a good so-called nearest neighbour
cut plane given that the point set obeys
a certain sparseness criterion.  
Given these conditions on the intput, the 
partitioning algorithm takes $O(n \log n)$ time, for fixed $k$.

However, Bentley himself admits that, although better than naive partitioning,
this elaborate partitioning scheme
is not completely robust.  In fact, Papadimitriou and Bentley INSERT REFERENCE
have shown that some inputs have {\it no\/} good nearest neighbour cut planes.


@@ I propose a different solution to this problem.  Ironically, 
it is based on observations made by Bentley  and McIlroy in 
@@^Bentley, Jon Louis@@>
@@^McIlroy, M.~Douglas@@>
``Engineering a Sort Function'', {\sl Software---Practice and Experience},
Vol 23(11), 1249--1265, November 1993.  There, they describe their
experience of writing a new library implementation of Quicksort.
@@^Quicksort@@>
(This is an excellent paper.  Go read it.)

Part of their work was to recognize the fact that it often pays
to treat specially those elements that compare equal to the pivot.
In an implementation of Quicksort, if one parititions elements into
three classes---those less than, equal to, and greater than the pivot---then
one often saves many recursive calls if a significant fraction of the
elements compare equal to the pivot.  

In fact, the spokes distribution in the $2$-d partitioning
problem exhibits exactly this
kind of behaviour: in a given dimension, half the points compare equal
to the pivot.  So I propose the same solution for the $k$-d partitioning
problem as Bentley and McIlroy describe for Quicksort:  treat equal
elements specially, by partitioning into three classes.  Bentley
and McIlroy call this \term{fat partitioning}@@^fat partitioning@@>,
and they observe that task is equivalent to Dijkstra's `Dutch National Flag'
problem.  
@@^Dijkstra, Edsger W.@@>
We'll hear more of this later when we actually do the partitioning.

To implement this, we add another child to each node.
(Is this a record?  Eight paragraphs for one variable declaration?)
@@<Other internal node fields@@>=
struct E2_node_s *eq_child;

@@ Unfortunately, there is a small fly in the ointment: what if
there are many points with exactly the same coordinates?
@@^degenerate inputs@@>
If we don't check for this problem, then we will soon come to
a point where we endlessly recurse on
the equal elements---there being no others---trying to break them into 
buckets with no more than
|kd_bucket_cutoff| points each.

The solution is to 
never flatten a dimension twice in the same path from a bucket to the
root.
This implemented by passing a bit mask down the recursion tree.


If there are a large number of points with exactly the same coordinates,
then we get poor performance on the queries.  But gee whiz, what are
we supposed to do?  You deserve what you get if you don't preprocess
the input to remove duplicates.  So there!

@@*Creating the tree.
Although we're not quite finished defining the data structure, we
now know enough about it to write most of the code that builds it.
We'll put in placeholders to be filled in later when we introduce the
necessary concepts.

Here's the outline of the creation routine.

@@<Subroutines@@>=
void
E2_create(tsp_instance_t *tsp) 
{
	errorif(!E2_supports(tsp), "2-d trees may not be used for this instance");
	@@<Allocate structures@@>@@;
	@@<Build the tree@@>@@;
}

@@
The first step is to allocate the space for the tree.  In
general, 
the 
buckets have an irregular number of items in them, so we can't 
allocate all the tree nodes in advance: we don't even know how many
we'll use.

So we'll have to settle for creating the pool within which we'll
be allocating the tree nodes.  Let's allocate them in 500-node blocks.

We also need a pool for the bounding boxes.

@@d new_node() ((E2_node_t *)(pool_alloc(node_pool)))
@@d free_node(P) pool_free(node_pool,(P))

@@<Allocate structures@@>=
node_pool = pool_create(sizeof(E2_node_t),500);
box_pool = pool_create(sizeof(E2_box_t),500);

@@ Of course, we'll need to declare these variables.
@@<Module variables@@>=
static pool_t *node_pool, *box_pool;

@@ We also need to allocate the permutation array.  
We can allocate this one all
in one swoop because it has $n$ entries, where $n$ is the number of cities.

Let's cheat a bit and initialize the array as well.  It starts out with 
the identity permutation.

@@<Allocate structures@@>=
n = tsp->n;
perm = new_arr_of(int,n);
{int i; for (i=0;i<n;i++) perm[i]=i;}

@@
@@<Module variables@@>=
static int n;

@@ We need the interface to the ordinary memory allocator.
@@<Module headers@@>=
#include "error.h"
#include "memory.h"

@@ While we're thinking about memory allocation, let's take care of 
deallocation.  

@@<Subroutines@@>=
void
E2_destroy(void) {
	pool_destroy(node_pool);
	pool_destroy(box_pool);
	box_pool = node_pool = NULL; /* Let's be defensive. */
	free_mem(perm);
	@@<Other deallocation@@>@@;
}

@@ We've used the constant |NULL|, which is written in ordinary
\CEE/ text as \hbox{|NU|}|LL|.  This constant is defined in the 
\file{stddef.h} header file.  While we're including it, let's include
some other standard header files.

@@<System headers@@>=
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include "fixincludes.h"


@@
The process of building the tree is much  like executing a Quicksort
routine.  We pick a pivot element, and then partition the points into 
three classes:
points preceding the pivot go in the |lo_child| subtree, 
points matching the pivot go in the |eq_child| subtree, and
points following the pivot go in the |hi_child| subtree.  
Then we recursively build the three subtrees.

However, the $k$-d tree-building problem has the extra complication of
picking the dimension along which we partition, |cutdimen|.  Bentley
@@^Bentley, Jon Louis@@>
suggests partitioning along the dimension which has maximum spread.
We do that here.  Note that the bookkeeping to determine spreads can
be folded into the parititioning at the previous level.

Because this process is naturally recursive, we use a separate recursive
procedure to do the dirty work.  But we must prime it with the right
arguments.  

It turns out that the range for the entire data set has already been
computed for us in the instance-reading function.  We just access those
values.

The set of values to be partitioned is specified using a closed-on-the-left
and open-on-the-right index range.

@@<Build the tree@@>=
coord = tsp->coord;
errorif(n<=0,"Need at least one point; instance has %d points",n);
E2_root = E2_build_helper(NULL,0,0,0,n,
	tsp->xmin,tsp->xmax,tsp->ymin,tsp->ymax);

@@ We need to declare the tree variable and the coordinate array variable.
The coordinates will be needed for queries later, which is why need to
keep it around on a more permanent basis.
@@<Module variables@@>=
static E2_node_t *E2_root;
static coord_2d *coord;

@@ The helper routine returns the
root of the subtree that it creates.

We are guaranteed to be given a positive number of points to partition,
so there will be at least one bucket created at this level.  So we create
it right away and fill in the common fields.

We increment the level number before testing to see whether to include
a bounding box 
because there is no sense in having a bounding box test at the root.

This invocation creates a bucket if there are few enough elements
(no more than |kd_bucket_cutoff|), or when both dimensions have already
been flattened.  The dimensions which have been flattened are recorded
in the bit vector |flat_dimen|.  Bit 0, with value $2^0=1$ is turned
on when the $x$ dimension is flattened, \ie, when one of our ancestors,
possibly this node, is an |eq_child| of a node whose cutting dimension
is the $x$ dimension.  Similarly, bit 1, with value $2^1=2$ is turned
on if the $y$ dimension is flattened.

@@<Module subroutines@@>=
static E2_node_t *
E2_build_helper(E2_node_t *parent,int flat_dimens,int level,
	int lo, int hi, 
	double xmin, double xmax, double ymin, double ymax) {
	E2_node_t *node = new_node();
	node->parent = parent;
#if !defined(KD_NO_HIDDEN_BIT)
	node->hidden = lo>=hi;
#endif
	if ( (++level % kd_bbox_skip)==0 ) {
		node->bbox = new_box();
		node->bbox->xmin = xmin;
		node->bbox->xmax = xmax;
		node->bbox->ymin = ymin;
		node->bbox->ymax = ymax;
		@@<Paranoid: check bounds@@>@@;
	} else {
		node->bbox = NULL;
	}
	if ( hi-lo <= kd_bucket_cutoff || flat_dimens == 0x03 ) {
		node->is_bucket = 1;
		node->f.e.lo = lo;
		node->f.e.hi = hi;
		@@<Fill other bucket fields@@>@@;
		@@<Make elements point to this bucket@@>@@;
	} else {
		node->is_bucket = 0;
		@@<Create three children@@>@@;
	}
	return node;
}

@@
It is possible for a node have no elements in it.  Such nodes must be buckets,
and have |hi==lo|.   The bounding box of such a bucket should not be trusted.

I could have chosen to avoid creating a node for an empty bucket, in which
case returning |NULL| would be the right answer.  However, I didn't do so
for the following reasons.

First, I didn't think of the possibility of empty buckets
before I wrote the code.  That's an honest answer.

Second, empty buckets are likely to be rare.  (I should measure this.)
So checking for a |NULL| pointer {\it every\/} time I want to visit a node
is likely to take more time overall than visiting an empty bucket.    
We can use the same simple code to cover both cases---empty and non-empty
buckets---it's just the termination test of the |for| loop.   
This shows again the benefit of treating zero as a first-class citizen
among numbers.

@@  Bottom-up searching only works if we can instantly jump to 
the right bucket.  We define an array that does this mapping for us.
@@<Make elements point to this bucket@@>=
{ int i;
for (i=lo;i<hi;i++) E2_point_to_bucket[perm[i]] = node;
}

@@ Of course, we need to declare this array.
@@<Module variables@@>=
static E2_node_t **E2_point_to_bucket;

@@ And we must allocate space for it.
@@<Allocate structures@@>=
E2_point_to_bucket = new_arr_of(E2_node_t *,n);

@@ And finally free it.
@@<Other deallocation@@>=
free_mem(E2_point_to_bucket);

@@ The recursive case is much more interesting.  It picks a cutting dimension,
finds a pivot, and then partitions.

If no dimensions have been flattened, then the
cut dimension is the one with the greatest range.
Otherwise, pick the nonflat dimension.

Exercise: Show that I could have replaced the entire |switch| statement
by the statement
|cutdimen = flat_dimens ? (xmax-xmin < ymax-ymin) : (2-flat_dimens);|.
Would it have been worth it?

@@<Create three children@@>=
{ int cutdimen=0; /* Satisfy GCC's dataflow analysis. */
switch ( flat_dimens ) {
case 0:
	if ( xmax-xmin > ymax-ymin ) cutdimen = 0;
	else cutdimen = 1;
	break;
case 1:
	cutdimen = 1;
	break;
case 2:
	cutdimen = 0;
	break;
case 3:	/* A valid |flat_dimens| value, but not here, so fall through. */@@;
default:
	errorif(1,"Invalid flat_dimens: %d", flat_dimens);
}
@@<Partition along dimension |cutdimen|@@>@@;
}

@@ Partitioning involves finding a pivot and then splitting the points into
three classes.

@@<Partition along dimension |cutdimen|@@>=
{ int p;	/* The pivot's index in |perm|. */
int a,b,c,d;	/* Cursors for partitioning. */
double exl,exh,lxl,lxh,gxl,gxh;	/* |x| extremes. */
double eyl,eyh,lyl,lyh,gyl,gyh;	/* |y| extremes. */
@@<Find the pivot@@>@@;
@@<Partition around |perm[p]|@@>@@;
@@<Build the subtrees@@>@@;
}

@@
In the Quicksort application, Bentley and McIlroy settled on the following
@@^Bentley, Jon Louis@@>
algorithm for finding a pivot.  For large inputs, it uses Tukey's `ninther':
the median of the three medians of three.  For smaller inputs, a median
of three is used.  

Now, 
their pivot-picking algorithm
may not be suitable here
because their application differs from ours in the following ways.
First, our cost model differs: we compare coordinates, which is fast,
while their comparison is a function-call away.  
Second, they are doing a pure sort; we too are sorting, but in $k$ dimensions.
Does this change matters?
Third, their machine is a VAX-8550; ours is likely to be a modern RISC machine.
Fourth, theirs is a library function, so side-effecting the random number
generator is a bad thing; we don't care about that: how much better or
slower is randomization? 

However, until someone gives convincing evidence that there are better choices
for the pivot, I will stick to the Bentley and McIlroy solution.
Before you run off and try to find a better solution, here's how
their algorithm stacks up:
to sort $n$ random 30-bit integers, they required $1.094n\lg n-0.74n$
comparisons.  (This is for $n$ ranging over each power of two from 128 to
65536. The function was found by a weighted least-squares regression fit.)

If you're thinking `pick the true median', then your thoughts
have already been anticipated.  In the Quicksort application, finding
the true median, although taking only linear time, is too costly.

@@d val(a) (coord[perm[(a)]].x[cutdimen])
@@d valx(a) (coord[perm[(a)]].x[0])
@@d valy(a) (coord[perm[(a)]].x[1])
@@d med3(a,b,c) (val(a)<val(b) ? (val(b)<val(c) ? b : val(a)<val(c) ? (c):(a)) @@;
							  : (val(b)>val(c) ? b : val(a)>val(c) ? (c):(a)) )

@@<Find the pivot@@>=
p = (lo+hi)/2;	/* Small arrays, middle element. */
if ( hi-lo > 7 ) {
	int p1=lo,pn=hi-1;
	if ( hi-lo > 40 ) {	/* Big arrays, pseudomedian of 9. */
		int s = (hi-lo)/8;
		p1 =  med3(p1,p1+s,p1+s+s);
		p =  med3(p-s,p,p+s);
		pn =  med3(pn-s-s,pn-s,pn);
	}
	p = med3(p1,p,pn);	/* Mid-size, median of 3. */
}

@@ Partitioning the elements into three classes means more than just finding
which elements belong to which class---it also means moving the elements
so that the members of each class is contiguous.  In addition, we'll
move all the lesser elements to the front, the greater elements to the
back, and the equal elements to the middle.  
This problem is equivalent to Dijkstra's `Dutch National Flag' problem,
@@^Dijkstra, Edsger W.@@>
after the Dutch flag, which is three horizontal stripes of red, white, and
blue.  (See {\tt http://www.cesi.it/flags/nl.html} for a rendition
of the Dutch National Flag.)

The invariant maintained is: equal, lesser, unknown, greater, equal.
The boundary indices are |lo|, |a|, |b|, |c|, |d|, and |hi-1|.

We're also careful to find the ranges over each set of elements.

@@d swapint(J,K)@@+ {@@+ int t=J;@@+ J=K;@@+ K=t;@@+ }
		/* Assumes |t| is not free in |J| or |K| */

@@<Partition around |perm[p]|@@>= 
@@<Initialize bounds@@>@@;
a=b=lo; c=d=hi-1; 
{double v = val(p), diff; 
node->f.i.cutdimen = cutdimen;  
node->f.i.cutvalue = v;
for(;;) {
	while( b<=c && (diff=val(b)-v)<=0.0 ) {
		if ( diff==0.0 ) {
			@@<Update bounds for equal elements at |b|@@>@@;
			swapint(perm[a],perm[b]);
			a++;
		} @@+ else @@+ {@@+  
			@@<Update bounds for lesser elements@@>@@+
		}
		b++;
	}
	while( c>=b && (diff=val(c)-v)>=0.0 ) {
		if ( diff==0.0 ) {
			@@<Update bounds for equal elements at |c|@@>@@;
			swapint(perm[d],perm[c]);
			d--;
		} @@+ else @@+ {@@+  
			@@<Update bounds for greater elements@@>@@+
		}
		c--;
	}
	if ( b>c ) break;
	swapint(perm[b],perm[c]);
	@@<Update bounds for lesser elements@@>@@;
	@@<Update bounds for greater elements@@>@@;
	b++; c--;
}
@@<Move equals to middle@@>@@;
}
@@<Paranoid: check the partitioning@@>@@;

@@
@@<Initialize bounds@@>=
exl=lxl=gxl=xmax;	
exh=lxh=gxh=xmin;	
eyl=lyl=gyl=ymax;	
eyh=lyh=gyh=ymin;	

@@
@@d min(x,y) ((x)<(y)?(x):(y))
@@d max(x,y) ((x)>(y)?(x):(y))
@@<Update bounds for equal elements at |b|@@>=
			exl = min(exl,valx(b));
			exh = max(exh,valx(b));
			eyl = min(eyl,valy(b));
			eyh = max(eyh,valy(b));

@@
			@@<Update bounds for lesser elements@@>=
			lxl = min(lxl,valx(b));
			lxh = max(lxh,valx(b));
			lyl = min(lyl,valy(b));
			lyh = max(lyh,valy(b));

@@
			@@<Update bounds for equal elements at |c|@@>=
			exl = min(exl,valx(c));
			exh = max(exh,valx(c));
			eyl = min(eyl,valy(c));
			eyh = max(eyh,valy(c));

@@
			@@<Update bounds for greater elements@@>=
			gxl = min(gxl,valx(c));
			gxh = max(gxh,valx(c));
			gyl = min(gyl,valy(c));
			gyh = max(gyh,valy(c));

@@
@@<Move equals to middle@@>=
{
int s,l,h;
s=min(a-lo,b-a);	/* Move first set of equals to middle. */
for(l=lo,h=b-s;s;s--) {swapint(perm[l],perm[h]);@@+l++;h++;}
s=min(d-c,hi-1-d);	/* Move last set of equals to middle. */
for(l=b,h=hi-s;s;s--) {swapint(perm[l],perm[h]);@@+l++;h++;}
}

@@ Now that the elements are partitioned, we recurse to build the subtrees.

It is possible to pick a sequence of bad pivots, causing many of the
segments to be large.  This would not only slow things down, but it would
also force us to use a lot of stack space.  

There are two ways to get around this.
First, one might always choose a pivot that guarantees a good partition,
for example the median; medians can be found in linear time (INSERT REFERENCE).
Second, one might always process the smaller segments first and
use tail recursion to process the remaining largest segment.  This guarantees
that at most $\log_2 n$ activation records are present on the stack
@@^tail recusion@@>
@@^stack overflow@@>
at any one time.

However, until this problem shows up,  
I will use the simplest solution: blind recursion.
Note that Quicksort itself runs in $O(n\log n)$ time on average.
For example, see C.~A.~R.~Hoare's INSERT REFERENCE, or Robert Sedgewick's
PhD thesis (INSERT REFERENCE), or the perhaps more readily available
Knuth (INSERT REFERENCE), section ??.
@@^Hoare, Charles Anthony Richard@@>
@@^Knuth, Donald Ervin@@>
@@^Sedgewick, Robert@@>

%%%
%%%A common trick in Quicksort implementations is to recurse on the 
%%%smaller-size array segment first.  This leaves the larger segment waiting
%%%in the activation record on the stack.   When the smaller segment is done,
%%%then we sort the larger segment.
%%%This strategy ensures that
%%%there are at most $\log_2 n$ activation records on the stack, protecting
%%%us from stack overflow.
%%%@@^stack overflow@@>
%%%
%%%Interestingly, many people know this trick, but a significant fraction
%%%of them get it backwards: they recurse on the {\it larger\/} segment
%%%first.  Knuth (CHECK THIS) comments on this phenomenon, and wags his finger
%%%@@^Knuth, Donald Ervin@@>
%%%appropriately.
%%%
%%%Here, we have three segments on which we recurse.  A moment's thought tells
%%%us 
%%%to recurse on the smallest first, the next smallest second, and the largest
%%%last.  This still guarantees that there are at most $\log_{2} n$ activation
%%%records on the stack: because the smallest segment is at most one third
%%%of the remaining elements, and the middle segment is at most half the
%%%remaining elements.
%%%
%%%We only need the largest segment last in order to guarantee this logarithmic
%%%bound.  Arranging to meet  
%%%this simpler condition isn't much less work: one fewer
%%%integer comparison in the worst case.
%%%I didn't realize this until after I coded the following, which arranges
%%%the
%%%stronger small-medium-large order, so I left it in.
%%%
%%%

@@<Build the subtrees@@>=
#if defined(KD_BUILD_SMALLEST_SEGMENT_FIRST)
{ int l = b-a, m = hi-(d-c)-lo+b-a, h = d-c;
if ( l <= m ) {
	if ( m <= h ) { @@<Build $<$ tree@@> @@+ @@<Build $=$ tree@@> @@+ 
		@@<Build $>$ tree@@> }
	else if ( l <= h ) { @@<Build $<$ tree@@> @@+ @@<Build $>$ tree@@> @@+ @@<Build $=$ tree@@> }
	else { @@<Build $>$ tree@@> @@+ @@<Build $<$ tree@@> @@+ @@<Build $=$ tree@@> }
} else {
	if ( l <= h ) { @@<Build $=$ tree@@> @@+ @@<Build $<$ tree@@> @@+ @@<Build $>$ tree@@> }
	else if ( m <= h ) { @@<Build $=$ tree@@> @@+ @@<Build $>$ tree@@> @@+ @@<Build $<$ tree@@> }
	else { @@<Build $>$ tree@@> @@+ @@<Build $=$ tree@@> @@+ @@<Build $<$ tree@@> }
}
}
#else
@@<Build $<$ tree@@>@@;
@@<Build $=$ tree@@>@@;
@@<Build $>$ tree@@>@@;
#endif

@@ To build the subtree for the smaller elements, we call ourselves 
recursively.  We  pass this node as the parent; we propagate the information
on which dimensions have been flattened, and what level the subtree is at; 
we also pass the array bounds for the segment and the spatial 
bounding box of those
points.

@@<Build $<$ tree@@>=
node->f.i.lo_child =
	E2_build_helper(node,flat_dimens,level,lo,lo+b-a,lxl,lxh,lyl,lyh);

@@ @@<Build $>$ tree@@>=
node->f.i.hi_child =
	E2_build_helper(node,flat_dimens,level,hi-(d-c),hi,gxl,gxh,gyl,gyh);

@@ When we recurse on the equal elements, we additionally 
tell the new invocation
that this dimension has already been flattened.
For $k\in\{0,1\}$, $2^k=k+1$, so we use |cutdimen+1| in place of an 
exponentiation.

@@<Build $=$ tree@@>=
node->f.i.eq_child = 
E2_build_helper(node,flat_dimens|(cutdimen+1),level,lo+b-a,hi-(d-c),exl,exh,eyl,eyh);


@@*Hiding and unhiding.
Part of the meaning of a semidynamic point set is that we may hide and unhide
points at will.  
A point becomes invisible to queries when it is hidden.  It becomes
visible again when it is unhidden.

First we will describe how to hide and unhide single points.
Later we will show how to hide and unhide all the points at once.

@@ Inside a bucket, we hide a node by moving it to the end of the bucket, and
decrement the |hi| index.  To recover all the points in a bucket, we
also store a |hi_all| index, which is the value of |hi| when all
the points are visible.

@@<Other external node fields@@>=
int hi_all;

@@  We need to initialize this field during tree creation.
@@<Fill other bucket fields@@>=
node->f.e.hi_all = hi;

@@ In addition to moving the point to the end of its bucket, we need to
ensure the |hidden| fields of our ancestors are properly set.

@@<Subroutines@@>=
void
E2_hide(int c) {
	int ci;
	E2_node_t *node;
	errorif (c<0 || c>=n,"Invalid city %d to hide",c);
	node = E2_point_to_bucket[c];
	@@<Make |perm[ci]==c|@@>@@;
	@@<Hide |ci|@@>@@;
	@@<If necessary, hide |node|'s ancestors@@>@@;
}


@@ Before we can hide city |c|, we must find it in its bucket.  

One option is to maintain an inverse of |perm|.  However, this takes
up linear extra space, and is a hassle to maintain.

The option I've chosen here is to perform a sequential search through the
bucket.  For most buckets this is  fast because, on average, this takes about
|kd_bucket_cutoff/2| steps.  With the default of 5 for |kd_bucket_cutoff|,
this is 2.5 steps.  That's small.  

I said `most buckets' because there is a fly in the ointment.  In fact,
this is the same fly and the same ointment that I mentioned earlier. 
When there are
many points with exactly the same coordinate, then the bucket storing
those points will be rather large.  Again, degenerate inputs lead to
@@^degenerate inputs@@>
bad running times.  
I've decided to risk this tradeoff because I expect
these inputs to be very rare.
@@^tradeoffs@@>


@@<Make |perm[ci]==c|@@>=
{ int hi_all = node->f.e.hi_all;
	for ( ci=node->f.e.lo;ci<hi_all; ci++ ) {
		if ( perm[ci]==c ) break;
	}
	errorif(ci==hi_all,"Point %d not found in its bucket",c);
}

@@ For correctness' sake, we must check to see whether the city is already
hidden.   (If the city is already  hidden, then |hi| should not be
decremented.)

Should we complain publicly if the city is already hidden?  
@@^public complaining@@>
As a matter of defensive programming, the answer---currently---is yes.
The algorithms that use this module shouldn't try to hide a hidden city.
Complaining about it here would probably help me track down a bug.
However, if this code is used in other contexts, then we may want
to eliminate this public complaining.

@@<Hide |ci|@@>=
{ int t, hi = node->f.e.hi;
if ( ci < hi ) { 
	hi=--node->f.e.hi;
	t=perm[ci];@@+perm[ci]=perm[hi];@@+perm[hi]=t;
} else {
	fprintf(stderr,"Hiding hidden city %d at perm[%d]\n",c,ci);
}
}
	
@@ We've used |fprintf|, and so we need the interface to the standard
I/O library. % While we're at it,
@@<System headers@@>=
#include <stdio.h>

@@ The next task is to set the |hidden| fields in our ancestors properly.
In particular, each node is an ancestor of itself.  
This simplifies the code nicely.

We stop climbing on one of three conditions: when we run 
off the top of the tree, when we hit an ancestor 
that is already hidden, or when not all the nodes in the subtree rooted
at that node are hidden.
To simplify the loop test, we put it at the end of the loop, so it 
only applies to internal nodes.
Remember that each internal node is ternary:
none of its three children are null pointers, |NULL|, though they may be empty.


@@<If necessary, hide |node|'s ancestors@@>=
#if !defined(KD_NO_HIDDEN_BIT)
if ( node->f.e.lo == node->f.e.hi && !node->hidden ) {
	do {
		node->hidden = 1; 
/* |printf("h");| */
		node=node->parent;
	} while ( node 
			&& !node->hidden 
			&& node->f.i.lo_child->hidden 
			&& node->f.i.eq_child->hidden 
			&& node->f.i.hi_child->hidden );
}
#endif

@@ The code for hiding a city is now complete.  It's now time
to turn our attention to unhiding a city.

Luckily for us, we get to reuse some of the code we've just seen, namely
the code that finds $\hbox{|perm|}^{-1}(c)$.  The other sections are easy.

@@<Subroutines@@>=
void
E2_unhide(int c) {
	int ci;
	E2_node_t *node = E2_point_to_bucket[c];
	@@<Make |perm[ci]==c|@@>@@;
	@@<Unhide |ci|@@>@@;
	@@<Unhide |node| and its ancestors@@>@@;
}


@@ As with hiding, we must first check to see if the city is already unhidden.
We complain publicly if this is the case.
@@^public complaining@@>


@@<Unhide |ci|@@>=
{ int t, hi = node->f.e.hi;
if ( ci >= hi ) { 
	t=perm[ci];@@+perm[ci]=perm[hi];@@+perm[hi]=t;
	node->f.e.hi++;
} else {
	fprintf(stderr,"Unhiding unhidden city %d at perm[%d]\n",c,ci);
}
}
	



@@
Unhiding ancestors is analogous hiding ancestors, but simpler.
We climb up the tree, setting |hidden| fields to false, and stop when
we either run off the top or reach an ancestor that is already unhidden.

@@<Unhide |node| and its ancestors@@>=
#if !defined(KD_NO_HIDDEN_BIT)
while ( node && node->hidden ) {
	node->hidden = 0;
	node=node->parent;
}
#endif

@@ Now we are ready to see how to hide and unhide all the points in the set.
One option is to call the individual operation on every point in the set.
This works, but has a high overhead.  We can reduce the overhead by 
specially coding
these bulk operations. This is the course I've chosen.

@@ We'll start with hiding.  We use a recursive routine to unhide all
the subtrees.  We use a helper routine that hides an entire subtree.

@@<Subroutines@@>=
void 
E2_hide_all(void) {
#if !defined(KD_NO_HIDDEN_BIT)
	if ( E2_root && !E2_root->hidden ) E2_hide_all_helper(E2_root);
#else
	if ( E2_root ) E2_hide_all_helper(E2_root);
#endif
}

@@ The recursive routine sets the |hidden| field, and then splits
into two cases.
Inside a bucket, it moves the live-range index |hi| down to |lo|.
At an internal node, it calls itself recursively.

One might worry about overflowing the runtime stack.  
With a bit of care, we'll only
overflow the stack here if we've already overflowed it in building the 
tree itself.  The `bit of care' is to process the largest segment last.
Unfortunately, we've lost that information, and it's not
easily recoverable. Yikes!  Oh well,
let's recurse blindly.
@@^stack overflow@@>

An extra optimization is to only recurse down subtrees which are
not currently hidden.

@@<Module subroutines@@>=
static void 
E2_hide_all_helper(E2_node_t *p) {
#if !defined(KD_NO_HIDDEN_BIT)
	p->hidden = 1;
#endif
	if ( p->is_bucket ) p->f.e.hi = p->f.e.lo;
	else { 
#if !defined(KD_NO_HIDDEN_BIT)
		if(!p->f.i.lo_child->hidden)E2_hide_all_helper(p->f.i.lo_child);
		if(!p->f.i.eq_child->hidden)E2_hide_all_helper(p->f.i.eq_child);
		if(!p->f.i.hi_child->hidden)E2_hide_all_helper(p->f.i.hi_child);
#else
		E2_hide_all_helper(p->f.i.lo_child);
		E2_hide_all_helper(p->f.i.eq_child);
		E2_hide_all_helper(p->f.i.hi_child);
#endif
	}
}

@@ Unhiding is very similar to hiding.
The only subtlety is that we have no option but to always recurse:
there may be hidden cities in subtrees whose |hidden| bit is turned off.


@@<Subroutines@@>=
void 
E2_unhide_all(void) {
	if ( E2_root ) E2_unhide_all_helper(E2_root);
}

@@ This time, a bucket's live-range index |hi| gets set to |hi_all|,
the value it has when all its points are unhidden.  At an internal node,
we have no option but to recurse into the children.

@@<Module subroutines@@>=
static void 
E2_unhide_all_helper(E2_node_t *p) {
	if ( p->is_bucket ) {
		p->f.e.hi = p->f.e.hi_all;
#if !defined(KD_NO_HIDDEN_BIT)
		p->hidden = p->f.e.lo >= p->f.e.hi;
#endif
	} else {
#if !defined(KD_NO_HIDDEN_BIT)
		p->hidden = 0;
#endif
		E2_unhide_all_helper(p->f.i.lo_child);
		E2_unhide_all_helper(p->f.i.eq_child);
		E2_unhide_all_helper(p->f.i.hi_child);
	}
}

@@* Nearest neighbours.
Now that we've built the tree, we're ready to describe the first query:
nearest neighbour search.  Given a city $i$, we'd like to find an
unhidden city that is nearest to $i$, excluding $i$ of course.

We proceed in bottom-up fashion, searching from the bucket containing 
$i$ and upward through the ever-larger subtrees that contain that bucket.
The idea is that the nearest neighbour is likely to be found in a part
of the tree that is near $i$'s bucket.  
With a candidate $j$ in hand, we terminate the walk to the root once we can 
prove that the ball of radius $\cost(i,j)$ lies entirely within the current
subtree.  Here, of course, one can use whatever metric is in effect in
the current context to define ``ball''; we aren't restricted to the Euclidean
metric.

I should say up front that most of this code is taken almost verbatim from
Bentley's {\sl $K$-d Trees for Semidynamic Point Sets}, Sixth Annual 
@@^Bentley, Jon Louis@@>
ACM Symposium on Computational Geometry, Berkeley, CA, June 1990, pp.~187--197.

@@ We also need quadrant-based nearest neighbour search. 
Most of the code is the same, so I've folded in the generalizations
required.

I borrow from and slightly extend ordinary mathematical
terminology: if city |i| lies
at $(x,y)$, then
quadrant 0 is point $(x,y)$;
quadrant 1 is all points $(x',y')$ with $x'>x$ and $y'\ge y$;
quadrant 2 is all points $(x',y')$ with $x'\le x$ and $y'>y$;
quadrant 3 is all points $(x',y')$ with $x'<x$ and $y'\le y$;
quadrant 4 is all points $(x',y')$ with $x'\ge x$ and $y'<y$.
This nomenclature is presented in module \module{NN}.

For the sake of generality, the core searching code will be able to handle
any combination of the five quadrants by using bit masks.
For exaple, to specify searching in quadrants 0, 1 and 4, a mask
of |0x13| will is used.

@@<Module variables@@>=
int quadrant_mask;


@@ We use a recursive helper routine to check subtrees.  

To save time passing state around, we define some external state.
The city we're trying to find a neighbour for is |E2_nn_seed|;
the best city found so far is |E2_nn_incumbent|.
Because we're using the Euclidean metric, 
we can take Sproull's advice (see Bentley (INSERT REFERENCE)) and 
@@^Bentley, Jon Louis@@>
@@^Sproull@@>
compare squared distances instead of actual distances; this 
saves a square root operation each time we determine an edge cost.  The
squared distance to the incumbent is stored in |E2_nn_dist_sq|.
Occasionally, however, we test against a bounding box whose radius
is the actual distance between the seed and the best neighbour found
so far.  This distance is stored in |E2_nn_dist|.


We will often compute distances to the seed city, so it will also be 
convenient to remember its coordinates.  They are stored in |E2_nn_seed_x|
and |E2_nn_seed_y|.

@@<Module variables@@>=
static int E2_nn_seed, E2_nn_incumbent;
static double E2_nn_dist, E2_nn_dist_sq, E2_nn_seed_x, E2_nn_seed_y;

@@  The recursive routine that checks subtrees is named |E2_rnn|.
It splits naturally into two cases: internal versus external nodes.

@@<Module subroutines@@>=
static void 
E2_rnn(E2_node_t *p) {
	if ( p->is_bucket ) {
		@@<Search this bucket for a nearer neighbour@@>@@;
	} else {
		@@<Search the children for a nearer neighbour@@>@@;
	}
}


@@ Inside a bucket, we perform a sequential search.

@@<Search this bucket for a nearer neighbour@@>=
{ int i, hi=p->f.e.hi;
for ( i=p->f.e.lo ; i<hi ; i++ ) {
	int pi = perm[i];
	@@<Update nearest neighbour if |pi| is nearer@@>@@;
}
}


@@
I avoid rounding in the computation of the actual distance because
I want this code to be applicable to both |EUC_2D| and |CEIL_2D|
cost functions.  Rounding would have implications on the bounding
box test.   We should be careful in this respect, and not rounding
is a conservative choice: it doesn't needlessly throw bits away.
@@^rounding@@>

If you need further convincing, then observe that both the rounding  
and the ceiling functions are 
monotonic on the real line.  That is, for any real numbers
$\alpha$ and $\beta$,
$\alpha \le \beta$  % \Rightarrow 
implies both
$\lfloor \alpha + 0.5\rfloor
\le \lfloor \beta + 0.5\rfloor$ 
and
$\lceil \alpha \rceil \le
\lceil \beta \rceil$.

I may want to consider using the |hypot| standard math library function 
instead.

The bitmask table encodes the case analysis for determining in which
relative quadrant city |pi| lies.  This way we can precisely prune
points in unwanted relative quadrants.

@@d my_sgn(X) ((X)<0?0:((X)>0?2:1)) 
		/* Answer 0 if negative, 1 if zero, and 2 if positive. */

@@<Update nearest neighbour if |pi| is nearer@@>=
{
	const double 
		diff_x = E2_nn_seed_x-coord[pi].x[0], 
		diff_y = E2_nn_seed_y-coord[pi].x[1];
	const int qmask[3][3]={{0x02,0x02,0x10},{0x04,0x01,0x10},{0x04,0x08,0x08}};
	if ( quadrant_mask & qmask[my_sgn(diff_x)][my_sgn(diff_y)] ) {
		/* City |pi| is in a quadrant we are searching. */
		const double dist_sq = diff_x*diff_x + diff_y*diff_y;
		@@<Verbose: |nn| show city being compared@@>@@;
		if ( dist_sq < E2_nn_dist_sq ) {
			@@<Verbose: |nn| new incumbent@@>@@;
			E2_nn_dist = sqrt(dist_sq);
			E2_nn_dist_sq = dist_sq;
			E2_nn_incumbent = pi;
		}
	}
}

@@ We need the interface to |sqrt|.
@@<System headers@@>=
#include <math.h>


@@  As usual, the recursive case is more interesting.  A naive implementation
would just call itself recursively on each of its three children.

However, we use a simple distance criterion to prune the search.
We avoid examining a branch if that branch is on the opposite side of the
cut plane from the seed city and the distance from the seed city to
the cut plane is greater than the distance from the seed city
to the incumbent city.  
%(We use squared distances, as mentioned earlier.)  
This tactic 
works whenever the
metric being used dominates the $L_\infty$ metric, which is the case
for all $L_p$ metrics ($p\ge 1$), and the Euclidean ($L_2$) metric in 
particular.  Note that the |CEIL_2D| metric dominates the Euclidean metric,
and therefore it also dominates the $L_\infty$ metric.

A clever thing that Bentley does is to first search the branch
that is on the same side of
@@^Bentley, Jon Louis@@>
the cut plane as the seed city.  The idea is that a nearest neighbour is
more likely to be found on the same side as opposed to the opposite side.
In this way we hope to find a strong pruning distance more quickly.
In our case we have separated the cities into three classes instead of
only two, so
we extend this heuristic 
slightly by searching the cut plane itself before the far
side of the cut plane.

When the seed city lies in the cut plane, we search the cut plane first,
and the other branches in some arbitrary order.

@@ One might worry about stack overflow in the case that the tree is rather
degenerate.  
@@^stack overflow@@>
We can avoid it by transforming the recursion into an iteration, but
this either means maintaining our own stack, or more cleverly,
using pointer reversal. 
(Pointer reversal was introduced by H.~Schorr and W.~Waite in their 
@@^{Schorr, H{.}}@@>
@@^{Waite, W{.}}@@>
1967 paper ``An efficient machine independent procedure for garbage 
collection'', {\sl Communications of the ACM}, 1967, 
Vol.~10, No.~8, pp.~501--506.  
The technique is useful for more than just garbage collection;
it is also used in graph-reduction model of evaluating functional programs.
For example, see \S11.6.1 in 
{\sl
Implementing Functional
Languages}, edited by Simon L.~Peyton Jones (COMPLETE REFERENCE).)
@@^Peyton Jones, Simon L{.}@@>
However, both these measures appear a bit drastic for now.  So I'll make the 
code just blindly recurse.

@@ When I first coded this section, I forgot to test the hidden bit of the
node we were going to recurse into:  there is no point in recursing into
subtrees that only have hidden cities.
Yet, the times to build a 20 nearest neighbour
structure will still very reasonable, about 15 seconds on {\tt brd14051}
on a 125MHz IBM RS/6000.
@@^RS/6000@@>
@@^brd14051@@>

I began to wonder how effective this extra test really is at pruning the 
search.  Does it succeed often enough to warrant checking that byte every
time?  So I performed the following experiment.  

One of the stress tests I've used to discover bugs in my $k$-d tree 
implementation is to compute successive nearest neighbours for each city.
That is, for each city $i$, I had the program compute $i$'s nearest
neighbour, hide that neighbour, and repeat until all the cities were hidden.
The program checked that the distances were non-decreasing.  This is a
significant amount of work, taking time at least quadratic in the number
of cities.

The following table records the number of user seconds required 
by the RS/6000 machine
to both build the $k$-d tree
and perform this computation on various instances.  Three variations
were performed.  The first variation tests the hidden bit before every
recursive call of |E2_rnn_helper|.  The second variation avoids this test,
but still tests the hidden bit on every call to |E2_rnn|.
The last avoids storing the hidden bit at all, and therefore saves on
bookkeeping costs related to the hidden bit, but might unnecessarily
visit extra nodes.

\noindent\hfill\halign{{\tt #\hfil}&\hfil#&\hfil#&\hfil#\cr
&\omit\quad Always test\quad\hfil&\omit\quad Sometimes test\quad\hfil&\quad 
No hidden bit\hfil\quad\cr
\omit\hfil\quad Instance\quad\hfil&\omit\hfil hidden bit\hfil&\omit\hfil 
hidden bit\hfil&\quad\hfil used or stored\hfil\quad\cr
lin105 & 0.3 	&  0.4 &  0.5 \cr
lin318 & 8.3 	& 13.2 & 15.0 \cr
dsj1000 & 317.2 &728.3 &845.8 \cr
}\hfill\hbox{}\penalty-10000
%Experiments July 26, 1996

These results show that the using the hidden bit to its fullest is the
right thing to do,
resulting in up to 100\% better performance than using it only
some of the time, and up to 265\% better performance than not using it
at all.

@@ There is one last detail.  
We also use quadrant masks to avoid recursive calls when possible.
That's the source of the expressions with |quadrant_mask|
involving the magic numbers |0x12|, |0x06|, |0x0c|, and |0x18|.
Do the case analysis with a bunch of pictures and you'll see why those
values are right.

@@<Search the children for a nearer neighbour@@>=
#if !defined(KD_NO_HIDDEN_BIT) && !defined(KD_NO_HIDDEN_RNN_TEST)
#define recurse_if_not_hidden(P) ((P)->hidden || (E2_rnn(P),42))
#else
#define recurse_if_not_hidden(P) (E2_rnn(P),42)
#endif
{
const int cutdimen = p->f.i.cutdimen;
const double seed_coord = cutdimen==0 ? E2_nn_seed_x : E2_nn_seed_y,
diff = seed_coord - p->f.i.cutvalue;
if ( diff < 0 ) { /* |seed < cutvalue | */
	recurse_if_not_hidden(p->f.i.lo_child);
	if ( E2_nn_dist >= -diff && ((cutdimen ? 0x12 : 0x06) & quadrant_mask) ) {
		recurse_if_not_hidden(p->f.i.eq_child);
		recurse_if_not_hidden(p->f.i.hi_child);
	}
} else if ( diff > 0 ) { /* |seed > cutvalue | */
	recurse_if_not_hidden(p->f.i.hi_child);
	if ( E2_nn_dist >= diff && ((cutdimen ? 0x0c : 0x18) & quadrant_mask) ) {
		recurse_if_not_hidden(p->f.i.eq_child);
		recurse_if_not_hidden(p->f.i.lo_child);
	}
} else {
	recurse_if_not_hidden(p->f.i.eq_child);
	recurse_if_not_hidden(p->f.i.lo_child);
	recurse_if_not_hidden(p->f.i.hi_child);
}
}

@@ Now that we've built the helper routine to search entire subtrees,
let's write the driver code itself.  Function |E2_nn(int c)| returns
an unhidden city that is nearest to |c|.  
If there are no unhidden neighbours, then it returns $-1$.

We look for a candidate first in |c|'s bucket, and then expand
the search to the subtrees rooted at ever-higher ancestors of that
bucket.  

But first we need to set up the required state for the recursive helper
routine.

Admittedly, the |do {...} while (0)| 
construction is awkward, but it lets us write
the `unfruitful' test code so that it may be reused.  This is the perfect
place for a forward |goto|.  Knuth (INSERT REFERENCE) once argued
@@^Knuth, Donald Ervin@@>
for the desirability of a well-placed |goto|; this was in response
to Edsger Dijkstra's famous and influential ``Goto considered harmful''
@@^Dijkstra, Edsger W.@@>
letter to the {\sl Communications of the ACM}.  Of course, all this
awkwardness would go away if we could program in continuation passing
style, as is common in, say, Scheme or \ML/.
@@^continuation passing style@@>
@@^|goto|@@>
@@^Scheme@@>
@@^ML@@>

@@<Subroutines@@>=
int E2_nn(int c) { return E2_nn_quadrant(c, 0x1f); }

int 
E2_nn_quadrant(int c, const int mask) 
{
	E2_node_t *node = E2_point_to_bucket[c];
	quadrant_mask = mask;
	E2_nn_seed = c;
	E2_nn_seed_x = coord[c].x[0];
	E2_nn_seed_y = coord[c].x[1];
	E2_nn_incumbent = -1;
	E2_nn_dist = E2_nn_dist_sq = E2_strict_upper_bound;
	@@<Search bucket |node| for a nearer neighbour, excluding the seed@@>@@;
	do {
		@@<|break| if further search would be unfruitful@@>@@;
		@@<Search proper ancestors for nearer neighbours@@>@@;
	} while (0);
	return E2_nn_incumbent;
}


@@ The variable |E2_strict_upper_bound| holds a number that is guaranteed
to be larger than the squared length of any edge.   
It is a kind of ``infinity''
@@^infinity@@>
and is computed as something larger than the square of the length of 
the diagonal of the 
bounding box of all the points.

To ensure strictness, I've both doubled and added one to the square of the
length of the diagonal.  If the diagonal is trivial, say 0 units long, then
adding 1 ensures strictness.  If the diagonal is very large, then just adding
1 alone might not ensure strictness because we only have limited precision:
the 1 might be less than the value of the least significant bit of the mantissa
of the squared length of the diagonal. Multiplying by 2 first gets us out
of that problem.  In very extreme cases, we might overflow the floating point
representation.

@@<Build the tree@@>=
{double xrange = tsp->xmax-tsp->xmin, yrange = tsp->ymax-tsp->ymin;
E2_strict_upper_bound = 2.0*(xrange*xrange+yrange*yrange)+1.0;
}

@@ It is visible only within this module.
@@<Module variables@@>=
static double E2_strict_upper_bound;

@@  In the bucket that contains the seed, we avoid returning the seed itself.
Otherwise, this code works the same as the bucket search we saw earlier.

@@<Search bucket |node| for a nearer neighbour, excluding the seed@@>=
{
	int i, hi=node->f.e.hi;
	for ( i=node->f.e.lo ; i<hi ; i++ ) {
		int pi = perm[i];
		if ( pi != E2_nn_seed ) {
			@@<Update nearest neighbour if |pi| is nearer@@>@@;
		}
	}
}


@@ We prune the search by stopping when we've already
looked at all parts of the tree that intersect a ball with radius
|E2_nn_dist|, centred at the seed city.  Because each partitioning cut
in the tree is along a plane perpendicular to one of the axes, we may
as well use just a bounding box instead.  

Recall that |CEIL_2D| dominates |EUC_2D|, so these tests are safe for
|CEIL_2D| as well.

In the bounding box comparisons, it might be wise to put in a safety factor
of $\varepsilon$, a small positive constant.

@@<|break| if further search would be unfruitful@@>=
{ E2_box_t *b = node->bbox;
if ( b
	&& (b->xmin <= E2_nn_seed_x-E2_nn_dist)
	&& (b->xmax >= E2_nn_seed_x+E2_nn_dist) @@|
	&& (b->ymin <= E2_nn_seed_y-E2_nn_dist)
	&& (b->ymax >= E2_nn_seed_y+E2_nn_dist) ) {
		@@<Verbose: |break| from further search@@>@@;
		break;
	}
}

@@ We walk up the tree, exploring ever-larger regions of the tree.
We're careful to not search the same subtree twice:  we avoid calling
|E2_rnn| on |last|, the node we've just come from.  We also don't search
subtrees which contain only hidden points.

As with the bucket search, we search the child that is on the same
side of the cut plane first.

@@<Search proper ancestors for nearer neighbours@@>=

#if !defined(KD_NO_HIDDEN_BIT)
#define recurse_if_not_last_or_hidden(P) ((P)==last||(E2_rnn(P),42))
#else
#define recurse_if_not_last_or_hidden(P) ((P)==last||(P)->hidden||(E2_rnn(P),42))
#endif

{ E2_node_t *last;
for ( last = node, node=node->parent; node ; last = node, node=node->parent ) {
	E2_node_t *l=node->f.i.lo_child, *e=node->f.i.eq_child, *h=node->f.i.hi_child;
	if ( (node->f.i.cutdimen == 0 && E2_nn_seed_x < node->f.i.cutvalue)
		@@| || (node->f.i.cutdimen == 1 && E2_nn_seed_y < node->f.i.cutvalue) ) {
		recurse_if_not_last_or_hidden(l);
		recurse_if_not_last_or_hidden(e);
		recurse_if_not_last_or_hidden(h);
	} else {
		recurse_if_not_last_or_hidden(h);
		recurse_if_not_last_or_hidden(e);
		recurse_if_not_last_or_hidden(l);
	}
	@@<|break| if further search would be unfruitful@@>@@;
}
}
	
	
@@*Fixed-radius nearest neighbours.
We've just seen how to search for nearest neighbours.  There we were concerned
with finding a {\it single\/}
unhidden city that is {\it nearest\/} to the seed city.
Fixed-radius nearest neighbour is different in that it is used 
to find {\it all\/}
cities within a {\it given\/} radius.  

@@ Now, many cities might fit the bill.
In a language such as Haskell, \ML/, or Scheme, where it is convenient to 
@@^Haskell@@>
@@^ML@@>
@@^Scheme@@>
return arbitrarily sized bags of elements, we  might just return a list, 
and let the caller iterate through them.  However, \CEE/ encourages a 
different style: the procedure that finds the cities also 
iterates through them,
calling a given procedure on each one.  This explains the peculiar
type signature of the fixed radius nearest neighbour routine.

@@ On the assumption that the given radius will be small, we mimic the
structure of the ordinary nearest neighbour search, except that we 
{\it don't\/}
update the distance.

As before, we'll use some global state instead of passing parameters around.
Variable |E2_frnn_dist_sq| is the square of the radius.

@@<Subroutines@@>=
void 
E2_frnn(int c, double rad, void (*proc)(int j)) {
	errorif(1,"Fixed radius nearest neighbour not implemented");
}

void E2_set_radius(int i, double r) {
	errorif(1,"Ball searching not implemented");
}

void E2_ball_search(int i, void (*proc)(int j)) {
	errorif(1,"Ball searching not implemented");
}


@@*Paranoia.
@@d verb(a) if ( verbose>=(a) )
@@<Paranoid: check the partitioning@@>=
#ifdef KD_CHECK_PARTITIONING
/* Check the invariant. */
{ int i; double v = node->f.i.cutvalue;
verb(1000)printf("\nDimension %d\n",cutdimen);
for (i=lo;i<hi;i++) {
	if ( i==lo ) verb(1000)printf("Checking lesser: %d %d\n",lo,lo+b-a);
	if ( i==lo+b-a ) verb(1000)printf("Checking equal: %d %d\n",lo+b-a,hi-(d-c));
	if ( i==hi-(d-c) ) verb(1000)printf("Checking greater: %d %d\n",hi-(d-c),hi);
	verb(1000)printf("%d (%.0f,%.0f)\t %.0f %.0f\n",i,valx(i),valy(i),val(i),v); fflush(stdout);
}
for (i=lo;i<lo+b-a;i++) {
	errorif(val(i)>=v,"Not lesser at %d",i);
}
for (i=lo+b-a;i<hi-(d-c);i++) {
	errorif(val(i)!=v,"Not equal at %d",i);
}
for (i=hi-(d-c);i<hi;i++) {
	errorif(val(i)<=v,"Not greater at %d",i);
}
}
#endif

@@
@@<Module headers@@>=
#include "error.h"
#include "memory.h"

@@ The following routine outputs PostScript commands to show the divisions
between buckets.

@@<Subroutines@@>=
extern tsp_instance_t *tsp_instance;

static void
E2_postscript_show_helper(FILE *ps_out, int level, E2_node_t *node, 
	double xmin, double xmax, double ymin, double ymax ) {
	if ( !node->is_bucket ) {
		double cv = node->f.i.cutvalue;
fprintf(ps_out,"%%cutdimen == %d\n",node->f.i.cutdimen);
		switch(node->f.i.cutdimen) {
		case 0:	/* $x$ dimension */
			fprintf(ps_out,"newpath %f x %f y moveto %f x %f y lineto stroke\n",
				cv,ymin, cv,ymax);
@@<Debug: indent@@> verb(1000)printf("= in x = %f\n",cv);
			E2_postscript_show_helper(ps_out,level+1,node->f.i.eq_child,cv,cv,ymin,ymax);
@@<Debug: indent@@> verb(1000)printf("< in x < %f\n",cv);
			E2_postscript_show_helper(ps_out,level+1,node->f.i.lo_child,xmin,cv,ymin,ymax);
@@<Debug: indent@@> verb(1000)printf("> in x > %f\n",cv);
			E2_postscript_show_helper(ps_out,level+1,node->f.i.hi_child,cv,xmax,ymin,ymax);
			break;
		case 1:
			fprintf(ps_out,"newpath %f x %f y moveto %f x %f y lineto stroke\n",
				xmin,cv, xmax,cv);
@@<Debug: indent@@> verb(1000)printf("= in y = %f\n",cv);
			E2_postscript_show_helper(ps_out,level+1,node->f.i.eq_child,xmin,xmax,cv,cv);
@@<Debug: indent@@> verb(1000)printf("< in y < %f\n",cv);
			E2_postscript_show_helper(ps_out,level+1,node->f.i.lo_child,xmin,xmax,ymin,cv);
@@<Debug: indent@@> verb(1000)printf("> in y > %f\n",cv);
			E2_postscript_show_helper(ps_out,level+1,node->f.i.hi_child,xmin,xmax,cv,ymax);
			break;
		}
	} else {
		int i;
		@@<Debug: indent@@> 
		for (i=node->f.e.lo;i<node->f.e.hi_all;i++) {
			verb(1000)printf("%d ",perm[i]);
		}
		verb(1000)printf("\n");
	}
}

void
E2_postscript_show(FILE*ps_out) {
#if defined(KD_SHOW_KDTREE)
	fprintf(ps_out,"gsave 0 setlinewidth\n");
	E2_postscript_show_helper(ps_out,0,E2_root,
		tsp_instance->xmin, tsp_instance->xmax,tsp_instance->ymin,tsp_instance->ymax);
	fprintf(ps_out,"grestore\n");
	fflush(ps_out);
	fprintf(stderr,"Printed stuff to ps_out\n");
#else
	return;
#endif
}

@@
@@<Exported subroutines@@>=
void E2_postscript_show(FILE *);

@@
@@<Debug: indent@@>=
verb(1000){ int i; for (i=0;i<level;i++) printf(" "); }

@@
@@<Paranoid: check bounds@@>=
#ifdef KD_CHECK_BBOX
verb(1000)printf("lo %d hi %d\n",lo,hi);
if ( lo < hi )
{ double xl,xh,yl,yh; int i;
	xl = xmax; xh = xmin; yl=ymax;yh = ymin;
	for (i=lo;i<hi;i++ ) {
verb(1000)printf("xl %f i %d perm[i] %d %f %f xl\n",xl,i,perm[i], 
		coord[perm[i]].x[0], coord[perm[i]].x[1]);
		xl=min(xl,valx(i));
		yl=min(yl,valy(i));
		xh=max(xh,valx(i));
		yh=max(yh,valy(i));
	}
	errorif( xl != xmin, "xl %f!= xmin %f",xl,xmin);
	errorif( yl != ymin, "yl %f!= ymin %f",yl,ymin);
	errorif( xh != xmax, "xh %f!= xmax %f",xh,xmax);
	errorif( yh != ymax, "yh %f!= ymax %f",yh,ymax);
}
#endif

@@
@@<Module variables@@>=
extern int verbose;

@@
@@<Verbose: |nn| show city being compared@@>=
#if KD_ALLOW_VERBOSE
if ( verbose >= 2000 ) {
	printf("  city %5d (%7.0f,%7.0f) is dist %10.3f\n",
		pi,coord[pi].x[0], coord[pi].x[1], sqrt(dist_sq));
}
#endif


@@
@@<Verbose: |nn| new incumbent@@>=
#if KD_ALLOW_VERBOSE
if ( verbose >= 1000 ) {
	printf("    new champion\n");
}
#endif

@@
@@<Verbose: |break| from further search@@>=
#if KD_ALLOW_VERBOSE
if ( verbose >= 500 ) {
		printf("     rnn break: seed=(%0.0f,%0.0f) dist=%f\n",
			E2_nn_seed_x, E2_nn_seed_y, E2_nn_dist );
		printf("     seedbb=(%0.0f,%0.0f,%0.0f,%0.0f) bb=(%0.0f,%0.0f,%0.0f,%0.0f)\n",
			E2_nn_seed_x-E2_nn_dist,
			E2_nn_seed_y-E2_nn_dist,
			E2_nn_seed_x+E2_nn_dist,
			E2_nn_seed_y+E2_nn_dist,
			b->xmin,
			b->ymin,
			b->xmax,
			b->ymax);
}
#endif


@@*Index.
@


1.158
log
@Made prototypes and function declarations match w.r.t. const.
,
@
text
@d1 47
a47 1
@@i copyrt.w
d55 4
d338 1
a338 1
const char *kdtree_rcs_id = "$Id: kdtree.w,v 1.157 1997/10/25 21:44:06 neto Exp neto $";
@


1.157
log
@Finished coding quadrant stuff (I think). Must compile and test.
@
text
@d9 3
d288 1
a288 1
const char *kdtree_rcs_id = "$Id: kdtree.w,v 1.156 1997/10/25 19:49:11 neto Exp neto $";
d371 1
a371 1
int E2_nn_quadrant(int i, int q);
@


1.156
log
@Compact the code.
@
text
@d9 3
d285 1
a285 1
const char *kdtree_rcs_id = "$Id: kdtree.w,v 1.155 1997/10/18 15:23:37 neto Exp neto $";
d706 1
d1515 23
d1611 7
d1620 14
a1633 8
	double diff_x = coord[pi].x[0]-E2_nn_seed_x, diff_y=coord[pi].x[1]-E2_nn_seed_y;
	double dist_sq = diff_x*diff_x + diff_y*diff_y;
	@@<Verbose: |nn| show city being compared@@>@@;
	if ( dist_sq < E2_nn_dist_sq ) {
		@@<Verbose: |nn| new incumbent@@>@@;
		E2_nn_dist = sqrt(dist_sq);
		E2_nn_dist_sq = dist_sq;
		E2_nn_incumbent = pi;
d1744 6
d1758 2
a1759 1
double seed_coord = p->f.i.cutdimen==0 ? E2_nn_seed_x : E2_nn_seed_y,
d1761 1
a1761 1
if ( diff < 0 ) {
d1763 1
a1763 1
	if ( E2_nn_dist >= -diff ) {
d1767 1
a1767 1
} else if ( diff > 0 ) {
d1769 1
a1769 1
	if ( E2_nn_dist >= diff ) {
d1809 2
d1812 2
a1813 1
E2_nn(int c) {
d1815 1
@


1.155
log
@I had missed a swapint conversion.  Now it compiles.
@
text
@d9 3
d282 1
a282 1
const char *kdtree_rcs_id = "$Id: kdtree.w,v 1.154 1997/10/18 14:40:25 neto Exp neto $";
d327 7
a333 1
to point |i|, but is not |i| itself.  
d365 1
d1707 1
a1707 1
#define recurse_if_not_hidden(P) if (!(P)->hidden) E2_rnn(P)
d1709 1
a1709 1
#define recurse_if_not_hidden(P) E2_rnn(P)
d1853 7
d1865 3
a1867 9
#if !defined(KD_NO_HIDDEN_BIT)
		if ( l != last && !l->hidden ) E2_rnn(l);
		if ( e != last && !e->hidden ) E2_rnn(e);
		if ( h != last && !h->hidden ) E2_rnn(h);
#else
		if ( l != last ) E2_rnn(l);
		if ( e != last ) E2_rnn(e);
		if ( h != last ) E2_rnn(h);
#endif
d1869 3
a1871 9
#if !defined(KD_NO_HIDDEN_BIT)
		if ( h != last && !h->hidden ) E2_rnn(h);
		if ( e != last && !e->hidden ) E2_rnn(e);
		if ( l != last && !l->hidden ) E2_rnn(l);
#else
		if ( h != last ) E2_rnn(h);
		if ( e != last ) E2_rnn(e);
		if ( l != last ) E2_rnn(l);
#endif
@


1.154
log
@Added E2 supports()
@
text
@d9 3
d279 1
a279 1
const char *kdtree_rcs_id = "$Id: kdtree.w,v 1.153 1997/10/18 14:31:05 neto Exp neto $";
d1110 1
a1110 1
for(l=lo,h=b-s;s;s--) {t=perm[l];@@+perm[l]=perm[h];@@+perm[h]=t;l++;h++;}
d1112 1
a1112 1
for(l=b,h=hi-s;s;s--) {t=perm[l];@@+perm[l]=perm[h];@@+perm[h]=t;l++;h++;}
@


1.153
log
@Made all floats into doubles.
Checked for CEIL 2D compliance, and added comments in key places.
Minor editing.
@
text
@d9 5
d276 1
a276 1
const char *kdtree_rcs_id = "$Id: kdtree.w,v 1.152 1997/10/17 21:48:51 neto Exp neto $";
d358 22
d705 3
a707 1
E2_create(tsp_instance_t *tsp) {
a811 2
errorif(tsp->edge_weight_type != EUC_2D,
	"Trying to construct a 2-d tree when not a EUC_2D instance");
@


1.152
log
@Removed CUTDIMEN and THISDIMEN kludge by recasting the coord 2d structure
as an array instead of two named fields.
@
text
@d9 4
d271 1
a271 1
const char *kdtree_rcs_id = "$Id: kdtree.w,v 1.151 1997/10/17 20:47:35 neto Exp neto $";
d318 1
a318 1
|void E2_frnn(int i, float rad, void (*proc)(int j))| is 
d327 1
a327 1
|void E2_set_radius(int i, float r)| sets the radius of the 
d348 2
a349 2
void E2_frnn(int i, float rad, void (*proc)(int j));
void E2_set_radius(int i, float r);
d392 1
a392 1
			float cutvalue;
d521 1
a521 1
this scheme uses $s+2k$ words per box as compared to $2sk$ words per box.
d523 5
a527 1
three nodes, the clever scheme uses 7 words for every 12 words in the
d532 1
a532 1
Using |float| and ordinary \CEE/ pointers, this is valid 
d550 1
a550 1
	float xmin,xmax,ymin,ymax;
d923 1
a923 1
int a,b,c,d,t;	/* Cursors (see partitioning), and a swap variable. */
d998 3
d1011 1
a1011 1
			t=perm[a];@@+perm[a]=perm[b];@@+perm[b]=t;
d1013 2
a1014 2
		} else { 
			@@<Update bounds for lesser elements@@>@@;
d1021 1
a1021 1
			t=perm[d];@@+perm[d]=perm[c];@@+perm[c]=t;
d1023 2
a1024 2
		} else {
			@@<Update bounds for greater elements@@>@@;
d1029 1
a1029 1
	t=perm[b];@@+perm[b]=perm[c];@@+perm[c]=t;
d1183 1
a1183 1
For $k\in\{0,1\}$, $2^k-1=k$, so we use |cutdimen+1| in place of an 
d1219 1
d1221 1
a1221 2
	{
	E2_node_t *node = E2_point_to_bucket[c];
a1224 1
	}
d1281 1
a1281 1
I/O library.  While we're at it,
d1494 1
a1494 1
static float E2_nn_dist, E2_nn_dist_sq, E2_nn_seed_x, E2_nn_seed_y;
d1533 7
a1539 3
$\alpha \le \beta \Rightarrow 
\lfloor \alpha + 0.5\rfloor
\lceil \alpha \rceil$.
d1546 2
a1547 2
	float diff_x = coord[pi].x[0]-E2_nn_seed_x, diff_y=coord[pi].x[1]-E2_nn_seed_y;
	float dist_sq = diff_x*diff_x + diff_y*diff_y;
d1620 2
a1621 2
on one of the POW machines.  
@@^POW@@>
d1637 1
a1637 2
by a POW machine
@@^POW@@>
d1672 1
a1672 1
float seed_coord = p->f.i.cutdimen==0 ? E2_nn_seed_x : E2_nn_seed_y,
d1698 1
a1698 1
We look for a candidate first in |c|'s bucket, and then expands
d1757 1
a1757 1
{float xrange = tsp->xmax-tsp->xmin, yrange = tsp->ymax-tsp->ymin;
d1763 1
a1763 1
static float E2_strict_upper_bound;
d1786 3
d1790 1
a1790 1
of $\epsilon$, a small positive constant.
d1873 1
a1873 1
E2_frnn(int c, float rad, void (*proc)(int j)) {
d1877 1
a1877 1
void E2_set_radius(int i, float r) {
@


1.151
log
@Move short fields to end of E2 node struct.
@
text
@d9 3
d267 1
a267 1
const char *kdtree_rcs_id = "$Id: kdtree.w,v 1.150 1997/09/27 18:06:44 neto Exp neto $";
d881 8
a888 7
The cut dimension is the one with the greatest range.

Ok, so this |CUTDIMEN| thing is a kludge.  
For the
general $k$-d case one would prefer to 
use an index into an array.  But for two dimensions, this works and is simple.
Thank goodness for \CWEB/.
d891 1
d894 2
a895 13
	if ( xmax-xmin > ymax-ymin ) {
#define CUTFIELD x 
#define THISDIMEN 1 
		@@<Partition along |CUTFIELD|@@>@@;
#undef CUTFIELD
#undef THISDIMEN
	} else {
#define CUTFIELD y
#define THISDIMEN 2 
		@@<Partition along |CUTFIELD|@@>@@;
#undef CUTFIELD
#undef THISDIMEN
	}
d898 1
a898 5
#define CUTFIELD y 
#define THISDIMEN 2 
	@@<Partition along |CUTFIELD|@@>@@;
#undef CUTFIELD
#undef THISDIMEN
d901 1
a901 5
#define CUTFIELD x
#define THISDIMEN 1 
	@@<Partition along |CUTFIELD|@@>@@;
#undef CUTFIELD
#undef THISDIMEN
d907 2
d913 1
a913 1
@@<Partition along |CUTFIELD|@@>=
d955 3
a957 3
@@d val(a) (coord[perm[(a)]].CUTFIELD)
@@d valx(a) (coord[perm[(a)]].x)
@@d valy(a) (coord[perm[(a)]].y)
d994 1
a994 1
node->f.i.cutdimen = THISDIMEN-1;  /* Note: for $k\in\{0,1\}$, $2^k-1=k$ */
d1172 2
d1177 1
a1177 2
E2_build_helper(node,flat_dimens|THISDIMEN,level,lo+b-a,hi-(d-c),exl,exh,eyl,eyh);

d1532 1
a1532 1
	float diff_x = coord[pi].x-E2_nn_seed_x, diff_y=coord[pi].y-E2_nn_seed_y;
d1713 2
a1714 2
	E2_nn_seed_x = coord[c].x;
	E2_nn_seed_y = coord[c].y;
d1876 1
a1876 1
verb(1000)printf("\nDimension %d\n",THISDIMEN-1);
d1974 2
a1975 2
verb(1000)printf("xl %f i %d perm[i] %d %f %f xl\n",xl,i,perm[i], coord[perm[i]].x,
		coord[perm[i]].y);
d1997 1
a1997 1
		pi,coord[pi].x, coord[pi].y, sqrt(dist_sq));
@


1.150
log
@Fixed RCS log behaviour.
@
text
@d9 3
d264 1
a264 1
const char *kdtree_rcs_id = "$Id: kdtree.w,v 1.149 1997/08/15 20:18:25 neto Exp neto $";
d376 2
a380 2
	char is_bucket;
	@@<Other common short fields@@>@@;
d394 2
@


1.149
log
@Added Index major section.
@
text
@d7 5
a11 1
{\obeylines$Log: kdtree.w,v $
d261 1
a261 1
const char *kdtree_rcs_id = "$Id: kdtree.w,v 1.148 1997/05/16 18:11:41 neto Exp neto $";
@


1.148
log
@Break locks by david and neto.
Include <config.h> and "lkconfig.h"
@
text
@d8 4
d257 1
a257 1
const char *kdtree_rcs_id = "$Id: kdtree.w,v 1.147 1997/01/21 21:55:55 david Exp david $";
d2030 2
@


1.147
log
@Added standard copyright notice by including copyrt.w
@
text
@d8 3
d241 2
d253 1
a253 1
const char *kdtree_rcs_id = "$Id: kdtree.w,v 1.146 1997/01/21 17:42:14 david Exp david $";
@


1.146
log
@Make showing of partitioning optional.
@
text
@d1 1
a4 1
\copyright 1996 David Neto
a5 2
All rights reserved, etc.
\vskip.5cm\relax
d7 3
a9 1

a10 1
{\obeylines$Log: kdtree.w,v $
d248 1
a248 1
const char *kdtree_rcs_id = "$Id: kdtree.w,v 1.145 1997/01/17 21:15:44 neto Exp $";
@


1.145
log
@Fixed a printing leak.
@
text
@d11 4
a14 1
{\obeylines$Log:	kdtree.w,v $
d249 1
a249 1
const char *kdtree_rcs_id = "$Id: kdtree.w,v 1.144 96/12/13 15:08:17 neto Exp $";
d1940 1
d1947 3
@


1.144
log
@Mention hypot
@
text
@d12 3
d246 1
a246 1
const char *kdtree_rcs_id = "$Id: kdtree.w,v 1.143 96/12/02 15:26:06 neto Exp $";
d1931 1
a1931 1
		printf("\n");
@


1.143
log
@Added copyright notice.
@
text
@d12 3
d243 1
a243 1
const char *kdtree_rcs_id = "$Id: kdtree.w,v 1.142 96/11/11 16:36:44 neto Exp $";
d1514 3
@


1.142
log
@fixed a spelling mistake.
@
text
@d4 7
d12 3
d240 1
a240 1
const char *kdtree_rcs_id = "$Id: kdtree.w,v 1.141 96/09/03 15:14:03 neto Exp $";
@


1.141
log
@Macro for ML programming language name.
@
text
@d5 3
d230 1
a230 1
const char *kdtree_rcs_id = "$Id: kdtree.w,v 1.140 96/08/16 13:04:53 neto Exp $";
d1494 1
a1494 1
If you need further convincing, then obsevre that both the rounding  
@


1.140
log
@Added fixincludes.
@
text
@d5 3
d227 1
a227 1
const char *kdtree_rcs_id = "$Id: kdtree.w,v 1.139 96/08/16 12:42:26 neto Exp $";
d1671 1
a1671 1
style, as is common in, say, Scheme or ML.
d1805 1
a1805 1
In a language such as Haskell, ML, or Scheme, where it is convenient to 
@


1.139
log
@Converted putchar to printf.  Otherwise, I'd never get a prototype
for SunOS' \_flusbuf.
@
text
@d5 4
d224 1
a224 1
const char *kdtree_rcs_id = "$Id: kdtree.w,v 1.138 96/08/15 14:20:27 neto Exp $";
d697 1
@


1.138
log
@Fixed the prototype for E2\_rnn
@
text
@d5 3
d220 1
a220 1
const char *kdtree_rcs_id = "$Id: kdtree.w,v 1.137 96/08/15 12:54:30 neto Exp $";
d1258 1
a1258 1
/* |putchar('h');| */
d1901 1
a1901 1
		putchar('\n');
d1921 1
a1921 1
verb(1000){ int i; for (i=0;i<level;i++) putchar(' '); }
@


1.137
log
@Make it pass -Wall
@
text
@d5 3
d217 1
a217 1
const char *kdtree_rcs_id = "$Id: kdtree.w,v 1.136 96/07/30 17:15:34 neto Exp $";
d288 1
a288 1
void E2_destroy();
d673 1
a673 1
E2_destroy() {
@


1.136
log
@Fixed editing bug with respect to recurse if not hidden in E2\_rnn.
@
text
@d5 3
d214 1
a214 1
const char *kdtree_rcs_id = "$Id: kdtree.w,v 1.135 96/07/30 13:03:33 neto Exp $";
a876 1
int n = hi-lo;
d1666 1
a1666 1
	E2_node_t *node = E2_point_to_bucket[c], *p=node;
d1755 2
a1756 2
	if ( node->f.i.cutdimen == 0 && E2_nn_seed_x < node->f.i.cutvalue 
		@@| || node->f.i.cutdimen == 1 && E2_nn_seed_y < node->f.i.cutvalue ) {
a1900 1
	int i;
@


1.135
log
@Fixed to compile.
@
text
@d5 3
d211 1
a211 1
const char *kdtree_rcs_id = "$Id: kdtree.w,v 1.134 96/07/30 12:59:52 neto Exp $";
a1615 1
	E2_rnn(p->f.i.lo_child);
@


1.134
log
@Added KD\_BUILD\_SMALLEST\_SEGMENT\_FIRST
@
text
@d5 3
d208 1
a208 1
const char *kdtree_rcs_id = "$Id: kdtree.w,v 1.133 96/07/29 17:08:56 neto Exp $";
d1098 1
a1098 1
	else if ( m <= h ) { @@<Build $=$ tree@@> @@+ @@<Build $>$ tree@@> + @@<Build $<$ tree@@> }
@


1.133
log
@Fixed to compile.
@
text
@d5 3
d205 1
a205 1
const char *kdtree_rcs_id = "$Id: kdtree.w,v 1.132 96/07/29 16:19:56 neto Exp $";
a1083 13
%%%Build the subtrees=
%%%{ int l = b-a, m = hi-(d-c)-lo+b-a, h = d-c;
%%%if ( l <= m ) {
%%%	if ( m <= h ) { <Build $<$ tree> + <Build $=$ tree> + 
%%%		<Build $>$ tree> }
%%%	else if ( l <= h ) { <Build $<$ tree> + <Build $>$ tree> + <Build $=$ tree> }
%%%	else { <Build $>$ tree> + <Build $<$ tree> + <Build $=$ tree> }
%%%} else {
%%%	if ( l <= h ) { <Build $=$ tree> + <Build $<$ tree> + <Build $>$ tree> }
%%%	else if ( m <= h ) { <Build $=$ tree> + <Build $>$ tree> + <Build $<$ tree> }
%%%	else { <Build $>$ tree> + <Build $=$ tree> + <Build $<$ tree> }
%%%}
%%%}
d1086 16
a1101 2
@@<Build $<$ tree@@> @@;
@@<Build $=$ tree@@> @@;
d1103 1
@


1.132
log
@Added *\_rcs\_id.
Made sure RCS log is activated within this file.
@
text
@d5 4
a191 1
const char kdtree_rcs_id[] = "$Id$";
d202 1
@


1.131
log
@Report experiments with hidden bit.
@
text
@d5 3
d188 1
d204 1
@


1.130
log
@Added KD\_NO\_HIDDEN\_RNN\_TEST
@
text
@d5 3
d9 1
a9 1
Added compile-time-option KD_IGNORE_HIDDEN_BIT
d411 1
a411 1
#if !defined(KD_IGNORE_HIDDEN_BIT)
d737 1
a737 1
#if !defined(KD_IGNORE_HIDDEN_BIT)
d1226 1
a1226 1
#if !defined(KD_IGNORE_HIDDEN_BIT)
d1281 1
a1281 1
#if !defined(KD_IGNORE_HIDDEN_BIT)
d1300 1
a1300 1
#if !defined(KD_IGNORE_HIDDEN_BIT)
d1327 1
a1327 1
#if !defined(KD_IGNORE_HIDDEN_BIT)
d1332 1
a1332 1
#if !defined(KD_IGNORE_HIDDEN_BIT)
d1364 1
a1364 1
#if !defined(KD_IGNORE_HIDDEN_BIT)
d1368 1
a1368 1
#if !defined(KD_IGNORE_HIDDEN_BIT)
d1512 1
a1512 1
One might worry about stack overflow in the case that the tree is rather
d1534 8
d1543 42
d1586 1
a1586 1
#if !defined(KD_IGNORE_HIDDEN_BIT) && !defined(KD_NO_HIDDEN_RNN_TEST)
d1736 1
a1736 1
#if !defined(KD_IGNORE_HIDDEN_BIT)
d1746 1
a1746 1
#if !defined(KD_IGNORE_HIDDEN_BIT)
@


1.129
log
@Added compile-time-option KD_IGNORE_HIDDEN_BIT
@
text
@d5 3
d1533 1
a1533 1
#if !defined(KD_IGNORE_HIDDEN_BIT)
d1905 1
@


1.128
log
@Recurse in rnn ony if not hidden.
@
text
@d5 3
d405 1
d407 1
d731 1
d733 1
d1220 1
d1232 1
d1275 1
d1280 1
d1294 1
d1296 3
d1321 1
d1323 1
d1326 1
d1330 5
d1358 1
d1360 1
d1362 1
d1364 1
a1527 1
@@d recurse_if_not_hidden(P) if (!(P)->hidden) E2_rnn(P)
d1530 5
d1680 1
d1684 5
d1690 1
d1694 5
@


1.127
log
@Don't be preachy about recursing on largest last.
@
text
@d5 3
d1059 1
a1059 1
%%%@@<Build the subtrees@@>=
d1062 4
a1065 4
%%%	if ( m <= h ) { @@<Build $<$ tree@@> @@+ @@<Build $=$ tree@@> @@+ 
%%%		@@<Build $>$ tree@@> }
%%%	else if ( l <= h ) { @@<Build $<$ tree@@> @@+ @@<Build $>$ tree@@> @@+ @@<Build $=$ tree@@> }
%%%	else { @@<Build $>$ tree@@> @@+ @@<Build $<$ tree@@> @@+ @@<Build $=$ tree@@> }
d1067 3
a1069 3
%%%	if ( l <= h ) { @@<Build $=$ tree@@> @@+ @@<Build $<$ tree@@> @@+ @@<Build $>$ tree@@> }
%%%	else if ( m <= h ) { @@<Build $=$ tree@@> @@+ @@<Build $>$ tree@@> @@+ @@<Build $<$ tree@@> }
%%%	else { @@<Build $>$ tree@@> @@+ @@<Build $=$ tree@@> @@+ @@<Build $<$ tree@@> }
d1216 1
d1501 1
d1508 1
d1511 2
a1512 2
		E2_rnn(p->f.i.eq_child);
		E2_rnn(p->f.i.hi_child);
d1515 1
a1515 1
	E2_rnn(p->f.i.hi_child);
d1517 2
a1518 2
		E2_rnn(p->f.i.eq_child);
		E2_rnn(p->f.i.lo_child);
d1521 3
a1523 3
	E2_rnn(p->f.i.eq_child);
	E2_rnn(p->f.i.lo_child);
	E2_rnn(p->f.i.hi_child);
@


1.126
log
@Fixed some minor editing of english.
Replaced INFINITY by a computed (floating point!) upper bound.
Isolated debugging output and made it subject to verbose value and
compile-time choices.
@
text
@d5 6
d999 11
a1009 5
A common trick in Quicksort implementations is to recurse on the 
smaller-size array segment first.  This leaves the larger segment waiting
in the activation record on the stack.   This strategy ensures that
there are at most $\log_2 n$ activation records on the stack, protecting
us from stack overflow.
d1011 1
d1013 7
a1019 3
Interestingly, many people know this trick, but a significant fraction
of them get it backwards: they recurse on the {\it larger\/} segment
first.  Knuth (CHECK THIS) comments on this phenomenon, and wags his finger
d1021 1
a1021 1
appropriately.
d1023 46
a1068 7
Here, we have three segments on which we recurse.  A moment's thought tells
us 
to recurse on the smallest first, the next smallest second, and the largest
last.  This still guarantees that there are at most $\log_{2} n$ activation
records on the stack: because the smallest segment is at most one third
of the remaining elements, and the middle segment is at most half the
remaining elements.
a1069 9
We only need the largest segment last in order to guarantee this logarithmic
bound.  Arranging to meet  
this simpler condition isn't much less work: one fewer
integer comparison in the worst case.
I didn't realize this until after I coded the following, which arranges
the
stronger small-medium-large order, so I left it in.


d1071 3
a1073 12
{ int l = b-a, m = hi-(d-c)-lo+b-a, h = d-c;
if ( l <= m ) {
	if ( m <= h ) { @@<Build $<$ tree@@> @@+ @@<Build $=$ tree@@> @@+ 
		@@<Build $>$ tree@@> }
	else if ( l <= h ) { @@<Build $<$ tree@@> @@+ @@<Build $>$ tree@@> @@+ @@<Build $=$ tree@@> }
	else { @@<Build $>$ tree@@> @@+ @@<Build $<$ tree@@> @@+ @@<Build $=$ tree@@> }
} else {
	if ( l <= h ) { @@<Build $=$ tree@@> @@+ @@<Build $<$ tree@@> @@+ @@<Build $>$ tree@@> }
	else if ( m <= h ) { @@<Build $=$ tree@@> @@+ @@<Build $>$ tree@@> @@+ @@<Build $<$ tree@@> }
	else { @@<Build $>$ tree@@> @@+ @@<Build $=$ tree@@> @@+ @@<Build $<$ tree@@> }
}
}
d1097 1
@


1.125
log
@More info to catch dsj1000 bug.
@
text
@d5 3
d140 2
a141 1
if we can completely recover any of its old states; we say it is 
d157 1
a157 1
object-oriented code handling.  Besides, the code that Bentley describes
d198 1
a198 1
The names of the procedures all begin with |E2| to reflect this fact.
d205 1
a205 1
in the \module{read} module.
d257 2
a258 2
@@ We need the interface to the \module{read} module.  In turn,
it needs the \module{length} module.
d412 1
a412 1
In terms of defining our data structure, if we only compare occasionally,
d421 1
a421 1
this scheme uses $s+2k$ words as compared to $2sk$ words.
d567 1
a567 1
We'll put in blanks to be filled in later when we introduce the
d651 5
a655 3
those which precede the pivot, which we put in the |lo_child| subtree, 
and those which follow the piviot, which we put in the |hi_child| subtree.  
Then we recursively build the two subtrees.
d678 2
a679 2
errorif(tsp->edge_weight_type != EUC_2D,"Trying to construct a 2-d tree"
		"when not a EUC_2D instance");
d753 1
a753 1
So checking for an |NULL| pointer {\it every\/} time I want to visit a node
d861 1
a861 1
for the median, I will stick to the Bentley and McIlroy solution.
d894 1
a894 1
be move all the lesser elements to the front, the greater elements to the
d1316 1
a1316 1
I should say up front that most of this code is almost verbatim from
d1379 8
d1391 1
d1393 1
d1413 1
a1413 2
(We use squared distances, as mentioned
earlier.)  
d1418 2
a1419 1
particular.
d1441 10
a1450 2
using pointer reversal. (For an introduction to pointer reversal,
see \S?? in 
d1453 1
a1453 1
Languages}, edited by Simon L.~Peyton Jones (COMPLETE REFERENCE).
d1455 1
a1455 1
Both these measures appear a bit drastic for now.  So I'll make the 
d1465 1
a1465 1
	if ( E2_nn_dist_sq >= diff*diff ) {
d1471 1
a1471 1
	if ( E2_nn_dist_sq >= diff*diff ) {
d1485 1
a1485 1
If there are no unhidden neighbours, then we return $-1$.
d1494 1
a1494 1
Admittedly, the |do \hbox{$\ldots$} while (0)| 
d1518 1
a1518 1
	E2_nn_dist = E2_nn_dist_sq = INFINITY;	/* |INFINITY| comes from \file{length.h}*/
d1527 27
d1585 1
a1585 11
		printf("     rnn break: seed=(%0.0f,%0.0f) dist="length_t_spec"\n",
			E2_nn_seed_x, E2_nn_seed_y, length_t_pcast(E2_nn_dist) );
		printf("     seedbb=(%0.0f,%0.0f,%0.0f,%0.0f) bb=(%0.0f,%0.0f,%0.0f,%0.0f)\n",
			E2_nn_seed_x-E2_nn_dist,
			E2_nn_seed_y-E2_nn_dist,
			E2_nn_seed_x+E2_nn_dist,
			E2_nn_seed_y+E2_nn_dist,
			b->xmin,
			b->ymin,
			b->xmax,
			b->ymax);
d1661 1
d1666 1
a1666 1
printf("\nDimension %d\n",THISDIMEN-1);
d1668 4
a1671 4
	if ( i==lo ) printf("Checking lesser: %d %d\n",lo,lo+b-a);
	if ( i==lo+b-a ) printf("Checking equal: %d %d\n",lo+b-a,hi-(d-c));
	if ( i==hi-(d-c) ) printf("Checking greater: %d %d\n",hi-(d-c),hi);
	printf("%d (%.0f,%.0f)\t %.0f %.0f\n",i,valx(i),valy(i),val(i),v); fflush(stdout);
d1706 1
a1706 1
@@<Debug: indent@@> printf("= in x = %f\n",cv);
d1708 1
a1708 1
@@<Debug: indent@@> printf("< in x < %f\n",cv);
d1710 1
a1710 1
@@<Debug: indent@@> printf("> in x > %f\n",cv);
d1716 1
a1716 1
@@<Debug: indent@@> printf("= in y = %f\n",cv);
d1718 1
a1718 1
@@<Debug: indent@@> printf("< in y < %f\n",cv);
d1720 1
a1720 1
@@<Debug: indent@@> printf("> in y > %f\n",cv);
d1728 1
a1728 1
			printf("%d ",perm[i]);
d1751 1
a1751 1
{ int i; for (i=0;i<level;i++) putchar(' '); }
d1756 1
a1756 1
printf("lo %d hi %d\n",lo,hi);
d1761 1
a1761 1
printf("xl %f i %d perm[i] %d %f %f xl\n",xl,i,perm[i], coord[perm[i]].x,
d1772 40
@


1.124
log
@Removed 117 debugging output.
Made bbox checkig optional.
@
text
@d5 4
d1083 1
a1083 1
	errorif (c<0 || c>=n,"Invalid city %d to hide");
d1287 1
a1287 2
	}
	else { 
d1534 11
@


1.123
log
@Fixed the bbox bug.  I wasn't updating the boboounding box
on the b and c elemnts that were swapped.
@
text
@d5 4
a1373 3
if ( E2_nn_seed==117) {
printf(" %d to %d is sqrt(%f)\n",E2_nn_seed,pi, dist_sq);
}
a1374 3
if ( E2_nn_seed==117) {
printf("   new champion\n");
}
a1530 10
		if ( E2_nn_seed == 117 )  {
			printf("     rnn break: seed=(%0.0f,%0.0f) dist=%f\n",E2_nn_seed_x,
				E2_nn_seed_y,E2_nn_dist);
			printf("     seedbb=(%0.0f,%0.0f,%0.0f,%0.0f) bb=(%0.0f,%0.0f,%0.0f,%0.0f)\n",
				E2_nn_seed_x-E2_nn_dist,
				E2_nn_seed_y-E2_nn_dist,
				E2_nn_seed_x+E2_nn_dist,
				E2_nn_seed_y+E2_nn_dist,
				b->xmin, b->ymin, b->xmax, b->ymax);
		}
d1607 1
a1607 1
#ifdef KD_PARANOID
d1699 1
a1699 1
#if 0
@


1.122
log
@More debugging outupt for failure kcase on lin318
@
text
@d4 4
a7 1
{\obeylines$Log: kdtree.w,v $
d710 3
d922 2
d1269 1
a1269 1
@@ This time, a bucket's the live-range index |hi| gets set to |hi_all|,
d1276 4
a1279 2
	p->hidden = 0;
	if ( p->is_bucket ) p->f.e.hi = p->f.e.hi_all;
d1281 1
d1708 22
@


1.121
log
@Simplified the code a bit.
It fails on lin318.tsp
@
text
@d5 4
d1353 1
d1359 3
d1363 3
d1521 13
a1533 1
	&& (b->ymax >= E2_nn_seed_y+E2_nn_dist) ) break;
d1642 1
a1642 1
E2_postscript_show_helper(FILE *ps_out, E2_node_t *node, 
d1651 6
a1656 2
			E2_postscript_show_helper(ps_out,node->f.i.lo_child,xmin,cv,ymin,ymax);
			E2_postscript_show_helper(ps_out,node->f.i.hi_child,cv,xmax,ymin,ymax);
d1661 6
a1666 2
			E2_postscript_show_helper(ps_out,node->f.i.lo_child,xmin,xmax,ymin,cv);
			E2_postscript_show_helper(ps_out,node->f.i.hi_child,xmin,xmax,cv,ymax);
d1669 7
d1683 1
a1683 1
	E2_postscript_show_helper(ps_out,E2_root,
d1693 4
@


1.120
log
@Bounding box every 1/kd\_bucket\_skip fraction, not 1-that fraction.
Big bug removed: bounding box initialization during Dutch National Flag
problem is now fixed.  (Had max's at infinity instead of effectively
negative infinity.)
Factored the nn search in a bucket.  The general case now is free
from checking that it doesn't return the seed.  It should be faster.
Added PostScript debugging output to draw the buckets.
@
text
@d5 9
d1508 2
a1509 2
	&& (b->xmax >= E2_nn_seed_x+E2_nn_dist)
	@@|&& (b->ymin <= E2_nn_seed_y-E2_nn_dist)
d1524 1
d1527 3
a1529 3
		if ( node->f.i.lo_child != last && !node->f.i.lo_child->hidden ) E2_rnn(node->f.i.lo_child);
		if ( node->f.i.eq_child != last && !node->f.i.eq_child->hidden ) E2_rnn(node->f.i.eq_child);
		if ( node->f.i.hi_child != last && !node->f.i.hi_child->hidden ) E2_rnn(node->f.i.hi_child);
d1531 3
a1533 3
		if ( node->f.i.hi_child != last && !node->f.i.hi_child->hidden ) E2_rnn(node->f.i.hi_child);
		if ( node->f.i.eq_child != last && !node->f.i.eq_child->hidden ) E2_rnn(node->f.i.eq_child);
		if ( node->f.i.lo_child != last && !node->f.i.lo_child->hidden ) E2_rnn(node->f.i.lo_child);
@


1.119
log
@Fixed a name of a section.
Fixed bucket search for nearer neighbour.
@
text
@d5 4
d688 1
a688 1
	if ( ++level % kd_bbox_skip ) {
d911 4
a914 2
exl=eyl=lxl=lyl=gxl=gyl=INFINITY;	/* |INFINITY| comes from \file{length.h} */
exh=eyh=lxh=lyh=gxh=gyh=INFINITY;
d1325 10
d1341 8
a1348 12
@@<Search this bucket for a nearer neighbour@@>=
{ int i;
for ( i=p->f.e.lo ; i<p->f.e.hi ; i++ ) {
	int pi = perm[i];
	if ( pi != E2_nn_seed ) {
		float diff_x = coord[pi].x-E2_nn_seed_x, diff_y=coord[pi].y-E2_nn_seed_y;
		float dist_sq = diff_x*diff_x + diff_y*diff_y;
		if ( dist_sq < E2_nn_dist_sq ) {
			E2_nn_dist = sqrt(dist_sq);
			E2_nn_dist_sq = dist_sq;
			E2_nn_incumbent = pi;
		}
a1350 1
}
d1462 2
a1463 2
	E2_nn_dist = E2_nn_dist_sq = INFINITY;
	{@@+E2_node_t *p=node;@@+@@<Search this bucket for a nearer neighbour@@>@@;@@+}
d1471 13
d1602 43
@


1.118
log
@Compiles now.  I had to add |f.i.| to many of the field names.
I also had to add $E2\_nn\_dist$ back in for the bounding box test.
@
text
@d5 4
d188 1
a188 1
to point |i|.
d1048 2
d1054 1
d1328 2
a1329 2
	if ( i!= E2_nn_seed ) {
		int pi = perm[i];
d1422 1
a1422 1
bucket.
d1446 1
a1446 1
	E2_node_t *node = E2_point_to_bucket[c];
d1452 1
a1452 1
	E2_rnn(node);
a1453 1
		
d1455 1
a1455 1
		@@<Search ancestors for nearer neighbours@@>@@;
d1488 1
a1488 1
@@<Search ancestors for nearer neighbours@@>=
@


1.117
log
@Give up on FRNN, ball searching for now.
We don't need them for Greedy / MF heuristic.
@
text
@d5 4
d1074 2
a1075 2
{ int hi_max = node->f.e.hi_max;
	for ( ci=node->f.e.lo;ci<hi_max; ci++ ) {
d1078 1
a1078 1
	errorif(ci==hi_max,"Point %d not found in its bucket",c);
d1129 3
a1131 3
			&& node->lo_child->hidden 
			&& node->eq_child->hidden 
			&& node->hi_child->hidden );
d1218 3
a1220 3
		if(!p->lo_child->hidden)E2_hide_all_helper(p->lo_child);
		if(!p->eq_child->hidden)E2_hide_all_helper(p->eq_child);
		if(!p->hi_child->hidden)E2_hide_all_helper(p->hi_child);
d1245 3
a1247 3
		E2_unhide_all_helper(p->lo_child);
		E2_unhide_all_helper(p->eq_child);
		E2_unhide_all_helper(p->hi_child);
d1283 4
d1294 1
a1294 1
static float E2_nn_dist_sq, E2_nn_seed_x, E2_nn_seed_y;
d1312 6
d1320 1
a1320 1
for ( i=p->lo ; i<p->hi ; i++ ) {
d1326 1
d1334 3
d1387 2
a1388 2
float seed_coord = p->cutdimen==0 ? E2_nn_seed_x : E2_nn_seed_y,
diff = seed_coord - p->cutvalue;
d1390 1
a1390 1
	E2_rnn(p->lo_child);
d1392 2
a1393 2
		E2_rnn(p->eq_child);
		E2_rnn(p->hi_child);
d1396 1
a1396 1
	E2_rnn(p->hi_child);
d1398 2
a1399 2
		E2_rnn(p->eq_child);
		E2_rnn(p->lo_child);
d1402 3
a1404 3
	E2_rnn(p->eq_child);
	E2_rnn(p->lo_child);
	E2_rnn(p->hi_child);
d1420 2
a1421 1
Admittedly, the |if (1)| construction is awkward, but it lets us write
d1446 2
a1447 1
	if (1) {
d1450 1
a1450 1
	}
d1466 1
a1466 1
{ E2_box_t b = node->bbox;
d1485 5
a1489 5
	if ( node->cutdimen == 0 && E2_nn_seed_x < node->cutvalue 
		@@| || node->cutdimen == 1 && E2_nn_seed_y < node->cutvalue ) {
		if ( node->lo_child != last && !node->lo_child->hidden ) E2_rnn(node->lo_child);
		if ( node->eq_child != last && !node->eq_child->hidden ) E2_rnn(node->eq_child);
		if ( node->hi_child != last && !node->hi_child->hidden ) E2_rnn(node->hi_child);
d1491 3
a1493 3
		if ( node->hi_child != last && !node->hi_child->hidden ) E2_rnn(node->hi_child);
		if ( node->eq_child != last && !node->eq_child->hidden ) E2_rnn(node->eq_child);
		if ( node->lo_child != last && !node->lo_child->hidden ) E2_rnn(node->lo_child);
@


1.116
log
@Continued a bit on fixed radius nearest neighbours.
Added more about stack overflow.  Referenced Peyton Jones' Implementing
Functional Languages.
@
text
@d5 5
d1511 5
d1518 3
@


1.115
log
@I forgot to mention the move to using only squared distances in
nearest neighbour search.
@
text
@d5 4
d664 1
a664 1
E2_node_t *
d1175 1
a1175 1
the bulk operation. This is what we choose.
d1347 15
d1500 7
a1506 4
|void E2_frnn(int i, float rad, void (*proc)(int j))| is 
a 
\term{fixed-radius nearest neighbour search}@@^fixed-radius nearest neighbour search@@>.
It calls |proc| on all points |j| that lie within |rad| units of point |i|.
@


1.114
log
@Changed $E2\_tree$ to $E2\_root$.
Implemented $unhide\_all$ and $hide\_all$.
Got started on comments about fixed radius nearest neighbour.
@
text
@d5 5
@


1.113
log
@Added some index references to people.
changed is\_internal to is\_bucket.
Worked on nearest neighbours computation.
@
text
@d5 5
d583 11
d624 1
a624 1
E2_tree = E2_build_helper(NULL,0,0,0,n,
d631 1
a631 1
static E2_node_t *E2_tree;
d885 1
a885 1
exl=eyl=lxl=lyl=gxl=gyl=INFINITY;
d935 1
d999 7
d1007 1
a1007 1
Inside a bucket, we hide a node by moving it to the end of the bucket, and
d1085 4
d1162 70
d1257 6
a1262 4
the best city found so far is |E2_nn_incumbent|, 
and it is at distance
|E2_nn_dist| from the seed city.  Because we're using the Euclidean metric, 
we can compare squared distances instead of actual distances; this 
d1272 1
a1272 1
static float E2_nn_dist, E2_nn_dist_sq, E2_nn_seed_x, E2_nn_seed_y;
a1289 6
When we do find a nearer neighbour, we use the official distance function
|cost|.  I feel safer using it.  It's an irrational reaction, because
with no proof of consistency otherwise, we should use the official cost
function throughout our computations.  Oh well.


d1295 2
a1296 2
		float diffx = coord[pi].x-E2_nn_seed_x, diffy=coord[pi].y-E2_nn_seed_y;
		float dist_sq = diffx*diffx + diffy*diffy;
a1298 1
			E2_nn_dist = cost(pi,E2_nn_seed);	/* Use the ``official'' cost function. */
d1313 5
a1317 1
the cut plane is greater than |E2_nn_dist|.  This tactic 
d1323 2
a1324 1
A clever thing that Bentley does is to first search on the same side of
d1327 2
a1328 1
more likely to be found on the same side as opposed to the  opposite side.
d1335 3
d1340 7
a1346 7
float val = p->cutval,
this_coord = p->cutdimen==0 ? E2_nn_seed_x : E2_nn_seed_y;
if ( this_coord < val ) {
	rnn(p->lo_child);
	if ( this_coord + E2_nn_dist >= val ) {
		rnn(p->eq_child);
		rnn(p->hi_child);
d1348 6
d1355 3
a1357 5
	rnn(p->hi_child);
	if ( this_coord - E2_nn_dist <= val ) {
		rnn(p->eq_child);
		rnn(p->lo_child);
	}
d1364 1
a1372 2
If there are no nearest neighbours, then we return -1.

d1427 2
a1428 1
|E2_rnn| on |last|, the node we've just come from.
d1451 24
d1476 4
a1479 3
@@ ---------
@@ We will be using many routines from external libraries.  The interfaces
to those routines are described in the following headers.
a1480 5
@@<System headers@@>=
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <assert.h>
a1481 2
@@
@@<Other external node fields@@>=
@


1.112
log
@Clarify comments in first part of the document.
Make the recursive building more CWEB-like.
Finished the hiding/unhiding part, but I haven't tried compiling it.
@
text
@d4 6
a9 1
{\obeylines$Log:	kdtree.w,v $
d88 1
a88 1
@@^Tarjan@@>
d135 1
d231 1
a231 1
	char is_internal;
d274 1
d297 1
d348 1
d412 1
d423 1
d587 1
d645 1
a645 1
	node->hidden = lo<hi;
d654 1
a654 1
		node->is_internal = 0;
d660 1
a660 1
		node->is_internal = 1;
d767 1
d822 1
d869 2
a870 6
exl=eyl=lxl=lyl=gxl=gyl=INT_MAX;
exh=eyh=lxh=lyh=gxh=gyh=INT_MIN;

@@
@@<System headers@@>=
#include <limits.h>
d923 1
d1150 5
d1158 2
a1159 1
The best city found so far is recorded in the variable |E2_nn_incumbent|, 
d1166 4
d1171 2
a1172 2
static int E2_nn_incumbent;
static float E2_nn_dist, E2_nn_dist_sq;
d1175 36
d1212 7
a1218 2
It uses a simple distance criterion to prune the search.
It avoids examining a branch if that branch is on the opposite side of the
d1226 56
a1281 1
Inside a bucket, we perform a sequential search.
d1283 13
a1295 8
@@<Module subroutines@@>=
void 
E2_rnn(E2_node_t *p) {
	if ( p->is_internal ) {
		float val = p->cutval,
		this_coord = 
	} else {
		
d1297 21
d1320 3
d1324 21
@


1.111
log
@Added comments about persistence.
Fixed too-long-line for cweave.
Worked on hiding/unhiding
Added to nn.
@
text
@d5 6
d69 2
a70 1
Bentley actually describes the hiding and unhiding as deletion and undeletion.
d72 1
a72 1
prefer the concept of hiding because it seems a more accurate description of
d154 1
a154 1
|int E2_nn(int i)| returns the index of the unhidden point that is nearest
d312 1
a312 1
the average depth of an item is logarithmic in the number of items.
d438 1
a438 1
have shown that some inputs have {\it no} good nearest neighbour cut planes.
d477 1
d617 8
d633 1
a633 1
	node->hidden = 0;
d918 2
a919 2
last.  This guarantees that there are at most $\log_{3/2} n$ activation
records on the stack, because the smallest segment is at most one third
d923 9
a932 6
#define RECURSE_LO node->f.i.lo_child = \
	E2_build_helper(node,flat_dimens,level,lo,lo+b-a,lxl,lxh,lyl,lyh);
#define RECURSE_EQ node->f.i.eq_child = \
	E2_build_helper(node,flat_dimens|THISDIMEN,level,lo+b-a,hi-(d-c),exl,exh,eyl,eyh);
#define RECURSE_HI node->f.i.hi_child = \
	E2_build_helper(node,flat_dimens,level,hi-(d-c),hi,gxl,gxh,gyl,gyh);
d935 4
a938 3
	if ( m <= h ) { RECURSE_LO @@+ RECURSE_EQ @@+ RECURSE_HI }
	else if ( l <= h ) { RECURSE_LO @@+ RECURSE_HI @@+ RECURSE_EQ }
	else { RECURSE_HI @@+ RECURSE_LO @@+ RECURSE_EQ }
d940 3
a942 3
	if ( l <= h ) { RECURSE_EQ @@+ RECURSE_LO @@+ RECURSE_HI }
	else if ( m <= h ) { RECURSE_EQ @@+ RECURSE_HI @@+ RECURSE_LO }
	else { RECURSE_HI @@+ RECURSE_EQ @@+ RECURSE_LO }
d945 24
a968 3
#undef RECURSE_LO
#undef RECURSE_EQ
#undef RECURSE_HI
d988 1
d990 59
d1050 71
d1123 1
d1126 1
a1126 1
nearest neighbour search.  Given a city $i$, we'd like to find the 
d1142 2
a1143 1
The best city found so far is |E2_nn_incumbent|, and it is at distance
d1149 1
a1149 1
@@<Modulre variables@@>=
d1156 1
a1156 1
It avoids search a branch if that branch is on the opposite side of the
d1173 1
@


1.110
log
@Ensure theat recursing won't break the stack.
Start work on nearest neighbour query.
@
text
@d5 4
d62 2
a63 1
(Bentley actually describes the hiding and unhiding as deletion and undeletion.
d65 13
a77 2
prefer the notion of hiding because it seems a more accurate description of
what is going on.)
d908 1
a908 1
@@d RECURSE_LO node->f.i.lo_child =  \
d910 1
a910 1
@@d RECURSE_EQ node->f.i.eq_child =  \
d912 1
a912 1
@@d RECURSE_HI node->f.i.hi_child =  \
d925 3
d929 1
d931 4
d936 15
d966 1
a966 1
@@ We use a recursive helper routine |E2_rnn| to check subtrees.  
d975 3
d979 13
d993 8
a1002 2
To
avoid duplicated work, we pass it a parameter telling it where we came from.
a1013 2
@@
@@<Fill other bucket fields@@>=
@


1.109
log
@Made coord a static variable.
@
text
@d5 3
d819 1
d871 20
d892 1
a892 2
@@<Paranoid: check the partitioning@@>@@;
node->f.i.lo_child = 
d894 1
a894 1
node->f.i.eq_child = 
d896 1
a896 1
node->f.i.hi_child = 
d898 11
d911 31
@


1.108
log
@Be careful with macro parameters.  Parenthesize them.
@
text
@d5 3
d565 1
d569 1
a569 1
E2_tree = E2_build_helper(tsp->coord,NULL,0,0,0,n,
d572 3
a574 1
@@ We need to declare the tree variable.
d577 1
d593 1
a593 1
E2_build_helper(coord_2d *coord,E2_node_t *parent,int flat_dimens,int level,
d870 1
a870 1
	E2_build_helper(coord,node,flat_dimens,level,lo,lo+b-a,lxl,lxh,lyl,lyh);
d872 1
a872 1
	E2_build_helper(coord,node,flat_dimens|THISDIMEN,level,lo+b-a,hi-(d-c),exl,exh,eyl,eyh);
d874 1
a874 1
	E2_build_helper(coord,node,flat_dimens,level,hi-(d-c),hi,gxl,gxh,gyl,gyh);
@


1.107
log
@This file was added after I went to 100 and above.
@
text
@d5 3
d362 1
a362 1
@@d free_box(P) pool_free(box_pool,P)
d493 1
a493 1
@@d free_node(P) pool_free(node_pool,P)
d742 3
a744 3
@@d val(a) (coord[perm[a]].CUTFIELD)
@@d valx(a) (coord[perm[a]].x)
@@d valy(a) (coord[perm[a]].y)
@


1.6
log
@Fixed my in-file log.  (I edited, saved, and committed the revision,
but didn't reload before the next commit...)
@
text
@d5 4
@


1.5
log
@Removed some printing clutter.
@
text
@d5 12
@


1.4
log
@Most importantly, I fixed the construction bug.  The code that was
moving equal elements to the middle did not handle the left end properly.
It was 0-based instead of being based at the real lower end: lo.

I added comments about what to do with an empty bucket, and why.

I added better paranoid checking diagnostics.
@
text
@a762 1
printf("\n");
a763 1
	printf("a,b,c,d %d %d %d %d\n", a,b,c,d);
d872 1
a872 1
printf("Dimension %d\n",THISDIMEN-1);
@


1.3
log
@Added missing break.
Fixed a swap.  Duh.
More precise output.
@
text
@d5 5
d564 1
d593 19
d763 1
d836 2
a837 2
s=min(a,b-a);	/* Move first set of equals to middle. */
for(l=0,h=b-s;s;s--) {t=perm[l];@@+perm[l]=perm[h];@@+perm[h]=t;l++;h++;}
d874 7
a880 1
printf("\nDimension %d, Checking lesser: %d %d\n",THISDIMEN-1,lo,lo+b-a);
a881 1
	printf("%d (%.0f,%.0f)\t %.0f %.0f\n",i,valx(i),valy(i),val(i),v); fflush(stdout);
a883 1
printf("Checking equal: %d %d\n",lo+b-a,hi-(d-c));
a884 1
	printf("%d (%.0f,%.0f)\t %.0f %.0f\n",i,valx(i),valy(i),val(i),v); fflush(stdout);
a886 1
printf("Checking greater: %d %d\n",hi-(d-c),hi);
a887 1
	printf("%d (%.0f,%.0f)\t %.0f %.0f\n",i,valx(i),valy(i),val(i),v); fflush(stdout);
@


1.2
log
@Fixed typo in med3 computation.
Added better debugging output for paranoid.
Fails paranoid check on lin105.tsp
@
text
@d5 5
d633 1
d753 1
a753 1
			t=perm[d];@@+perm[d]=perm[c];@@+perm[d]=t;
d848 1
a848 1
printf("\nDimension %d, Checking lesser: %d %d\n",THISDIMEN-1,lo,hi);
@


1.1
log
@Initial revision
@
text
@d4 4
a7 1
{\obeylines$Log:$
d708 1
a708 1
	p = med3(p1,p,p);	/* Mid-size, median of 3. */
d733 1
d841 2
a842 1
{ int i; double v = val(p);
d844 2
a845 1
	errorif(val(i)>=v,"Bug!");
d847 1
d849 2
a850 1
	errorif(val(i)!=v,"Bug!");
d852 4
a855 2
for (i=lo+b-a;i<hi-(d-c);i++) {
	errorif(val(i)<=v,"Bug!");
@
