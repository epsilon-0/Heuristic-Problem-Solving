head	1.251;
access
	david
	neto;
symbols
	zero-four-zero:1.251;
locks
	neto:1.251;


1.251
date	98.07.16.21.58.55;	author neto;	state Exp;
branches;
next	1.250;

1.250
date	98.06.19.16.39.17;	author neto;	state Exp;
branches;
next	1.249;

1.249
date	98.05.29.21.01.10;	author neto;	state Exp;
branches;
next	1.248;

1.248
date	98.05.23.18.23.32;	author neto;	state Exp;
branches;
next	1.247;

1.247
date	98.05.23.18.09.57;	author neto;	state Exp;
branches;
next	1.246;

1.246
date	98.05.23.17.31.25;	author neto;	state Exp;
branches;
next	1.245;

1.245
date	98.05.23.16.22.53;	author neto;	state Exp;
branches;
next	1.244;

1.244
date	98.05.21.15.46.08;	author neto;	state Exp;
branches;
next	1.243;

1.243
date	98.04.10.15.13.31;	author neto;	state Exp;
branches;
next	1.242;

1.242
date	98.02.21.04.05.19;	author neto;	state Exp;
branches;
next	1.241;

1.241
date	98.01.23.21.04.55;	author neto;	state Exp;
branches;
next	1.240;

1.240
date	97.12.20.20.44.12;	author neto;	state Exp;
branches;
next	1.239;

1.239
date	97.12.20.20.31.25;	author neto;	state Exp;
branches;
next	1.238;

1.238
date	97.12.20.18.38.16;	author neto;	state Exp;
branches;
next	1.237;

1.237
date	97.12.19.20.46.37;	author neto;	state Exp;
branches;
next	1.236;

1.236
date	97.12.13.21.31.04;	author neto;	state Exp;
branches;
next	1.235;

1.235
date	97.12.13.21.28.15;	author neto;	state Exp;
branches;
next	1.234;

1.234
date	97.12.13.16.47.54;	author neto;	state Exp;
branches;
next	1.233;

1.233
date	97.12.05.21.42.32;	author neto;	state Exp;
branches;
next	1.232;

1.232
date	97.11.14.22.53.44;	author neto;	state Exp;
branches;
next	1.231;

1.231
date	97.10.18.18.09.11;	author neto;	state Exp;
branches;
next	1.230;

1.230
date	97.10.18.14.47.50;	author neto;	state Exp;
branches;
next	1.229;

1.229
date	97.10.17.21.48.15;	author neto;	state Exp;
branches;
next	1.228;

1.228
date	97.10.17.21.01.11;	author neto;	state Exp;
branches;
next	1.227;

1.227
date	97.09.27.18.06.21;	author neto;	state Exp;
branches;
next	1.226;

1.226
date	97.09.12.21.30.04;	author neto;	state Exp;
branches;
next	1.225;

1.225
date	97.08.15.20.18.25;	author neto;	state Exp;
branches;
next	1.224;

1.224
date	97.08.15.16.59.29;	author neto;	state Exp;
branches;
next	1.223;

1.223
date	97.08.15.16.19.19;	author neto;	state Exp;
branches;
next	1.222;

1.222
date	97.08.14.20.19.46;	author neto;	state Exp;
branches;
next	1.221;

1.221
date	97.06.19.19.41.34;	author neto;	state Exp;
branches;
next	1.220;

1.220
date	97.06.17.21.45.20;	author neto;	state Exp;
branches;
next	1.219;

1.219
date	97.06.17.21.32.47;	author neto;	state Exp;
branches;
next	1.218;

1.218
date	97.06.17.20.28.42;	author neto;	state Exp;
branches;
next	1.217;

1.217
date	97.06.16.20.45.00;	author neto;	state Exp;
branches;
next	1.216;

1.216
date	97.06.16.20.24.52;	author neto;	state Exp;
branches;
next	1.215;

1.215
date	97.06.16.17.35.12;	author neto;	state Exp;
branches;
next	1.214;

1.214
date	97.06.16.17.20.52;	author neto;	state Exp;
branches;
next	1.213;

1.213
date	97.06.16.16.38.10;	author neto;	state Exp;
branches;
next	1.212;

1.212
date	97.06.16.16.33.44;	author neto;	state Exp;
branches;
next	1.211;

1.211
date	97.06.16.16.07.26;	author neto;	state Exp;
branches;
next	1.210;

1.210
date	97.06.13.22.12.45;	author neto;	state Exp;
branches;
next	1.209;

1.209
date	97.06.13.21.59.58;	author neto;	state Exp;
branches;
next	1.208;

1.208
date	97.06.13.21.49.29;	author neto;	state Exp;
branches;
next	1.207;

1.207
date	97.06.13.21.39.08;	author neto;	state Exp;
branches;
next	1.206;

1.206
date	97.06.13.21.16.06;	author neto;	state Exp;
branches;
next	1.205;

1.205
date	97.06.13.21.01.59;	author neto;	state Exp;
branches;
next	1.204;

1.204
date	97.06.13.20.59.29;	author neto;	state Exp;
branches;
next	1.203;

1.203
date	97.06.13.20.32.09;	author neto;	state Exp;
branches;
next	1.202;

1.202
date	97.06.13.20.28.08;	author neto;	state Exp;
branches;
next	1.201;

1.201
date	97.06.13.20.16.23;	author neto;	state Exp;
branches;
next	1.200;

1.200
date	97.06.13.19.49.27;	author neto;	state Exp;
branches;
next	1.199;

1.199
date	97.06.13.18.44.11;	author neto;	state Exp;
branches;
next	1.198;

1.198
date	97.06.13.18.17.30;	author neto;	state Exp;
branches;
next	1.197;

1.197
date	97.05.16.21.15.06;	author neto;	state Exp;
branches;
next	1.196;

1.196
date	97.05.16.21.13.33;	author neto;	state Exp;
branches;
next	1.195;

1.195
date	97.05.16.20.37.20;	author neto;	state Exp;
branches;
next	1.194;

1.194
date	97.05.16.18.11.41;	author neto;	state Exp;
branches;
next	1.193;

1.193
date	97.05.16.18.09.40;	author neto;	state Exp;
branches;
next	1.192;

1.192
date	97.02.11.16.08.50;	author neto;	state Exp;
branches;
next	1.191;

1.191
date	97.02.10.19.32.36;	author neto;	state Exp;
branches;
next	1.190;

1.190
date	97.01.27.16.43.48;	author neto;	state Exp;
branches;
next	1.189;

1.189
date	97.01.27.16.41.02;	author neto;	state Exp;
branches;
next	1.188;

1.188
date	97.01.21.22.30.17;	author david;	state Exp;
branches;
next	1.187;

1.187
date	97.01.21.21.55.55;	author david;	state Exp;
branches;
next	1.186;

1.186
date	97.01.21.17.48.24;	author david;	state Exp;
branches;
next	1.185;

1.185
date	97.01.21.17.26.31;	author david;	state Exp;
branches;
next	1.184;

1.184
date	97.01.21.17.23.46;	author david;	state Exp;
branches;
next	1.183;

1.183
date	97.01.21.16.33.44;	author david;	state Exp;
branches;
next	1.182;

1.182
date	97.01.21.16.22.34;	author david;	state Exp;
branches;
next	1.181;

1.181
date	97.01.21.16.12.53;	author david;	state Exp;
branches;
next	1.180;

1.180
date	97.01.21.16.10.23;	author david;	state Exp;
branches;
next	1.179;

1.179
date	97.01.21.15.37.41;	author david;	state Exp;
branches;
next	1.178;

1.178
date	97.01.21.01.52.54;	author david;	state Exp;
branches;
next	1.177;

1.177
date	97.01.21.00.18.10;	author david;	state Exp;
branches;
next	1.176;

1.176
date	97.01.20.23.49.31;	author david;	state Exp;
branches;
next	1.175;

1.175
date	97.01.20.19.50.46;	author david;	state Exp;
branches;
next	1.174;

1.174
date	97.01.20.19.45.56;	author david;	state Exp;
branches;
next	1.173;

1.173
date	97.01.20.19.44.31;	author david;	state Exp;
branches;
next	1.172;

1.172
date	97.01.17.22.11.41;	author neto;	state Exp;
branches;
next	1.171;

1.171
date	97.01.17.20.38.05;	author neto;	state Exp;
branches;
next	1.170;

1.170
date	97.01.17.19.43.19;	author neto;	state Exp;
branches;
next	1.169;

1.169
date	97.01.16.22.19.02;	author neto;	state Exp;
branches;
next	1.168;

1.168
date	97.01.16.14.20.22;	author neto;	state Exp;
branches;
next	1.167;

1.167
date	96.12.16.16.56.30;	author neto;	state Exp;
branches;
next	1.166;

1.166
date	96.12.13.15.14.03;	author neto;	state Exp;
branches;
next	1.165;

1.165
date	96.12.13.15.08.50;	author neto;	state Exp;
branches;
next	1.164;

1.164
date	96.12.13.14.49.28;	author neto;	state Exp;
branches;
next	1.163;

1.163
date	96.12.12.14.01.35;	author neto;	state Exp;
branches;
next	1.162;

1.162
date	96.12.12.14.01.09;	author neto;	state Exp;
branches;
next	1.161;

1.161
date	96.12.05.16.13.54;	author neto;	state Exp;
branches;
next	1.160;

1.160
date	96.12.05.16.00.59;	author neto;	state Exp;
branches;
next	1.159;

1.159
date	96.12.05.15.57.08;	author neto;	state Exp;
branches;
next	1.158;

1.158
date	96.12.05.15.55.57;	author neto;	state Exp;
branches;
next	1.157;

1.157
date	96.12.05.15.35.46;	author neto;	state Exp;
branches;
next	1.156;

1.156
date	96.12.05.15.29.19;	author neto;	state Exp;
branches;
next	1.155;

1.155
date	96.12.05.15.27.51;	author neto;	state Exp;
branches;
next	1.154;

1.154
date	96.12.05.15.25.37;	author neto;	state Exp;
branches;
next	1.153;

1.153
date	96.12.05.15.00.38;	author neto;	state Exp;
branches;
next	1.152;

1.152
date	96.12.05.14.54.59;	author neto;	state Exp;
branches;
next	1.151;

1.151
date	96.12.05.14.41.05;	author neto;	state Exp;
branches;
next	1.150;

1.150
date	96.11.08.15.49.55;	author neto;	state Exp;
branches;
next	1.149;

1.149
date	96.09.19.15.41.47;	author neto;	state Exp;
branches;
next	1.148;

1.148
date	96.09.18.17.16.52;	author neto;	state Exp;
branches;
next	1.147;

1.147
date	96.09.18.16.42.38;	author neto;	state Exp;
branches;
next	1.146;

1.146
date	96.09.18.16.39.49;	author neto;	state Exp;
branches;
next	1.145;

1.145
date	96.09.18.16.22.10;	author neto;	state Exp;
branches;
next	1.144;

1.144
date	96.09.17.14.28.52;	author neto;	state Exp;
branches;
next	1.143;

1.143
date	96.09.17.14.07.18;	author neto;	state Exp;
branches;
next	1.142;

1.142
date	96.09.12.14.15.07;	author neto;	state Exp;
branches;
next	1.141;

1.141
date	96.09.12.14.08.10;	author neto;	state Exp;
branches;
next	1.140;

1.140
date	96.09.12.14.05.44;	author neto;	state Exp;
branches;
next	1.139;

1.139
date	96.09.11.16.37.48;	author neto;	state Exp;
branches;
next	1.138;

1.138
date	96.09.10.16.21.26;	author neto;	state Exp;
branches;
next	1.137;

1.137
date	96.08.23.17.24.32;	author david;	state Exp;
branches;
next	1.136;

1.136
date	96.08.23.15.40.41;	author david;	state Exp;
branches;
next	1.135;

1.135
date	96.08.20.11.30.40;	author neto;	state Exp;
branches;
next	1.134;

1.134
date	96.08.16.16.59.37;	author neto;	state Exp;
branches;
next	1.133;

1.133
date	96.08.16.16.56.43;	author neto;	state Exp;
branches;
next	1.132;

1.132
date	96.08.16.16.49.58;	author neto;	state Exp;
branches;
next	1.131;

1.131
date	96.08.16.13.36.01;	author neto;	state Exp;
branches;
next	1.130;

1.130
date	96.08.16.13.32.04;	author neto;	state Exp;
branches;
next	1.129;

1.129
date	96.08.16.13.04.58;	author neto;	state Exp;
branches;
next	1.128;

1.128
date	96.08.16.12.42.06;	author neto;	state Exp;
branches;
next	1.127;

1.127
date	96.08.15.14.45.51;	author neto;	state Exp;
branches;
next	1.126;

1.126
date	96.08.15.13.29.00;	author neto;	state Exp;
branches;
next	1.125;

1.125
date	96.08.15.12.36.18;	author neto;	state Exp;
branches;
next	1.124;

1.124
date	96.08.14.15.16.42;	author neto;	state Exp;
branches;
next	1.123;

1.123
date	96.08.14.14.45.14;	author neto;	state Exp;
branches;
next	1.122;

1.122
date	96.08.14.14.41.38;	author neto;	state Exp;
branches;
next	1.121;

1.121
date	96.08.14.14.37.27;	author neto;	state Exp;
branches;
next	1.120;

1.120
date	96.08.14.13.48.56;	author neto;	state Exp;
branches;
next	1.119;

1.119
date	96.08.02.14.38.42;	author neto;	state Exp;
branches;
next	1.118;

1.118
date	96.08.02.14.10.52;	author neto;	state Exp;
branches;
next	1.117;

1.117
date	96.07.30.16.29.32;	author neto;	state Exp;
branches;
next	1.116;

1.116
date	96.07.29.17.08.19;	author neto;	state Exp;
branches;
next	1.115;

1.115
date	96.07.29.16.20.02;	author neto;	state Exp;
branches;
next	1.114;

1.114
date	96.07.26.16.20.30;	author neto;	state Exp;
branches;
next	1.113;

1.113
date	96.07.25.14.05.12;	author neto;	state Exp;
branches;
next	1.112;

1.112
date	96.07.25.12.08.52;	author neto;	state Exp;
branches;
next	1.111;

1.111
date	96.07.24.15.56.44;	author neto;	state Exp;
branches;
next	1.110;

1.110
date	96.07.15.22.28.29;	author david;	state Exp;
branches;
next	1.109;

1.109
date	96.07.15.21.21.03;	author david;	state Exp;
branches;
next	1.108;

1.108
date	96.07.15.19.06.06;	author david;	state Exp;
branches;
next	1.107;

1.107
date	96.07.15.18.31.58;	author david;	state Exp;
branches;
next	1.106;

1.106
date	96.06.26.11.44.06;	author neto;	state Exp;
branches;
next	1.105;

1.105
date	96.06.26.10.57.37;	author neto;	state Exp;
branches;
next	1.104;

1.104
date	96.05.30.13.45.11;	author neto;	state Exp;
branches;
next	1.103;

1.103
date	96.05.30.13.26.08;	author neto;	state Exp;
branches;
next	1.102;

1.102
date	96.05.29.17.28.48;	author neto;	state Exp;
branches;
next	1.101;

1.101
date	96.05.29.13.53.58;	author neto;	state Exp;
branches;
next	1.100;

1.100
date	96.05.29.11.13.16;	author neto;	state Exp;
branches;
next	1.10;

1.10
date	96.05.29.11.05.44;	author neto;	state Exp;
branches;
next	1.9;

1.9
date	96.05.24.16.43.45;	author neto;	state Exp;
branches;
next	1.8;

1.8
date	96.05.22.17.12.16;	author neto;	state Exp;
branches;
next	1.7;

1.7
date	96.05.22.17.08.37;	author neto;	state Exp;
branches;
next	1.6;

1.6
date	96.05.22.16.13.13;	author neto;	state Exp;
branches;
next	1.5;

1.5
date	96.05.22.15.50.19;	author neto;	state Exp;
branches;
next	1.4;

1.4
date	96.05.22.14.34.42;	author neto;	state Exp;
branches;
next	1.3;

1.3
date	96.05.22.10.55.27;	author neto;	state Exp;
branches;
next	1.2;

1.2
date	96.03.15.15.59.57;	author neto;	state Exp;
branches;
next	1.1;

1.1
date	96.03.04.13.54.32;	author neto;	state Exp;
branches;
next	;


desc
@The top module in the Lin-Kernighan program.
@


1.251
log
@Added the LGPL notice in each file.
@
text
@


\noindent Copyright \copyright 1994, 1995, 1996, 1997, 1998 David Neto
\smallskip

\noindent 
   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Library General Public
   License as published by the Free Software Foundation; either
   version 2 of the License, or (at your option) any later version.
\smallskip

\noindent 
   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.
\smallskip

\noindent   
   You should have received a copy of the GNU Library General Public
   License along with this library; if not, write to the
   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA  02111-1307, USA.
\smallskip

\noindent   
   You may contact David Neto via email at {\tt netod@@@@acm.org}, or with
   greater latency at
\smallskip
\noindent{\obeylines
     Department of Computer Science
     University of Toronto
     10 King's College Rd.
     Toronto, Ontario
     M5S 3G4
     Canada
}
\medskip


\noindent\hbox{}\hrule\hbox{}\penalty-1000
\vskip0.5cm\relax



@@i webdefs.w
@@i types.w

{\obeylines
$Log: lk.w,v $
Revision 1.250  1998/06/19 16:39:17  neto
Check that the upper bound is given when computing held karp lower bounds.
Of course, I could always compute it on the fly....

Revision 1.249  1998/05/29 21:01:10  neto
Off by a factor of 100 in calculation of percentage for Held Karp.

Revision 1.248  1998/05/23 18:23:32  neto
Doh.  Was discarding the held karp bound. Fixed. I hope

Revision 1.247  1998/05/23 18:09:57  neto
Needed casts around length t stuff in held karp bounds.

Revision 1.246  1998/05/23 17:31:25  neto
This now compiles to .o.
(The cleanup function needs access to do weighted perfect matching.
But it doesn't handle held karp only...)

Revision 1.245  1998/05/23 16:22:53  neto
Added proper setup of held-karp lower bound.
Added options for upper bound.  Change -b to -l, a lower bound.
Added options for held karp computations.

Revision 1.244  1998/05/21 15:46:08  neto
New interface to match run

Revision 1.243  1998/04/10 15:13:31  neto
Made safe for non-E2 instances

Revision 1.242  1998/02/21 04:05:19  neto
Added support for Iterated LK (for TSP).
Also fixed some output stuff for matching.

Revision 1.241  1998/01/23  21:04:55  neto
Now it compiles well with match module.
Fixed some printing minor errors.

Revision 1.240  1997/12/20 20:44:12  neto
Changed variable "start tour" to "construction algorithm".
It's more descriptive and more accurate.

Revision 1.239  1997/12/20 20:31:25  neto
Import the matching header.
Fix raw lengths if CEIL 2D.
Export comparison functions for double and length t.

Revision 1.238  1997/12/20 18:38:16  neto
Added first draft of support for doing minimum weighted perfect matchings.

Revision 1.237  1997/12/19  20:46:37  neto
Fixed the calls to decluster mst and preprocess: I was passing the
instance to the wrong procedure.

Revision 1.236  1997/12/13 21:31:04  neto
Ooops, I put it in the wrong place!

Revision 1.235  1997/12/13 21:28:15  neto
decluster mst now takes the tsp instance argument instead of relying on
a global variable.

Revision 1.234  1997/12/13 16:47:54  neto
Updated to new interface with error module.
Made all module names upper case.

Revision 1.233  1997/12/05  21:42:32  neto
It's Moore's curve, dodo.  :)

Revision 1.232  1997/11/14  22:53:44  neto
Output starting tour if verbose is high and postscript is on.

Revision 1.231  1997/10/18  18:09:11  neto
Convert to new protocol for nearest neighbours.

Revision 1.230  1997/10/18 14:47:50  neto
Now we use E2 supports() for more intelligent construction or non-construction
of 2-d trees.

Revision 1.229  1997/10/17  21:48:15  neto
Changed coord\_2d structure.

Revision 1.228  1997/10/17  21:01:11  neto
Added begin data structures mark.

Revision 1.227  1997/09/27 18:06:21  neto
Fixed RCS log behaviour.

Revision 1.226  1997/09/12  21:30:04  neto
Code wasn't included! This caused seg faults.  (This is a CWEB scripto-level
bug.  oops).

Revision 1.225  1997/08/15  20:18:25  neto
Added Index major section.

Revision 1.224  1997/08/15  16:59:29  neto
Print the MST to PostScript as well.

Revision 1.223  1997/08/15  16:19:19  neto
Added -m (--mst-edge-lengths-only) to print the edge lengths and quit

Revision 1.222  1997/08/14  20:19:46  neto
Added symbol BUILD DECLUSTER STRUCTURES to internal conditional compilation.

Revision 1.221  1997/06/19  19:41:34  neto
Be a little more friendly on initial tour length.

Revision 1.220  1997/06/17  21:45:20  neto
Put declustering configuration info in the version banner.

Revision 1.219  1997/06/17  21:32:47  neto
Must include declevel.h

Revision 1.218  1997/06/17  20:28:42  neto
Added support for milestones.
Made declustering stuff conditional.

Revision 1.217  1997/06/16  20:45:00  neto
I need to remember the mst space.

Revision 1.216  1997/06/16  20:24:52  neto
A first cut at doing declustering.

Revision 1.215  1997/06/16  17:35:12  neto
Cleaned up output (again).

Revision 1.214  1997/06/16  17:20:52  neto
Split the validation and print section.

Revision 1.213  1997/06/16  16:38:10  neto
I removed an extraneous print line (Edit bug).

Revision 1.212  1997/06/16  16:33:44  neto
Print no decimal points when no-round option is *not* used.
(i.e. the right thing)

Revision 1.211  1997/06/16  16:07:26  neto
Print length in double format when verbose < 10.

Revision 1.210  1997/06/13  22:12:45  neto
Fixed a spelling mistake.

Revision 1.209  1997/06/13  21:59:58  neto
Refine verbose levels for some output.

Revision 1.208  1997/06/13  21:49:29  neto
Make 5 the default verbose.
Some things that were printed at verbose level 2 now pushed up to 10.

Revision 1.207  1997/06/13  21:39:08  neto
Fixed comments.
Prettied up some TeX stuff.
Terminate columns of numbers in printing tour.
Make sure tour is printed if given -t option, no matter what verbose
setting is.

Revision 1.206  1997/06/13  21:16:06  neto
Fixed comment about main.
put starting braces of functions in column 1.
Updated a section name to reflect reality (report results in only
one place).

Revision 1.205  1997/06/13  21:01:59  neto
Fixed a variable name

Revision 1.204  1997/06/13  20:59:29  neto
Make verbose==1 output only the length of the tour.
Make verbose==2 the default, and it's quite quiet.

Revision 1.203  1997/06/13  20:32:09  neto
Don't print starting incumbent len if verbose==0

Revision 1.202  1997/06/13  20:28:08  neto
Removed flushes of stdout after resource mark calls.
Made checking kd tree quieter if verbose==0

Revision 1.201  1997/06/13  20:16:23  neto
Sorted, minor editing on help text.
Made it really quiet when verbose==0.

Revision 1.200  1997/06/13  19:49:27  neto
Made it a little quiter.

Revision 1.199  1997/06/13  18:44:11  neto
Fixed up the parens matching hack (for editors).

Revision 1.198  1997/06/13  18:17:30  neto
It's not Neto's curve, it's Moore's curve.
I've moved the origin to 6 o'clock instead of at the origin.  This
may help cache behaviour.
(Because the 0/1 boundary is at the edge of the square instead of
right in the middle.).

Revision 1.197  1997/05/16  21:15:06  neto
Now I don't need special behaviour for Linux regarding getpagesize.

Revision 1.196  1997/05/16  21:13:33  neto
Now I don't need special behaviour for Linux regarding gethostname.

Revision 1.195  1997/05/16  20:37:20  neto
Put in some support from configure.

Revision 1.194  1997/05/16  18:11:41  neto
Break locks by david and neto.
Include <config.h> and "lkconfig.h"

Revision 1.193  1997/05/16  18:09:40  neto
Include <config.h> and lkconfig.h

Revision 1.192  1997/02/11  16:08:50  neto
Fixed parsing of start tour.

Revision 1.191  1997/02/10  19:32:36  neto
Added a grestore to close out postscript .

Revision 1.190  97/01/27  16:43:48  neto
Made lk cleanup prototype and definition match in storage class modifier.

Revision 1.189  97/01/27  16:41:02  neto
Better output of intermediate PostScript.

Revision 1.188  1997/01/21  22:30:17  david
Fixed an errorif call.

Revision 1.187  1997/01/21  21:55:55  david
Added standard copyright notice by including copyrt.w

Revision 1.186  1997/01/21  17:48:24  david
Output the tour to the PostScript output stream, if open.

Revision 1.184  1997/01/21  17:23:46  david
Fixed printing out of start tour option, w.r.t. canonical.

Revision 1.183  1997/01/21  16:33:44  david
Added canonical back again.
Fixed error messages about sorting options.

Revision 1.182  1997/01/21  16:22:34  david
Make printing of SFC results optional.

Revision 1.180  1997/01/21  16:10:23  david
Fixed ordering and normalization in SFC comparison function.

Revision 1.179  1997/01/21  15:37:41  david
Fixed the rewrite rule and the comparison rule for SFC when a and
b compare as different.

Revision 1.177  1997/01/21  00:18:10  david
Fail if --maxdepth option given without proper compilation flag.

Revision 1.176  1997/01/20  23:49:31  david
Changed max\_probe\_depth to max\_generic\_flips

Revision 1.175  1997/01/20  19:50:46  david
Fixed setting probe depth.

Revision 1.174  1997/01/20  19:45:56  david
Fixed limit.h to limits.h

Revision 1.173  1997/01/20  19:44:31  david
Added a maxdepth option.

Revision 1.172  1997/01/17  22:11:41  neto
Modifying sfc comparison function.  Still buggy.
Need to use both bits at the same time (x and y) and use table
lookup.
Added printing of labels to the postscript debugging output.

Revision 1.170  1997/01/17  19:43:19  neto
MAXHOSTNAMELEN not defined under Solaris.

Revision 1.169  1997/01/16  22:19:02  neto
Print the wall clock time afterward too.

Revision 1.168  97/01/16  14:20:22  neto
Added space filling curve code.

Revision 1.167  96/12/16  16:56:30  neto
Now it passes gcc with lots of warnings turned on.

Revision 1.166  96/12/13  15:14:03  neto
Fixed a parameter mistake in printing.

Revision 1.165  96/12/13  15:08:50  neto
Fixed typo on variable name.

Revision 1.164  96/12/13  14:49:28  neto
Added raw length computation.

Revision 1.163  96/12/12  14:01:35  neto
Fixed a CWEB typo.

Revision 1.162  96/12/12  14:01:09  neto
Print the current time, too.

Revision 1.161  96/12/05  16:13:54  neto
Free the lengths array.

Revision 1.160  96/12/05  16:00:59  neto
Fixed printf.

Revision 1.159  96/12/05  15:57:08  neto
Fixed prototype for double\_cmp, and made it a module subroutine so that
it would be defined before used.

Revision 1.158  96/12/05  15:55:57  neto
Add the lengths in smallest-to-largest order.   This is the best
numerically-wise.

Revision 1.157  96/12/05  15:35:46  neto
Seem to have fixed the validation routine.

Revision 1.156  96/12/05  15:29:19  neto
Dumb dumb dubm.  +=

Revision 1.155  96/12/05  15:27:51  neto
Need more casts.
.l

Revision 1.154  96/12/05  15:25:37  neto
Need to cast the cost function to double.

Revision 1.153  96/12/05  15:00:38  neto
Changed validation to use compute both a length\_t validation variable
and a double-valued validation variable.  For now, use the double-valued
one to do the check.

Revision 1.152  96/12/05  14:54:59  neto
Added name and comment to output.

Revision 1.151  96/12/05  14:41:05  neto
Added option --noround

Revision 1.150  96/11/08  15:49:55  neto
Added some length\_t\_pcast in places.

Revision 1.149  96/09/19  15:41:47  neto
Added string.h to header list.
Removed assert.h

Revision 1.148  96/09/18  17:16:52  neto
Better name for upper limit on resource marks: last\_resource\_mark.
Also, report a summary from the very beginning to the very end.

Revision 1.147  96/09/18  16:42:38  neto
Fixed calling problem with resource\_report.  Duh.

Revision 1.146  96/09/18  16:39:49  neto
Be a little more intelligent about reporting resource statistics.

Revision 1.145  96/09/18  16:22:10  neto
Added a resource mark at the very beginning of the run, to capture
memory usage of the read routine.

Revision 1.144  96/09/17  14:28:52  neto
More feedback about shutdown sequence.  It seems to take a while.

Revision 1.143  96/09/17  14:07:18  neto
Added conditional compilation if structure around a use of 
a twolevel debugging name.

Revision 1.142  96/09/12  14:15:07  neto
Fixed an unterminated preprocessor else.

Revision 1.141  96/09/12  14:08:10  neto
Removed duplicate const in prototype.

Revision 1.140  96/09/12  14:05:44  neto
Added twolevel debugging routines.

Revision 1.139  96/09/11  16:37:48  neto
Strengthened tour\_set prototype.

Revision 1.138  96/09/10  16:21:26  neto
Added handling of two-level representation.

Revision 1.137  96/08/23  17:24:32  david
Removed the period from the etal macro

Revision 1.136  1996/08/23  15:40:41  david
Fixed for linux.  Unistd declares gethostname and getpagesize only
if \_\_USE\_BSD is defined.  So I doit manually.

Revision 1.135  96/08/20  11:30:40  neto
Added unistd.h for gethostname

Revision 1.134  96/08/16  16:59:37  neto
Report the fixincludes rcs id only if we actually compiled it in.

Revision 1.133  96/08/16  16:56:43  neto
Was including fixincludes twice erroneously.

Revision 1.132  96/08/16  16:49:58  neto
Added fixincludes to the rcs list

Revision 1.131  96/08/16  13:36:01  neto
only need gethostname

Revision 1.130  96/08/16  13:32:04  neto
Fixed the semantics of fwrite.

Revision 1.129  96/08/16  13:04:58  neto
Added fixincludes.

Revision 1.128  96/08/16  12:42:06  neto
Converted putchar to printf.  Otherwise, I'd never get a prototype
for SunOS' \_flusbuf.

Revision 1.127  96/08/15  14:45:51  neto
Enable  definition of length\_rcs\_id

Revision 1.126  96/08/15  13:29:00  neto
Make it pass -Wall

Revision 1.125  96/08/15  12:36:18  neto
No longer use the "upper" module.

Revision 1.124  96/08/14  15:16:42  neto
Fixed printing of command line.

Revision 1.123  96/08/14  14:45:14  neto
Really fixed it this time.

Revision 1.122  96/08/14  14:41:38  neto
Fixed cast of qsort.

Revision 1.121  96/08/14  14:37:27  neto
Fix the declaration of sort to match ANSI (use void instead of char).

Revision 1.120  96/08/14  13:48:56  neto
Add an option to specify sorting procedure.

Revision 1.119  96/08/02  14:38:42  neto
Update documentation and printing of command line to reflect new
construct implementation.
.\

Revision 1.118  96/08/02  14:10:52  neto
Update command line switches to match what construct offers.
Updated the construct() call.

Revision 1.117  96/07/30  16:29:32  neto
Flush stdout after each call to resource\_mark

Revision 1.116  96/07/29  17:08:19  neto
Fixed to compile

Revision 1.115  96/07/29  16:20:02  neto
Added *\_rcs\_id.
Made sure RCS log is activated within this file.

}

@@*The Lin-Kernighan program.
This program implements the Lin-Kernighan heuristic for the 
traveling salesman problem (TSP).  

See the famous 1973 paper {\sl 
An effective heuristic algorithm for the traveling salesman
        problem},
Operations Research,
    {\bf 21},
    pp.~498--516,
    1973,
  by Shen Lin and Brian Kernighan
for the first description and motivation of this algorithm.
A more modern source is the chapter by Johnson and McGeoch, 
    {``The traveling salesman problem:
            a case study''},
Chapter 8, 
    pp.~215--310, in
    {\sl Local Search in Combinatorial Optimization},
    {Emile Aarts and Jan Karel Lenstra} editors,
    {John Wiley \& Sons}, 1997,
    {Wiley Interscience series in discrete mathematics
        and optimziation}.
That chapter
describes the Lin-Kernighan  algorithm (LK from now on) in the
context of other local search algorithms for the TSP.  If you plan to implement
LK, you really ought to study that chapter closely.  When it comes becomes
available,
you should also read the implementation report by Johnson, Bentley, McGeoch
and Ostheimer.

(Then again, why not just work from this code base?)

@@ The outline of the main module is as follows:
@@c
#include <config.h>
#include "lkconfig.h"
@@<System headers@@>@@;
@@<Early module headers@@>@@;
@@<Module headers@@>@@;

@@<Module variables@@>@@;
@@<Global variables@@>@@;
@@<Static prototypes@@>@@;
@@<Module subroutines@@>@@;
@@<Subroutines@@>@@;
const char *lk_rcs_id="$Id: lk.w,v 1.250 1998/06/19 16:39:17 neto Exp neto $";


@@ We will be using many routines from external libraries.  The interfaces
to those routines are described in the following headers.

@@<System headers@@>=
#include <stdio.h>
#define __USE_MISC		/* Linux needs this to get the definition of |nrand48| */
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <math.h>
#if defined(OS_HAS_BROKEN_HEADERS)
#define FIXINCLUDES_USE_RCS_ID
#define FIXINCLUDES_NEED_GETHOSTNAME
#define FIXINCLUDES_NEED_TIME_STUFF
#include "fixincludes.h"
#undef FIXINCLUDES_USE_RCS_ID
#undef FIXINCLUDES_NEED_GETHOSTNAME
#undef FIXINCLUDES_NEED_TIME_STUFF
#endif

@@ The exported interface is contained in the \file{lk.h} header file,
which has the following form.

@@(lk.h@@>=
extern const char *lk_rcs_id;
@@<Exported type definitions@@>@@;
@@<Exported definitions@@>@@;
@@<Exported variables@@>@@;
@@<Exported subroutines@@>@@;

@@ To ensure consistency between the interface and the implementation,
we import our own interface.

@@<Module headers@@>=
#include "lk.h"


@@*The main module.
The program parses the command line, reads an instance,
builds support data structures, constructs a starting tour,
optimized that tour with Lin-Kernighan, then prints the results.

If the system supports resource measurement, then resource usage
is reported over the phases of execution.

@@<Subroutines@@>=
int
main(int argc, char **argv) 
{
	@@<|main| variables@@>@@#
	@@<Do basic initialization@@>@@;
	@@<Parse the command line@@>@@;
	@@<Print a banner@@>@@;
	@@<Read the TSP instance@@>@@;
	@@<Possibly produce only a Held-Karp lower bound@@>@@;
	@@<Possibly reorder the cities@@>@@;
	@@<Allocate the space for this instance@@>@@;
	@@<Build the data structures@@>@@;
	if ( do_weighted_perfect_matching ) {
		@@<Construct a starting matching@@>@@;
	} else {
		@@<Construct a starting tour@@>@@;
	}
	@@<Run the Lin-Kernighan algorithm@@>@@;
	@@<Stop the timers and print interval times@@>@@;
	@@<Validate and print the result@@>@@;
	@@<Free the allocated space@@>@@;
	return 0;
}


@@*Command-line options.
We'll be experimenting with this program, so we need to put in lots of
control knobs, better known as command-line options.  

This program follows the
GNU conventions.  Each option has both a short name consisting of a 
minus sign followed by a single letter, and a long name, 
consisting of two minus
signs  followed by a string of alphanumeric characters.  Parameters to
an option follow whitespace after the option name.  Options are terminated
by `{\tt --}', thus allowing filename parameters to the program to
begin with a leading dash while not being in conflict with command-line
option names or their parameters.

In this program, parameters are processed from left to right, so later
options may override earlier options.

Option \type{-h} or \type{--help} prints out help for command-line 
options, and then quits the program.

Option \type{--version} makes LK print out version information
and then exit successfully.


Option \type{-v} or \type{--verbose} turns on the ``verbose'' mode of 
output.  It has an optional numeric argument, where 0 means no verbose
reporting, and higher values lead to more verbiage.  If no number
is provided, then a default value of 100 is used.  If this option is not
used at all, then a default value of |DEFAULT_VERBOSE| is used.

Option \type{-P} or \type{--postscript} has a mandatory filename argument.
Debugging PostScript output is placed in that file.

Option \type{-q} or \type{--quiet} is synonymous with \type{--verbose 0}.

Option \type{-i} or \type{--iterate} tells us that Lin-Kernighan should
be iterated in the sense of Johnson'90.  An optional numeric
parameter specifies the number of iterations. 
If no numeric parameter is given, a value of 20 is used.  
This is not yet implemented.

Option \type{-r} or \type{--representation} has a mandatory string argument
specifying which oriented tour representation we should use.  
Allowable arguments are \type{array} (the default), 
\type{splay}, 
\type{two-level}, 
\type{tld}, 
and \type{segment}.   
Only \type{array} and \type{two-level} are supported for now.
Suboption \type{splay} has an optional numeric argument that must be either
0, 1, 2, or 3, corresponding to each of the four levels of faithfullness
to the splaying discipline (lower numbers mean less splaying).  See
Fredman \etal.~for the details on this.
Option \type{tld} is ``two-level-debug''; it checks the two-level tree
implementation against the array implementation; the program must have
been compiled
with symbol |TWOLEVEL_DEBUG| defined.


Option \type{-c} or \type{--candidate} has a mandatory expression 
as a parameter.  For each city $i$ in the tour, the expresion specifies
a predicate that defines which other cities may appear on $i$'s candidate list.
The basic predicates are as follows: \type{nn $k$} is satisfied by the $k$
nearest neighbours of city $i$; \type{nq $k$} is satisfied by the $k$
nearest neighbours of $i$ in each quadrant surrounding $i$;
\type{del $d$} is satisfied by any city that is at most $d$ steps away 
from city $i$ in the Delauney triangulation of all the cities.
(The last two options are only applicable to two-dimensional Euclidean 
instances.)  Basic predicates may be combined by the keyword \type{or}.
Delauney triangulation is not yet supported.

Option \type{-s} or \type{--start} has a mandatory string argument specifying
what the starting tour should be.  Allowable arguments are 
\type{random} (random tour),
\type{canonical} (tour $1,2,3,\ldots,n$),
\type{greedy} (greedy, or multi-fragment heuristic---the default)
%\type{ai} (arbitrary insertion), 
%and \type{best} (best of the above---the default).
Suboption \type{random} takes an optional long integer seed.
If the points are to be sorted by a spacefilling curve, 
by specifying option \type{--sfc}, then the canonical tour is the cities
in space-filling curve order.

Option \type{-S} or \type{--sort} has a mandatory string argument specifying
what the sorting procedure should be.  Allowable arguments are
\type{qsort} (the system C library's implementation of Quicksort),
or
\type{dsort} (a determinstic sorting function---Bentley and McIlroy's 
implementation of Quicksort, see INSERT REFERENCE).
It so happens that some system library's implementations of |qsort|
are not deterministic; running times of this program have varied
by up to a factor of 2 because of it, and they sometimes return different
length tours.  Using \type{-S dsort} ensures consistent results.

Option \type{-p} or \type{--print} tells us to print the LK-optimal
tour (or matching)
when
we're done.  The default is to not print the tour (matching), because I'm
usually
interested in the far less bulky output of only run times and tour lengths.

Option \type{-M} or \type{--mst-edge-lengths-only} tells us to 
compute the minimum spanning tree, output the set of edge lengths
in the tree, and then exit.  In particular, a tour is not computed
when this option is used.  This option is useful for cloning an input.
See the program \file{tspgen}.  For post-processing, this option is
probably most useful with the \type{--quiet} so that human-oriented
noise is removed.

Option \type{--no-round} tells us to avoid rounding computed distances.  
The TSPLIB file format specifies that instances of type |EUC_2D| use
rounded distances, \ie, 
$$\hbox{\it cost}(u,v) = \left\lfloor 0.5 + \sqrt{(u_x-v_x)^2+(u_y-v_y)^2} 
\right\rfloor.$$
However, David Johnson's runs on Euclidean inputs do not do any rounding
(I had a pleasant conversation with him at FOCS'96 in Burlington, Vermont).
Using this option allows us to override the TSPLIB definition and just use
the ordinary Euclidean metric:
$$\hbox{\it cost}(u,v) = \sqrt{(u_x-v_x)^2+(u_y-v_y)^2}.$$
This is useful only when the |length_t| type is either an exact type or 
a floating point type.

Option \type{--sfc} asks us to reorder the cities according to my
space-filling curve.  This only makes sense for geometric instances,
and is currently only implemented for 2-dimensional Euclidean instances.
This uses extra memory to remember the mapping.
However, I expect this to use the cache hierarchy more effectively.
This is a research hypothesis.

Option \type{--maxdepth} takes an optional integer argument, $d$.
It asks us to limit the probe depth to at most $d$ generic flips, \ie\
$d$ flips deep in the greedy portion of the search for an improving
sequential $\lambda$-change.
Some researchers speed up their implementations of Lin-Kernighan
by specifiying that probes should stop at 50 or 100 flips.
I believe
this is unnatural.   
Instead I think limiting the depth due to the
inherent topology of the instance is preferable.
This is a research hypothesis.
If this option is not specified, then no limit is put on the probing depth.
If \type{--maxdepth} is specified without giving a value for $d$, then
a default of $d=50$ is used.

Option \type{-l} or \type{--lower-bound}
takes two mandatory arguments, a string and a number.
The number is taken as a lower bound on the tour length, useful for
keeping track of milestones.  The string is a name for the bound
given by the user.  In verbose output the milestones are labelled with
the name of the bound. 
For example, the user might indicate a known optimal tour length by
specifying \type{-l optimal 14379}. 
(Optimal tours for \type{lin105} have
length 14379.) 
Then the output might say something like: 
\type{2.5\% above optimal after 1.5 user seconds}.
Simliarly, \type{-l Held-Karp 702.3} might be used to get messages like
\type{2.5\% above Held-Karp after 5.5 user seconds}.
If a bound is specified, milestones are printed when the verbose level 
is 25 or more.

Option \type{-u} or \type{--upper-bound}
is similar to \type{-l}, 
taking two mandatory arguments, a string and a number.
The number is taken as an upper bound on the tour length,
and the name is taken as its description, \eg, \type{optimal}, or
\type{best-known}.  This option is required when option \type{--held-karp}
is specified.

Option \type{--held-karp} specifies that we should compute the
Held-Karp lower bound on the tour length, and then exit.
See module \module{ASCEND} for a description of the Held-Karp lower bound.

Option \type{--held-karp-lambda} specifies that we should compute
the Held-Karp lower bound on tour length and print out a representation
of the Lagrange multipliers with which we achieve that bound.

Option \type{-m} or \type{--matching} tells us to tackle the Minimum
Weighted Perfect Matching problem rather than the Traveling Salesman
Problem.  It affects several of the other options: the tour representation
is irrelevant; the start kind (\type{canonical}, \type{greedy},
\type{random}) specifies algorithms constructing weighted
perfect matchings that correspond to similar algorithms for
constructing tours.



Option \type{-} specifies that the TSPLIB input will be found on the standard
input stream.  

Anything that remains on the command line after options are processed will
be treated as a filename from which our TSPLIB input is taken.  It is an
error to specify more than one file (standard input counts as a file).
If no files are specified, then the standard input is used.

@@ We scan the command line arguments from left to right.

@@<Parse the command line@@>=
@@<Set the option defaults@@>@@;
{ int r, filecount=0, postscript_filecount=0, more_options = 1;
	filename = NULL;
	for (r=1;r<argc;r++) {
		if ( more_options && argv[r][0] == '-' && argv[r][1]!=0 ) {
			@@<Parse this option@@>@@;
			@@<Flag illegal option@@>@@;
		} else {
			if ( filecount ) {
				@@<Print the command line; split at |r|@@>@@;
				fprintf(stderr,"Only one input file allowed\n");
				exit(1);
			}
			if ( !(more_options && strcmp(argv[r],"-")==0) ) 
				filename = argv[r];
				/* |else| case means use |stdin| */
			filecount++;
		}
	}
}
@@<Check option prerequisites@@>@@;


@@
@@<Module variables@@>=
static char *filename;
static int mst_edge_lengths_only;
static int do_weighted_perfect_matching;
static int held_karp_only;
static int held_karp_lambda_only;

@@
@@d DEFAULT_VERBOSE 5
@@<Set the option defaults@@>=
	verbose = DEFAULT_VERBOSE;
	iterations = 1;
	should_show_tour = 0;
	should_show_version = 0;
	mst_edge_lengths_only = 0;
	held_karp_only = 0;
	held_karp_lambda_only = 0;
	do_weighted_perfect_matching = 0;
	representation = REP_ARRAY;
	candidate_expr = CAND_NN;
	cand_nn_k = 20;
	cand_nq_k = 5;
	cand_del_d = 3;
	construction_algorithm = CONSTRUCT_GREEDY;
	start_heuristic_param = 42L;
	PostScript_filename = NULL;
	lower_bound_name = NULL;
	lower_bound_value=1.0; /* Dummy. */
	upper_bound_name = NULL;
	upper_bound_value=0.0; /* Dummy. */
	sort = (void (*)(void *, size_t, size_t, int(*)(const void*,const void*)))qsort;
	noround = 0;
	
@@
@@<Global variables@@>=
int verbose, iterations, should_show_tour, should_show_version;
int representation, construction_algorithm;
long start_heuristic_param;
int candidate_expr, cand_nn_k, cand_nq_k, cand_del_d;
char *PostScript_filename, *lower_bound_name, *upper_bound_name;
void (*sort)(void *a, size_t n, size_t es, int(*cmp)(const void *,const void*));
int noround;
double upper_bound_value, lower_bound_value;

@@
@@<Exported variables@@>=
extern int verbose, iterations, should_show_tour, should_show_version;
extern int representation, construction_algorithm;
extern long start_heuristic_param;
extern int candidate_expr, cand_nn_k, cand_nq_k, cand_del_d;
extern char *PostScript_filename, *lower_bound_name, *upper_bound_name;
extern void (*sort)(void *a, size_t n, size_t es, int(*cmp)(const void *,const void*));
extern int noround;
extern double lower_bound_value, upper_bound_value;

@@
@@<Exported definitions@@>=
#define REP_ARRAY		1	/* Tour representations */
#define REP_TWO_LEVEL	2
#define REP_SPLAY_0		3
#define REP_SPLAY_1		4
#define REP_SPLAY_2		5
#define REP_SPLAY_3		6
#define REP_TWO_LEVEL_DEBUG		7
@@#

#define CAND_NN			1	/* Candidate predicate types --- they may be ||||'d */
#define CAND_NQ			2
#define CAND_DEL		4
@@#


@@  The \type{--help} option is the easiest one.
@@<Parse this option@@>=
if ( strcmp(argv[r],"-h")==0 || strcmp(argv[r],"--help")==0 ) {
	printf("Usage: %s [options] [filename]\n",argv[0]);
	printf(" -                          TSPLIB input on stdin\n");
	printf(" --                         End options\n");
	printf(" -l --lower-bound <name> <length> \n"
           "                            Give lower bound, enable milestones\n");
	printf(" -c --candidate <p>         Specify candidate cities\n");
	printf("      <p> ::= <bp> | <bp> or <p>\n");
	printf("      <bp> ::= nn <k> | nq <k> | del <d>\n");
	printf("                            (nq, del are unimplemented)\n");
	printf("    --held-karp             Compute approx Held-Karp TSP lower bound,\n");
	printf("                            then exit successfully.  Requires -u\n");
	printf("    --held-karp-lambda      Compute approx Held-Karp TSP lower bound,\n");
	printf("                            print the best Lagrange multipliers found,\n");
	printf("                            then exit successfully.  Requires -u\n");
	printf(" -h --help                  Give this help, then exit\n");
	printf(" -i --iterate [n]           Iterated LK n times (default is 1, n default is 20)\n");
	printf("                            (unimplemented)\n");
	printf(" -m --matching              Find cheap weighted perfect matchings\n"@@| 
		   "                            rather than short tours\n");
	printf(" -M --mst-edge-lengths-only Print the edge lengths in a minimum spanning tree\n");
	printf("                            and then exit successfully\n");
	printf("    --maxdepth [d]          Limit probe depth to d cities\n");
	printf("    --no-round              Don't round distance computations\n");
	printf(" -p --print                 Print the LK-optimal tour or matching\n");
	printf(" -P --postscript <file>     Generate PostScript output and write to <file>\n");
	printf(" -q --quiet                 Same as --verbose 0\n");
	printf(" -r --representation <rep>  Specify tour representation (default is array)\n");
	printf("      <rep> ::= array | two-level | tld (two-level-debug)| splay\n");
	printf("                            (This has no effect if finding a matching)\n");
	printf(" -s --start <kind>          Specify staring tour (matching) algorithm"@@|
           "                            Greedy is default.\n");
	printf("      <kind> ::= canonical | greedy | random [seed]\n");
	printf("    --sfc                   Reorder cities by Moore's space filling curve\n");
	printf(" -S --sort <kind>           Specify sorting procedure (default is qsort)\n");
	printf("      <kind> ::= qsort (from system library) | dsort (Bentley&McIlroy qsort)\n");
	printf(" -u --upper-bound <name> <length> \n"
           "                            Give upper bound, required for Held-Karp\n");
	printf(" -v --verbose [n]           Set verbose level (default is 5, n default is 100)\n");
	printf("    --version               Print LK version number, then exit successfully\n");
	exit(0);
}

@@ If the user tells us the options are finished, then we shouldn't process more
options...  (Sort of obvious, huh?).

@@<Parse this option@@>=
if ( strcmp(argv[r],"--")==0 ) {
	more_options = 0;
	continue;
}

@@ Here we find out whether we should turn off rounding of Euclidean distance
computations.
@@<Parse this option@@>=
if ( strcmp(argv[r],"--no-round")==0 ) {
	noround = 1;
	continue;
}

@@ Here we find out whether we must print the tour in addition to
printing its length.
@@<Parse this option@@>=
if ( strcmp(argv[r],"-p")==0 || strcmp(argv[r],"--print")==0 ) {
	should_show_tour = 1;
	continue;
}

@@ Here we find out whether we should only print the minimum spanning
tree edge lengths (and not compute a tour).
@@<Parse this option@@>=
if ( strcmp(argv[r],"-M")==0 || strcmp(argv[r],"--mst-edge-lengths-only")==0 ) {
	mst_edge_lengths_only = 1;
	continue;
}

@@ Here we find out whether we should only compute a Held-Karp lower
bound for the TSP.
@@<Parse this option@@>=
if ( strcmp(argv[r],"--held-karp")==0 ) {
	held_karp_only = 1;
	continue;
}

@@ Here we find out whether we should only compute a Held-Karp lower
bound for the TSP and print the Lagrange multipliers used.
@@<Parse this option@@>=
if ( strcmp(argv[r],"--held-karp-lambda")==0 ) {
	held_karp_lambda_only = 1;
	continue;
}

@@ Here we find out whether we should try to find a cheap weighted perfect
matching rather than a short tour.  
If we are to find a matching, then the tour representation is irrelevant,
because there is no tour.

@@<Parse this option@@>=
if ( strcmp(argv[r],"-m")==0 || strcmp(argv[r],"--matching")==0 ) {
	do_weighted_perfect_matching = 1;
	continue;
}



@@ Here we find out whether we should print version information.
@@<Parse this option@@>=
if ( strcmp(argv[r],"--version")==0 ) {
	should_show_version = 1;
	@@<Print a version banner@@>@@;
	exit(0);
	continue;
}


@@ Here we find out whether we should reorder the cities according to
my spacefilling curve.  I suspect this improves the performance in
a non-uniform memory architecture (NUMA) machine.  I have my reasons.
@@^non-uniform memory architecture@@>
@@^NUMA@@>

@@<Parse this option@@>=
if ( strcmp(argv[r],"--sfc")==0 ) {
	should_sfc_reorder = 1;
	continue;
}

@@
@@<Set the option defaults@@>=
should_sfc_reorder = 0;

@@
@@<Global variables@@>=
int should_sfc_reorder;


@@ The quiet option sets the verbose variable.
@@<Parse this option@@>=
if ( strcmp(argv[r],"-q")==0 || strcmp(argv[r],"--quiet")==0 ) {
	verbose = 0;
	continue;
}

@@ The verbose option has an optional numerical argument.  We must check for
its presence.
@@<Parse this option@@>=
if ( strcmp(argv[r],"-v")==0 || strcmp(argv[r],"--verbose")==0 ) {
	verbose = 100;
	if ( r+1<argc && is_number(argv[r+1]) ) verbose = atoi(argv[++r]);
	continue;
}

@@ But we need to create the predicate |is_number|.  We allow an optional
single
unary minus.  We are paranoid about |NULL| parameters.

@@<Module subroutines@@>=
static int
is_number(char *p) 
{
	if ( p == NULL ) return 0;	/* Be paranoid. */
	if ( *p == '-' ) p++;		/* Skip over a single unary minus. */
	if ( *p == 0 ) return 0;	/* Need at least one digit. */
	for (;*p;p++) {
		if (!isdigit(*p)) return 0;
	}
	return 1;
}

@@	We've just used the |isdigit| macro which is defined in \file{ctype.h}.
@@<System headers@@>=
#include <ctype.h>

@@ While we're doing optional numerical arguments, 
let's do the \type{--iterate} switch as well.
@@<Parse this option@@>=
if ( strcmp(argv[r],"-i")==0 || strcmp(argv[r],"--iterate")==0 ) {
	iterations = 20;
	if ( r+1<argc && is_number(argv[r+1]) ) iterations = atoi(argv[++r]);
	continue;
}

@@ The maximum probe depth option has an optional numerical argument, which
goes into |max_generic_flips|.  
We must check this option's presence, as in the verbose option.

@@<Parse this option@@>=
if ( strcmp(argv[r],"--maxdepth")==0 ) {
#if !defined(JBMR_LIMIT_PROBE_DEPTH)
	errorif(1,
		"Option --maxdepth requires JBMR_LIMIT_PROBE_DEPTH compilation flag.\n");
#endif
	max_generic_flips = 50;
	if ( r+1<argc && is_number(argv[r+1]) ) max_generic_flips = atoi(argv[++r]);
	continue;
}

@@
@@<Global variables@@>=
int max_generic_flips;

@@
@@<Exported variables@@>=
extern int max_generic_flips;

@@ The default maximum probe depth should really be $\infty$ but |INT_MAX|,
the maximum representable signed integer should suffice.
@@<Set the option defaults@@>=
max_generic_flips=INT_MAX;

@@  We need the definition of |INT_MAX|
@@<System headers@@>=
#include <limits.h>

@@ Lets tackle the starting tour option.  This has a mandatory string
argument chosen from a fixed list.  Argument string \type{random} has
an optional numeric parameter.
@@<Parse this option@@>=
if ( strcmp(argv[r],"-s")==0 || strcmp(argv[r],"--start")==0 ) {
	if ( r+1>=argc ) {
		@@<Print the command line; split at |r|@@>@@;
		fprintf(stderr, "Need one of {canonical,greedy,random [seed]}\n");
		exit(1);
	}
	r++;

	if ( strcmp(argv[r],"greedy")==0 ) construction_algorithm = CONSTRUCT_GREEDY;
	else if ( strcmp(argv[r],"canonical")==0 ) construction_algorithm = CONSTRUCT_CANONICAL;
	else if ( strcmp(argv[r],"random")==0 ) {
		construction_algorithm = CONSTRUCT_RANDOM;
		if ( r+1<argc && is_number(argv[r+1]) ) start_heuristic_param = atol(argv[++r]);
	} else {
		@@<Print the command line; split at |r|@@>@@;
		fprintf(stderr, "Need one of {canonical,greedy,random [seed],best}\n");
		exit(1);
	}
	continue;
}

@@ Next comes the sort procedure option.  It also has a mandatory string
argument chosen from a fixed list.
@@<Parse this option@@>=
if ( strcmp(argv[r],"-S")==0 || strcmp(argv[r],"--sort")==0 ) {
	if ( r+1>=argc ) {
		@@<Print the command line; split at |r|@@>@@;
		fprintf(stderr, "Need one of {dsort,qsort}\n");
		exit(1);
	}
	r++;

	if ( strcmp(argv[r],"qsort")==0 ) 
		sort = (void (*)(void *, size_t, size_t,int(*)(const void*,const void*)))qsort;
	else if ( strcmp(argv[r],"dsort")==0 ) sort = dsort;
	else {
		@@<Print the command line; split at |r|@@>@@;
		fprintf(stderr, "Need one of {dsort,qsort}\n");
		exit(1);
	}
	continue;
}

@@ We need to import the interface to |dsort|.
@@<Module headers@@>=
#include "dsort.h"

@@ The \type{--representation} switch also has a mandatory string
argument chosen from a fixed list.

@@<Parse this option@@>=
if ( strcmp(argv[r],"-r")==0 || strcmp(argv[r],"--representation")==0 ) {
	if ( r+1>=argc ) {
		@@<Print the command line; split at |r|@@>@@;
		fprintf(stderr, "Need one of {array,splay [level],two-level,tld}\n");
		exit(1);
	}
	r++;
	if ( strcmp(argv[r],"array")==0 ) {
		representation = REP_ARRAY;
	} else if ( strcmp(argv[r],"two-level")==0 ) {
		representation = REP_TWO_LEVEL;
	} else if ( strcmp(argv[r],"tld")==0 ) {
		representation = REP_TWO_LEVEL_DEBUG;
	} else if ( strcmp(argv[r],"splay")==0 ) {
		int level=0;
		if ( r+1<argc && is_number(argv[r+1]) ) level = atoi(argv[++r]);
		if ( level<0 || level>3 ) {
			@@<Print the command line; split at |r|@@>@@;
			fprintf(stderr,"Splay level must be 0, 1, 2, or 3\n");
			exit(1);
		}
		representation = REP_SPLAY_0 + level;
	} else {
		@@<Print the command line; split at |r|@@>@@;
		fprintf(stderr, "Need one of {array,splay [level],two-level,tld}\n");
		exit(1);
	}
	continue;
}

@@ The PostScript option  needs a filename.
@@<Parse this option@@>=
if ( strcmp(argv[r],"-P")==0 || strcmp(argv[r],"--postscript")==0 ) {
	if (r+1>=argc) {
		@@<Print the command line; split at |r|@@>@@;
		fprintf(stderr,"Need a file name\n");
		exit(1);
	}
	r++;
	if ( postscript_filecount ) {
		fprintf(stderr,
			"Warning: %s already specified as PostScript output file; "
			"%s overrides\n", 
			PostScript_filename, argv[r]);
	}
	postscript_filecount++;
	PostScript_filename = argv[r];
	continue;
}

@@ The lower bound option needs a name and a floating-point number.
In most UNIX shells, names with spaces can be specified if quoted.

@@<Parse this option@@>=
if ( strcmp(argv[r],"-l")==0 || strcmp(argv[r],"--lower-bound")==0 ) {
	if (r+1>=argc) {
		@@<Print the command line; split at |r|@@>@@;
		fprintf(stderr,"Need a lower bound name\n");
		exit(1);
	}
	if (r+2>=argc) {
		@@<Print the command line; split at |r|@@>@@;
		fprintf(stderr,"Need a lower bound on length\n");
		exit(1);
	}
	r++;
	lower_bound_name=dup_string(argv[r]);
	r++;
	lower_bound_value=atof(argv[r]);
	continue;
}

@@ The upper bound option is very much like the lower bound option.

@@<Parse this option@@>=
if ( strcmp(argv[r],"-u")==0 || strcmp(argv[r],"--upper-bound")==0 ) {
	if (r+1>=argc) {
		@@<Print the command line; split at |r|@@>@@;
		fprintf(stderr,"Need an upper bound name\n");
		exit(1);
	}
	if (r+2>=argc) {
		@@<Print the command line; split at |r|@@>@@;
		fprintf(stderr,"Need an upper bound on length\n");
		exit(1);
	}
	r++;
	upper_bound_name=dup_string(argv[r]);
	r++;
	upper_bound_value=atof(argv[r]);
	continue;
}

@@ The upper bounding option is required when computing Held-Karp lower bounds.
@@<Check option prerequisites@@>=
errorif( (held_karp_only || held_karp_lambda_only) && upper_bound_name == NULL,
	"Held-Karp lower bounding requires an upper bound\n");


@@ Now we get to the most involved option: the candidate list predicate 
expression.  Fortunately, it's at worst just the disjunction of a number of
basic predicates.

@@<Parse this option@@>=
if ( strcmp(argv[r],"-c")==0 || strcmp(argv[r],"--candidate")==0 ) {
	int numeric_param;
	candidate_expr = cand_nn_k = cand_nq_k = cand_del_d = 0;
	r++;
	do {
		if ( r>=argc ||
				(strcmp(argv[r],"nn")!=0 && strcmp(argv[r],"nq")!=0 &&
				strcmp(argv[r],"del")!=0) 
		   ) {
			@@<Print the command line; split at |r|@@>@@;
			fprintf(stderr,"Need one of {nn,nq,del}\n");
			exit(1);
		}
		if ( r+1>=argc || !is_number(argv[r+1]) ) {
			r++;
			@@<Print the command line; split at |r|@@>@@;
			fprintf(stderr,"Need a numeric parameter\n");
			exit(1);
		} else numeric_param = atoi(argv[r+1]);
		if ( strcmp(argv[r],"nn")==0 ) {
			candidate_expr |= CAND_NN;
			if ( cand_nn_k < numeric_param ) cand_nn_k = numeric_param;
		} else if ( strcmp(argv[r],"nq")==0 ) {
			candidate_expr |= CAND_NQ;
			if ( cand_nq_k < numeric_param ) cand_nq_k = numeric_param;
		} else if ( strcmp(argv[r],"del")==0 ) {
			candidate_expr |= CAND_DEL;
			if ( cand_del_d < numeric_param ) cand_del_d = numeric_param;
		} else {
			@@<Print the command line; split at |r|@@>@@;
			fprintf(stderr,"Need one of {nn,nq,del}\n");
			exit(1);
		}
		r++;
	} while( r+1<argc && strcmp(argv[r+1],"or")==0 && (r+=2) );
	continue;
}

@@ If there's an option we don't understand, then we tell the user about
it and skip over it.  Note that the code for each legal option performs
a |continue| to get to the next argument, so if we get here, then we've
seen a non-empty string with a leading `\type-'.

@@<Flag illegal option@@>=
@@<Print the command line; split at |r|@@>@@;
fprintf(stderr,"Skipping unrecognized option %s\n",argv[r]);

@@ Here we print out the command line, from  the
beginning of the candidate expression onward, but split it right
after the last token read.  This idea is stolen from Knuth's 
\TeX.  We do the splitting in this way so the user can see where
the program got confused (or found an error, rather).

Variable |se| marks the start of the expression.  Did you catch its definition
above?

To be able to properly show the split, we count the characters coming before
the split.

@@<Print the command line; split at |r|@@>=
{	int chars_before_split = 0, i;
	for ( i=0;i<=r && i<argc;i++ ) {
		fprintf(stderr,"%s ",argv[i]);
		chars_before_split += strlen(argv[i]) + 1;
	}
	fputc('\n',stderr);
	for ( i=0;i<chars_before_split;i++) {fputc(' ',stderr);}
	for ( i=r+1 ; i<argc ; i++ ) {
		fprintf(stderr,"%s ",argv[i]);
	}
	fputc('\n',stderr);
}

@@ Once the command line has been successfully parsed, we print a banner.  
It consists of a few lines of text identifying the program name, version
numbers, and information on how the program was compiled and run.

While measuring and testing this program, it is important to know
the version of the module being used.  I use the revision control system
known as RCS.  The following string variable is updated automatically
each time this module is checked into the system.
@@^RCS@@>
@@^revision control system@@>

@@<Print a banner@@>=
if ( verbose>=10 ) {
	extern const char *compile_compile, *compile_link; /* Compiler options */
	@@<Print a version banner@@>@@;
	if ( verbose >= 10 ) @@<Print a copyright notice@@>@@;
	if ( verbose >= 100 ) {
		printf("%s\n",compile_compile);
		printf("%s\n",compile_link);
		printf("%s\n",array_rcs_id);
		printf("%s\n",construct_rcs_id);
		printf("%s\n",dict_rcs_id);
		printf("%s\n",dsort_rcs_id);
		printf("%s\n",error_rcs_id);
#if defined(OS_HAS_BROKEN_HEADERS)
		printf("%s\n",fixincludes_rcs_id);
#endif
		printf("%s\n",jbmr_rcs_id);
		printf("%s\n",kdtree_rcs_id);
		printf("%s\n",length_rcs_id);
		printf("%s\n",lk_rcs_id);
		printf("%s\n",memory_rcs_id);
		printf("%s\n",nn_rcs_id);
		printf("%s\n",pool_rcs_id);
		printf("%s\n",read_rcs_id);
		printf("%s\n",resource_rcs_id);
	}
	printf("Command line equivalent: ");@@+@@<Print an equivalent command line@@>@@;
	printf("Start time: ");@@+@@<Print the current time@@>@@;
}

@@ String |VERSION_STRING| appears in \file{$<$config.h$>$} and is set
in file \file{configure.in}.  
%This version banner conforms to the GNU coding standards.

If declustering is implemented, then a short string is appended to
the version number.  The letter \type{d} indicates declustering,
letter \type{e} indicates clustering used for eligibility testing,
and  \type{g} indicates clustering used for greedy selection.
Note that \type{g} implies \type{e}.

@@<Print a version banner@@>=
printf("LK %s",VERSION_STRING);
#if JBMR_DECLUSTER_IN_ELIGIBILITY_TEST 
	printf("de");
#	if JBMR_DECLUSTER_IN_GREEDY
		printf("g");
#	endif
#endif
printf("\n");

@@ LK is free software.  This is a GNU-compliant copyright notice. 
@@<Print a copyright notice@@>=
printf(@@;
"LK approximately solves the traveling salesman problem.\n"@@;
"\nCopyright (C) 1997 David M. Neto\n"@@;
"LK comes with NO WARRANTY, to the extent permitted by law.\n"@@;
"You may redistribute and/or modify copies of LK under the terms of the\n"@@;
"GNU General Public License, version 2 or any later version.\n"@@;
"For more information about these matters, see the file named COPYING.\n"@@;
/* Maybe insert major author names, i.e. me. */
);

@@ A few of the version number strings are in modules we haven't seen yet.
Let's include them now.
@@<Module headers@@>=
#include "pool.h"
#include "dict.h"
#include "kdtree.h"


@@ If verbose mode is on at all, we print out a complete
and unambiguous command line equivalent to the one we got.  That is,
we fill in the important details if they were skipped.

@@<Print an equivalent command line@@>=
if ( verbose>=10 ) {
	printf("%s ",argv[0]);
	if ( verbose != DEFAULT_VERBOSE ) printf("-v %d ",verbose);
	if ( should_show_version ) printf("--version "); /* But it exits by now! */
	if ( do_weighted_perfect_matching ) printf("-m ");
	if ( mst_edge_lengths_only ) printf("-M ");
	if ( held_karp_only ) printf("--held-karp ");
	if ( held_karp_lambda_only ) printf("--held-karp-lambda ");
	if ( should_show_tour ) printf("-p ");
	if ( noround ) printf("--no-round ");
	if ( NULL != PostScript_filename ) printf("-P %s ",PostScript_filename);
	if ( iterations != 1 ) printf("-i %d ",iterations);@@#
	switch(construction_algorithm) {
	case CONSTRUCT_CANONICAL: printf("-s canonical "); break;
	case CONSTRUCT_GREEDY: printf("-s greedy "); break;
	case CONSTRUCT_RANDOM: printf("-s random %ld ",start_heuristic_param);break;
	default: errorif(1,"Bad construction_algorithm == %d\n",construction_algorithm);
	}
	@@#
	if ( sort == dsort ) printf("-S dsort ");
	@@#
	printf("-c ");
	if ( candidate_expr & CAND_NN ) 
		printf("nn %d %s",cand_nn_k, 
			candidate_expr & (CAND_NQ|CAND_DEL) ? "or ": "");
	if ( candidate_expr & CAND_NQ ) 
		printf("nq %d %s",cand_nq_k, 
			candidate_expr & CAND_DEL ? "or ": "");
	if ( candidate_expr & CAND_DEL ) 
		printf("del %d ",cand_del_d);
	@@#
	switch(representation) {
	case REP_ARRAY: printf("-r array "); break;
	case REP_TWO_LEVEL: printf("-r two-level "); break;
	case REP_TWO_LEVEL_DEBUG: printf("-r tld "); break;
	case REP_SPLAY_0: printf("-r splay 0 "); break;
	case REP_SPLAY_1: printf("-r splay 1 "); break;
	case REP_SPLAY_2: printf("-r splay 2 "); break;
	case REP_SPLAY_3: printf("-r splay 3 "); break;
	default: errorif(1,"Bad representation == %d\n",representation);
	}
	@@#
	if ( should_sfc_reorder ) printf("--sfc ");
	@@#
	if ( max_generic_flips != INT_MAX ) printf("--maxdepth %d ", max_generic_flips);
	@@#
	if ( lower_bound_name != NULL ) printf("-l %s %f ", lower_bound_name, lower_bound_value);
	if ( upper_bound_name != NULL ) printf("-u %s %f ", upper_bound_name, upper_bound_value);
	@@#
	if ( filename ) {
		if ( filename[0]=='-' ) printf("-- %s",filename);
		else printf("%s",filename);
	} else printf("-");
	printf("\n");
}

@@  It might also help the user to tell them when a particular run started.
The following code prints the current date and time in human-readable form.
I hope it uses only ANSI-standard library facilities.
@@^system dependencies@@>

@@<Print the current time@@>=
{ 
#if HAVE_TIME_H && HAVE_TIME && HAVE_CTIME
  time_t now = time(NULL);
  printf("%s",ctime(&now));
  fflush(stdout);
#endif
}

@@ This time code requires the \file{time.h} interface.
@@<System headers@@>=
#if HAVE_TIME_H
#include <time.h>
#endif

@@*Initialization.

Now we read the instance into a structure that is read-only for the rest
of the program.  That is, after this initialization, this structure is not
changed for the remainder of the execution of the program.  This may have
significant consequences for a parallel implementation of this program.

For convenience, we have a module-level variable |n| which is an alias
for |tsp_instance->n|.

The procedure |read_tsp_file| reads the instance and provides us
with generalized |cost| and |pseudo_cost| functions.  (The |pseudo_cost|
function is only guaranteed to be monotonic in the |cost| function,
although it may be faster.  See the \module{READ} module for more
information.)

@@<Read the TSP instance@@>=
last_resource_mark = resource_mark("Reading the instance");
if ( filename ) {
	TSPLIB_in = fopen(filename,"r");
	errorif( TSPLIB_in==NULL, "Couldn't open \"%s\" for reading",filename);
} else TSPLIB_in = stdin;
if ( PostScript_filename ) {
	FILE *prolog;
	char buf[8192];
	size_t countin, countout;
	ps_out = fopen(PostScript_filename,"w");
	errorif( ps_out==NULL, "Couldn't open \"%s\" for writing",filename);
	prolog = fopen("prolog.ps","r");
	errorif( prolog==NULL,"Couldn't open prolog.ps for reading");
	while ( (countin=fread(buf,1,8192,prolog)) > 0 ) {
		char *p=buf;
		while ( (countout=fwrite(p,1,countin,ps_out)) < countin ) {
			countin-=countout; p+= countout;
		}
	}
	fclose(prolog);
} else ps_out = NULL;
tsp_instance = read_tsp_file( TSPLIB_in, ps_out );
n = tsp_instance->n;

@@ We need to declare that module-level variable |n| and the file handles.
@@<Module variables@@>=
static int n;
static FILE *TSPLIB_in, *ps_out;

@@ The interface for the reading routine is defined in the \file{read.h}.
We also need the |length_t| type.
@@<Early module headers@@>=
#define LENGTH_USE_RCS_ID
#include "length.h"
#undef LENGTH_USE_RCS_ID
#include "read.h"

@@ We need to declare the |tsp_instance| variable.  

@@<Global variables@@>=
tsp_instance_t *tsp_instance;

@@ @@<Exported variables@@>=
extern tsp_instance_t *tsp_instance;

@@*Held-Karp lower bounds for the TSP.
Sometimes all we want to do is produce the Held-Karp lower bound for the
TSP.

Sometimes we want to see the Lagrange multipliers used in the result.

@@<Possibly produce only a Held-Karp lower bound@@>=
if ( held_karp_only || held_karp_lambda_only ) {
	length_t held_karp_bound; 
	errorif(upper_bound_value<=0,"main: upper bound %d should be positive.",upper_bound_value);
	ascend_setup(n);
	held_karp_bound = ascend(n,upper_bound_value);
	printf("Held-Karp lower bound: "length_t_spec
		" (%.2f%% below upper bound " length_t_spec")\n",
		length_t_pcast(held_karp_bound),
			100.0*((double)(upper_bound_value-held_karp_bound))/upper_bound_value, 
		length_t_pcast(upper_bound_value));
	if ( held_karp_lambda_only ) {
		int i;
		double * const lambda = ascend_best_lambda();
		errorif(lambda==NULL,"No Lagrange multilpier lambda vector!\n");
		printf("Lagrange multipliers:\n");
		for ( i=0; i<n ; i++) {
			printf("%d %f\n",1+i,lambda[i]);
		}
	}
	ascend_cleanup();
	exit(0);
}

@@ We need the interface to module \module{ASCEND}.
@@<Module headers@@>=
#include "ascend.h"

@@*Reordering the cities.
I have reason to believe that, for geometric instances at least, 
reordering the cities according to a space-filling curve improves
the performance of the program on machines with
a non-uniform memory architecture (NUMA).
@@^non-uniform memory architecture@@>
@@^NUMA@@>

When we do sort the instance, we must remember the original city numbers.
These are stored in the array |original_city_num|.

@@<Possibly reorder the cities@@>=
if ( should_sfc_reorder ) {
	int i, n=tsp_instance->n;
	coord_2d *new_coord;
	errorif( tsp_instance->coord == NULL, 
		"Space filling curve reordering applies only to geometric instances.\n");
	original_city_num = new_arr_of(int,n);
	for (i=0;i<n ; i++) original_city_num[i] = i;
	sort(original_city_num,(size_t)n,sizeof(int),cmp_sfc_Moore);
	new_coord = new_arr_of(coord_2d,n);
	for (i=0;i<n ; i++) new_coord[i]=tsp_instance->coord[original_city_num[i]];
#if 0
	free_mem(tsp_instance->coord);mem_deduct(n*sizeof(coord_2d));
	tsp_instance->coord = new_coord;
#else
	for (i=0;i<n ; i++) tsp_instance->coord[i]=new_coord[i];
	free_mem(new_coord);mem_deduct(n*sizeof(coord_2d));
#endif
#if defined(LK_SHOW_AFTER_SFC)
	if ( ps_out ) {
		length_t len=cost(0,n-1);int i; for (i=1;i<n;i++,len+=cost(i,i-1));
		fprintf(ps_out,"(SFC(Moore) tour, len "length_t_spec") title\n",
			length_t_pcast(len));
		fprintf(ps_out,"(%s) comment\n",tsp_instance->comment);
		for ( i=0;i<n;i++ ) {
			fprintf(ps_out,"%d %f %f sfcs\n",i+1,
				tsp_instance->coord[i].x,tsp_instance->coord[i].y);
			fprintf(ps_out,"(%d) %d label\n",i,i);
			if ( i>0 ) fprintf(ps_out,"%d %d edge\n",i-1,i);
		}
		fprintf(ps_out,"%d %d edge\n",n-1,0);
		fprintf(ps_out,
			"1 1 N { dup xs exch get exch ys exch get circle } for\n");
		fprintf(ps_out,"showpage\n");
		fflush(ps_out);
	}
#endif
}

@@ We make the |original_city_num| array globally visible so that any module
can remamp city numbers for output.  It is non-|NULL| if a remapping is
in effect.

@@<Global variables@@>=
int *original_city_num = NULL;

@@
@@<Exported variables@@>=
extern int *original_city_num;


@@
@@<Free the allocated space@@>=
free_mem(original_city_num);

@@ Here is the comparison function that implicitly defines the space filling
curve.  It defined Moore's curve, a cyclic variant of Hilbert's curve.
Bartholdi and Platzman used a different curve in relation to the TSP, 
and even then only to specify a {\it tour\/},
not a city remapping for improving cache performance.

See my notes of September 27, 1996 for the definition of this function.
Actually, that was buggy.  So see my notes of January 20, 1997.
For much more information about space-filling curves, see the book
by Hans Sagan, {\sl Space Filling Curves}. (INSERT MORE COMPLETE
REFERENCE).
@@^Moore's curve@@>
@@^Hilbert's curve@@>
@@^Bartholdi@@>
@@^Platzman@@>

We must normalize the coordinates to the unit square with bottom-left
corner lies at the origin.
Just to be pedantic, we must take care of the case where all the points
are on an line parallel to one of the axes.  This is the purpose of the
|XNORM| and |YNORM| macros.  We divide by $(1+\epsilon)$ so that we get values in the
interval $[0,1)$.

@@d XNORM(V) (tsp_instance->xmax==tsp_instance->xmin ? 0.0 : 
	((V)-tsp_instance->xmin)/(tsp_instance->xmax-tsp_instance->xmin)/(1+10*DBL_EPSILON));
@@d YNORM(V) (tsp_instance->ymax==tsp_instance->ymin ? 0.0 :
	((V)-tsp_instance->ymin)/(tsp_instance->ymax-tsp_instance->ymin)/(1+10*DBL_EPSILON));

@@d sgn(value) ((value)<0? -1 : ((value)>0? 1: 0))


@@<Module subroutines@@>=
int cmp_sfc_Moore(const void *voida, const void *voidb);
int
cmp_sfc_Moore(const void *voida, const void *voidb) 
{
	int ai=*(const int *)voida, bi=*(const int *)voidb;
	double a[2],b[2];
	int ax,ay,bx,by,aq,bq,lastq=12;
	int order[13][4] = 
		{{0,3,1,2},{0,1,3,2},{0,3,1,2},{2,3,1,0},
		 {0,3,1,2},{2,3,1,0},{0,1,3,2},{2,1,3,0},
		 {0,1,3,2},{2,3,1,0},{2,1,3,0},{2,1,3,0},{3,2,0,1}};
	int rewrite[13][4] = 
		{{1,3,2,0},{4,1,7,6} ,{8,9, 2, 0},{9,0, 5,10},
		 {1,9,2,0},{9,0,5,11},{2,1, 11,6},{7,10,8,5},
		 {2,1,7,6},{9,4,5,10},{7,10,6, 3},{7,10,6,5},{7,10,2,0}};
	
	a[0]=XNORM(tsp_instance->coord[ai].x[0]);
	b[0]=XNORM(tsp_instance->coord[bi].x[0]);
	a[1]=YNORM(tsp_instance->coord[ai].x[1]);
	b[1]=YNORM(tsp_instance->coord[bi].x[1]);
@@q VIM is just amazing.  It doesn't match parens in strings with parens@@>
@@q outside of strings.  I've still used at q"(" at> here in case you're using@@>
@@q some sad sack editor that isn't as smart as VIM in this respect. @@>
	errorif(a[0]<0 || a[0]>=1,@@q"("@@>"cmp_sfc_Moore: a[0] out of range [0,1): %f",a[0]);
	errorif(a[1]<0 || a[1]>=1,@@q"("@@>"cmp_sfc_Moore: a[1] out of range [0,1): %f",a[1]);
	errorif(b[0]<0 || b[0]>=1,@@q"("@@>"cmp_sfc_Moore: b[0] out of range [0,1): %f",b[0]);
	errorif(b[1]<0 || b[1]>=1,@@q"("@@>"cmp_sfc_Moore: b[1] out of range [0,1): %f",b[1]);
	while (1) {
		if ( a[0]==b[0] && a[1]==b[1] )@@+ return 0;
		ax = a[0] >= 0.5;@@+ ay = a[1] >= 0.5;@@+ aq = (ax<<1)+ay;
		bx = b[0] >= 0.5;@@+ by = b[1] >= 0.5;@@+ bq = (bx<<1)+by;
		if ( aq != bq ) return order[lastq][aq]-order[lastq][bq];
		lastq= rewrite[lastq][aq];
		a[0] = (2*a[0])-ax; a[1] = (2*a[1])-ay;
		b[0] = (2*b[0])-bx; b[1] = (2*b[1])-by;
	}
}

@@ We needed a definition of machine epsilon, |DBL_EPSILON|.  It is found
in \file{float.h}.
@@<System headers@@>=
#include <float.h>


@@*Timers.
This program has several phases of execution, and we want to measure 
each of these phases in various ways.
In particular, we will be measuring the
time required to build the auxiliary data structures, construct a starting
tour, and the run the Lin-Kernighan algorithm.
We will also measure the space used by these phases.

The \module{RESOURCE} module is a general purpose measurement tool.  We call
it to take
snapshots of the current resource usage.  First we need to allocate space
for those snapshots.  This allocation is part of the basic initialization
of the program.

@@<Do basic initialization@@>=
mem_usage_reset();	/* Start memory counter at zero. */
resource_setup(50);  /* 50 is magic: it is an upper bound on the 
	number of calls to  |resource_mark| */
error_postcleanup_stats = resource_abnormal_exit_output;

@@ We need to know the interface to the resource measurement module.
@@<Module headers@@>=
#include "resource.h"

@@ We also need to declare |last_resource_mark|, which counts
what it says it counts.  We need it in order to properly report the timings
and memory usage statistics.

@@<Module variables@@>=
static int last_resource_mark;

@@*Data structures.
An efficient implementation of the Lin-Kernighan algorithm requires several
data structures.  For a complete treatment, see the chapter by
Johnson and McGeoch, the paper by Fredman, Johnson, McGeoch and Ostheimer,
and the (as-yet unavailable) implementation report by Johnson, Bentley, 
McGeoch and Rothberg.

@@*1$K$-d trees.
The first of these data structure is a 2-d tree, for fast proximity
searching.

@@<Build the data structures@@>=
if ( E2_supports(tsp_instance) ) {
	begin_data_structures_mark =
	last_resource_mark = resource_mark("Build the 2-d tree");
	E2_create(tsp_instance);
	if ( ps_out ) { E2_postscript_show(ps_out); }
	@@<Test the $k$-d tree@@>@@;
} else {
	begin_data_structures_mark 
		= resource_mark("Begin building data structures (but not k-d tree)");
}


@@ We sometimes want to know when the data structures started being built.
@@<Global variables@@>=
int begin_data_structures_mark;

@@
@@<Exported variables@@>=
extern int begin_data_structures_mark;


@@*1 Declustering trees.
Declustering needs some preprocessing as well.  

First, we need a minimum
spanning tree for the TSP instance.

@@d ALWAYS_BUILD_DECLUSTER_STRUCTURES 
	(LK_BUILD_DECLUSTER_STRUCTURES 
	|| JBMR_DECLUSTER_IN_ELIGIBILITY_TEST 
	|| JBMR_DECLUSTER_IN_GREEDY)

@@<Build the data structures@@>=
if ( ALWAYS_BUILD_DECLUSTER_STRUCTURES || mst_edge_lengths_only ) {
	last_resource_mark = resource_mark("Build a MST (decluster)");
	mst_len = decluster_mst(tsp_instance,mst);
	if ( mst_edge_lengths_only ) {
		@@<Possibly output the MST as PostScript@@>@@;
		@@<Print the MST edge lengths and exit@@>@@;
	}
}


@@ Sometimes we're only interested in the set of edge lengths in a minimum
spanning tree for the instance.  In that case we print them and then 
immediately exit.

The output format is very simple: the number $n-1$ followed by $n-1$
(floating point) lengths.

@@<Print the MST edge lengths and exit@@>=
{
	int i;
	printf("%d\n",n-1);
	for (i=0;i<n-1;i++) printf("%.15f\n", (double) (mst->edge[i].cost));
	exit(0);
}

@@ If PostScript output is desired and the instance is two-dimensional, 
then we should also output the tree as PostScript.
@@<Possibly output the MST as PostScript@@>=
if (ps_out && tsp_instance->coord) {
	int i;
	fprintf(ps_out,"(MST length "length_t_spec") title\n",
		length_t_pcast(mst_len));
	fprintf(ps_out,"(%s) comment\n",tsp_instance->comment);
	for (i=0;i<n-1;i++) {
		const int *city=mst->edge[i].city;
		fprintf(ps_out,"%f %f %f %f ue\n",
			tsp_instance->coord[city[0]].x[0],
			tsp_instance->coord[city[0]].x[1],
			tsp_instance->coord[city[1]].x[0],
			tsp_instance->coord[city[1]].x[1]);
	}
	fprintf(ps_out,"showpage\ngrestore\n%%%%EOF");
	fclose(ps_out); ps_out=NULL;
}


@@ For ordinary processing, we have a second preprocessing task related
to declustering.
We digest the minimum spanning tree so that least common ancestor
queries may be answered in constant time.

@@<Build the data structures@@>=
#if ALWAYS_BUILD_DECLUSTER_STRUCTURES
last_resource_mark = resource_mark("Preprocess the MST (decluster)");
decluster_preprocess(mst);
#endif

@@
@@<Cleanup code@@>=
#if ALWAYS_BUILD_DECLUSTER_STRUCTURES
if ( verbose >=50 ) printf("Cleaning up MST\n");
if ( mst != NULL ) decluster_cleanup_tree(mst);
if ( verbose >=50 ) printf("Cleaning up decluster data strucutres\n");
decluster_cleanup();
#endif

@@
@@<Allocate the space for this instance@@>=
if ( ALWAYS_BUILD_DECLUSTER_STRUCTURES || mst_edge_lengths_only ) {
mst = decluster_setup(n);
}

@@ We need to declare the minimum spanning tree variable |mst|.  Eventually
I'll add code that uses the MST to characterize the clusteredness of 
an instance.

@@<Global variables@@>=
decluster_tree_t *mst;
length_t mst_len;

@@ We've used a bunch of stuff from the \module{DECLUSTER} module.
These inclusion directives are mandatory
because I want dependency
information to always be compiled in.  Header file \file{declevel.h}
specifies the amount of declustering that should be implemented.

@@<Module headers@@>=
#include "declevel.h"
#include "decluster.h"

@@*1 Nearest neighbour lists.
Johnson and McGeoch, and Johnson \etal.~demonstrate the performance
benefit of an adjacency structure in an implementation of the Lin-Kernighan
algorithm.  We build it now.

@@<Build the data structures@@>=
last_resource_mark = resource_mark("Build the adjacency structure");
errorif((candidate_expr & CAND_NN) && (cand_nn_k < 1), 
	"Neighbourhood bound must be positive, but is %d",cand_nn_k);
errorif((candidate_expr & CAND_NQ) && (cand_nq_k < 1), 
	"Neighbourhood quadrant bound must be positive, but is %d",cand_nq_k);
errorif(candidate_expr & CAND_DEL, "Candidate structure %d not supported",candidate_expr);
nn_build(
	(candidate_expr & CAND_NN) ? cand_nn_k : 0,
	(candidate_expr & CAND_NQ) ? cand_nq_k : 0,
	(candidate_expr & CAND_DEL) ? cand_del_d : 0);

@@ We need the interface to the nearest neighbours module.
@@<Module headers@@>=
#include "nn.h"

@@ We need to call the cleanup routine.  
For allocation, things are complicated enough in allocation that it's all
done in |nn_build|.

@@<Cleanup code@@>=
if ( verbose >=50 ) printf("Cleaning up nn structure\n");
nn_cleanup();


@@*The oriented tour ADT.
We also need an 
implementation of the tour abstract data type.  
This implementation both
stores and manipulates the current tour.
Fredman \etal.~introduce this ADT, experimented with various 
implementations of the ADT, and provided an amortized lower bound on the time
it requires to performe a worst-case sequence of operations.


@@ Throughout this program, cities are identified 
with integers |0,...,tsp_instance->n-1|, inclusive.

@@ The oriented tour ADT consists of the following operations:

|tour_next(a)| is a query that returns the city that follows $a$ in the
current tour.

|tour_prev(a)| is a query that returns the city that precedes $a$ in the
current tour.  It must be the case that 
|tour_next(tour_prev(a))==tour_prev(tour_next(a))==a|.

|tour_between(a,b,c)| is a query that returns true or false.  It answers
the question:  ``In a forward traversal starting at city $a$, do we reach
city $b$ no later than city $c$?''

|tour_flip(a,b,c,d)| updates the tour by replacing the edges $(a,b)$ and
$(c,d)$ by the edges $(b,c)$ and $(a,d)$.  It assumes that 
|a==tour_next(b)| and |d==tour_next(c)|.  The orientation of the updated tour
is not specified.

These four operations are the ones defined by Fredman \etal.  In fact, I
have lifted these descriptions from that paper and lightly edited them
for inclusion here.  

For convenience's sake, I also define |tour_set(int *t)|, which
sets the current tour to be the same as the array of
integers |t|.  That is, city |i| in the tour is city |t[i]|.
Note that we don't need a ``get'' routine because the tour can be read off
by successively following |tour_next| cities until we wrap to the start
again.

We also define the standard setup and clean procedures: |tour_setup(int n)| and
|tour_cleanup(void)|.  The parameter to the setup procedure is the number
of cities in the instance.

@@
We isolate the implementation of the tour ADT both because it
is good design practice, and because at run time we may want to select from
several of the
possible implementations.

So, each of the operation names given above are actually function pointers
to actual implementations of these operations.

@@<Global variables@@>=
int (*tour_next)(int) = NULL;
int (*tour_prev)(int) = NULL;
int (*tour_between)(int,int,int) = NULL;
void (*tour_flip)(int,int,int,int) = NULL;
void (*tour_set)(int const *) = NULL;
void (*tour_setup)(int n) = NULL;
void (*tour_cleanup)(void) = NULL;

@@
@@<Exported variables@@>=
extern int (*tour_next)(int);
extern int (*tour_prev)(int);
extern int (*tour_between)(int,int,int);
extern void (*tour_flip)(int,int,int,int);
extern void (*tour_set)(int const *);
extern void (*tour_setup)(int n);
extern void (*tour_cleanup)(void);

@@ Currently, only the \type{array}, \type{two-level}, and \type{tld}
representations
are available.

@@<Parse the command line@@>=
switch(representation) {
case REP_ARRAY:
tour_next = array_next;
tour_prev = array_prev;
tour_between = array_between;
tour_flip = array_flip;
tour_set = array_set;
tour_setup = array_setup;
tour_cleanup = array_cleanup;
break;
case REP_TWO_LEVEL:
tour_next = twolevel_next;
tour_prev = twolevel_prev;
tour_between = twolevel_between;
tour_flip = twolevel_flip;
tour_set = twolevel_set;
tour_setup = NULL;	/* Special instructions below. */
tour_cleanup = twolevel_cleanup;
break;
case REP_TWO_LEVEL_DEBUG:
#if defined(TWOLEVEL_DEBUG)
tour_next = twolevel_debug_next;
tour_prev = twolevel_debug_prev;
tour_between = twolevel_debug_between;
tour_flip = twolevel_debug_flip;
tour_set = twolevel_debug_set;
tour_setup = NULL;	/* Special instructions below. */
tour_cleanup = twolevel_debug_cleanup;
#else
	errorif(1,"Two-level tree debugging (-DTWOLEVEL_DEBUG) wasn't compiled into the program");
#endif
break;
default:
	errorif(1,"Only array, two-level, and tld representations are currently supported");
}

@@ But first we need to include the appropriate tour interfaces.
@@<Module headers@@>=
#include "array.h"
#include "twolevel.h"

@@ We must call the |tour_setup| function before any of the other 
tour operations.  It allocates the requisite space for the tour
ADT implementation.

Two-level trees require an extra parameter, namely a group size.
Fredman \etal (INSERT REFERENCE) use a value of 100 for $n$ between
$10^3$ and $10^5$; they use a value of 200 for larger instances.
We'll extend the bottom end of this range by using a value of $n$
up to 50, and then a value of 50 for $n$ up to 1000.

Of course, tour representations are irrelevant when finding a weighted
matching!

@@<Allocate the space for this instance@@>=
if ( do_weighted_perfect_matching) {
	tour_setup=NULL;
} else { /* Yes, we really need a tour representation. */
switch(representation) {
case REP_TWO_LEVEL:
	{
	const int n=tsp_instance->n;
	twolevel_setup
		(n, n < 50 ? n : (n < 1000 ? 50 : (n > 100000 ? 200 :  100)));
	}
	break;
case REP_TWO_LEVEL_DEBUG:
	{
#if defined(TWOLEVEL_DEBUG)
	const int n=tsp_instance->n;
	twolevel_debug_setup
		(n, n < 50 ? n : (n < 1000 ? 50 : (n > 100000 ? 200 :  100)));
#else
	errorif(1,"Debugging of two-level isn't possible.  Recompile with -DTWOLEVEL_DEBUG");
#endif
	}
	break;
default:
	tour_setup(tsp_instance->n);
}
}


@@ When shutting down, we ought to call the cleanup function.
(But remember this might happen very early in the execution.)
@@<Cleanup code@@>=
if ( !do_weighted_perfect_matching ) {
	if ( verbose >=50 ) printf("Cleaning up tour data structure\n");
	if ( tour_cleanup != NULL ) (*tour_cleanup)();
}

@@ All local search algorithms for the TSP need a starting tour.
The procedure |construct| builds one for us, given |n| and some space
in which to write its results.

@@<Construct a starting tour@@>=
last_resource_mark = resource_mark("Construct starting tour");
tour = new_arr_of(int,n);
incumbent_len = construct(n,tour,construction_algorithm,start_heuristic_param);
if (verbose>=10) printf("Initial tour length: "length_t_spec"\n",length_t_pcast(incumbent_len));
@@<Possibly output the starting tour as PostScript@@>@@;

@@ If PostScript output is desired and the instance is two-dimensional, 
then we should also output the tree as PostScript.
@@<Possibly output the starting tour as PostScript@@>=
if (ps_out && tsp_instance->coord && verbose >= 50 && 
!do_weighted_perfect_matching ) {
	int i;
	const char *tour_name;
	switch( construction_algorithm ) {
	case CONSTRUCT_CANONICAL: tour_name="Canonical"; break;
	case CONSTRUCT_GREEDY: tour_name="Greedy"; break;
	case CONSTRUCT_RANDOM: tour_name="Random"; break;
	default: errorif(1,"Unkown start tour parameter %d\n",construction_algorithm);
		tour_name=""; /* Satisfy GCC's dataflow analysis. */
	}
	fprintf(ps_out,"(%s tour length "length_t_spec") title\n",
		tour_name,
		length_t_pcast(incumbent_len));
	fprintf(ps_out,"(%s) comment\n",tsp_instance->comment);
	for (i=0;i<n;i++) {
		const int city=tour[i], next_city=tour[(i+1)%n];
		fprintf(ps_out,"%f %f %f %f ue\n",
			tsp_instance->coord[city].x[0],
			tsp_instance->coord[city].x[1],
			tsp_instance->coord[next_city].x[0],
			tsp_instance->coord[next_city].x[1]);
	}
	fprintf(ps_out,"showpage\n");
}

@@ We've used some general purpose memory allocation routines,
which in turn use some error-checking
routines.  Their interfaces are given in the following header files.

@@<Early module headers@@>=
#include "error.h"
#include "memory.h"

@@ We also need the interface to the construction module.
@@<Module headers@@>=
#include "construct.h"

@@ We need to declare the |tour| array.
@@<Module variables@@>=
static int *tour;

@@ And then free it when we're done.
@@<Cleanup code@@>=
if ( !do_weighted_perfect_matching ) {
	if ( verbose >=50 ) printf("Cleaning initial tour\n");
	free_mem(tour);
}

@@ The variable |incumbent_len| is the length of the best tour found and
committed to so far.
@@<Global variables@@>=
length_t incumbent_len;

@@ We make it visible to the outside world.
@@<Exported variables@@>=
extern length_t incumbent_len;

@@ Once we have a starting tour in hand, we initialize the tour ADT
implementation.

@@<Construct a starting tour@@>=
tour_set(tour);

@@*The Lin-Kernighan algorithm.
Lin-Kernighan is a local search algorithm.  I've modeled my implementation
after that of Johnson, Bentley, McGeoch, and Rothberg, as described
in by Johnson and McGeoch in ``Local Search and the Traveling Salesman
Problem'', (INSERT REFERENCE).  The code appears in module \module{JBMR},
named in honour of Johnson \etal.

@@<Run the Lin-Kernighan algorithm@@>=
last_resource_mark = resource_mark("Lin-Kernighan");
if ( do_weighted_perfect_matching ) {
	match_run(3,iterations,prng_new(PRNG_DEFAULT,1998));
} else { /* Do the TSP. */
	jbmr_run(iterations,prng_new(PRNG_DEFAULT,1998));
}

@@ We need the interface to modules \module{JBMR} and \module{PRNG}.

@@<Module headers@@>=
#include "jbmr.h"

@@
@@<Early module headers@@>=
#include "prng.h"

@@ We need to call its setup and cleanup procedures.
@@<Allocate the space for this instance@@>=
if ( !do_weighted_perfect_matching ) jbmr_setup(n);

@@
@@<Cleanup code@@>=
if ( !do_weighted_perfect_matching ) {
	if ( verbose >=50 ) printf("Cleaning up jbmr structures\n");
	jbmr_cleanup();
}

@@* Weighted perfect matchings.
This program also (belatedly) handles finding cheap weighted perfect
matchings.   We use the same TSPLIB inputs as before, except we interpret
them as weighted matching problem instances instead of traveling salesman
problem instances.  

Of course, we need the interface to the \module{MATCH} module.

@@<Module headers@@>=
#include "match.h"

@@ If the instance has an odd number of vertices, then there is no
perfect matching.  

@@<Read the TSP instance@@>=
if ( do_weighted_perfect_matching ) {
errorif(n % 2,"Must have even number of vertices to have a perfect matching");
}

@@ Except for the tour representation and the starting tour, 
all the same data structures are used.  Here are the extra bits we need.

@@<Allocate...@@>=
if ( do_weighted_perfect_matching ) {
	match_setup(n);
}

@@
@@<Cleanup code@@>=
if ( do_weighted_perfect_matching ) {
	match_cleanup();
}

@@
@@<Construct a starting matching@@>=
last_resource_mark = resource_mark("Construct starting matching");
incumbent_len = match_construct(construction_algorithm,start_heuristic_param);
if (verbose>=10) printf("Initial matching length: "length_t_spec"\n",
		length_t_pcast(incumbent_len));
@@<Possibly output the starting matching as PostScript@@>@@;


@@
@@<Possibly output the starting matching as PostScript@@>=
if (ps_out && tsp_instance->coord) {
	char heuristic_name[200];
	switch(construction_algorithm) {
	case CONSTRUCT_CANONICAL: sprintf(heuristic_name,"Canonical");break;
	case CONSTRUCT_GREEDY: sprintf(heuristic_name,"Greedy");break;
	case CONSTRUCT_RANDOM: sprintf(heuristic_name,"Random %ld",start_heuristic_param);break;
	default: sprintf(heuristic_name,"unknown--Bug!");
	}
	match_ps_out(ps_out,heuristic_name);
}



@@ Beyond that, there are some differences in the winding down phase.



@@*Winding down.
When the program has finished its work, it gives us the answer it
has computed and reports the performance of the various phases of the
execution.  It then cleans up after itself.

@@<Stop the timers and print interval times@@>=
last_resource_mark = resource_mark("The end");
if (verbose>=2) {
	int i;
	if ( verbose >=5 )
		for (i=0;i<last_resource_mark;i++) {
			resource_report(stdout,i,i+1);
		}
	if ( last_resource_mark > 0 ) {
		resource_report(stdout,begin_data_structures_mark,last_resource_mark);
	}
	if (verbose>=10) {
		printf("End time: ");@@+@@<Print the current time@@>@@;
		mem_report();
	}
	@@<Print the machine name@@>@@;
}


@@
@@<System headers@@>=
#if HAVE_SYS_PARAM_H 
#include <sys/param.h>
#endif
#if HAVE_UNISTD_H
#include <unistd.h>	/* For |gethostname()| under AIX. */
#endif

@@ For some reason, |MAXHOSTNAME| is not defined by the Solaris header
file \file{<sys/param.h>}, although the manual page says it should be.
In that case, we define it ourselves to be 256, which is the current
value advertised on that page.
@@<Print the machine name@@>=
#if HAVE_GETHOSTNAME
{
#if !defined(MAXHOSTNAMELEN)  
#define MAXHOSTNAMELEN 256    
#endif /*  |!defined(MAXHOSTNAMELEN)| */
char buf[MAXHOSTNAMELEN+1];
gethostname(buf,MAXHOSTNAMELEN);
buf[MAXHOSTNAMELEN]=0;
printf("Machine: %s\n",buf);
}
#endif /* |HAVE_GETHOSTNAME| */


@@ We factor out the cleanup code into a the procedure |lk_cleanup| because
it may be called by the error checking routines.

@@<Free the allocated space@@>=
lk_cleanup();

@@ What does |lk_cleanup| do?  It calls the cleanup routines for all the
other modules.

@@<Module subroutines@@>=
static void lk_cleanup(void) 
{
	@@<Cleanup code@@>@@;
}

@@ This procedure needs to be known within this compilation unit only.
@@<Static prototypes@@>=
static void lk_cleanup(void);

@@ The error checking routine needs to know what procedure to call
to clean up.  We use a function pointer variable to do this in order
to keep the error module cleanly separated from the rest of the program.
The variable belongs to the error module, but we set it here.

@@<Do basic initialization@@>=
error_cleanup = lk_cleanup;

@@ After an error condition and subsequent cleanup, we 
want to report the memory statistics.  This might help us detect the
problem.  Again, |error_postcleanup_stats| belongs to the \module{ERROR}
module.

@@<Do basic initialization@@>=
error_postcleanup_stats = mem_report;

@@ We have a separate named section for the cleanup code so it can be added
to as necessary later in this file.  For now we just put in the call to
the cleanup code for the resource manager.

All this  code should be idempotent and should be able to be called before
any calls to the corresponding initialization code.  

@@<Cleanup code@@>=
resource_cleanup();


@@
	@@<Exported type definitions@@>=
@@
	@@<Exported variables@@>=
@@
	@@<Exported subroutines@@>=

@@ We should check to see that |jbmr_run| actually improved the result 
by as much as it says it did.   Of course, floating point computations
lose precision, so we only check to within a certain error tolerance.
For now, that error tolerance is half a unit.  In the future we might
allow the user to specify a tolerance.

We also make sure the tour is actually a tour.

We print the tour if the user's asked for it.  Right now it's just
the word ``Tour:'' followed by lines with up to 10 city numbers.
In the future, consider changing the code to
print it in TSPLIB's tour format, and possibly to a file.

@@d my_abs(A) ((A)<0?-(A):(A))
@@d within_epsilon(A,B) (my_abs(((A)-(B))) < 0.5)

@@<Validate and print the result@@>=
if ( do_weighted_perfect_matching ) {
	match_validate(&validate_len,&double_validate_len,&ordered_double_len,&raw_len);
} else {
	int i, c,cn;
	double *lengths = new_arr_of(double,n);
	double *raw_lengths = new_arr_of(double,n);
	double *length_t_lengths = new_arr_of(length_t,n);
	validate_len = 0;
	double_validate_len = ordered_double_len = raw_len=0.0;
	for ( i=0, c=0; i<n ; i++ ) {
		errorif( c == 0 && i > 0, "Not a tour");
		cn = tour_next(c);
		length_t_lengths[i]=cost(c,cn);
		double_validate_len += (double)length_t_lengths[i];
		lengths[i]=(double)length_t_lengths[i];
		if ( tsp_instance->edge_weight_type == EUC_2D ||
		     tsp_instance->edge_weight_type == CEIL_2D ) {
			raw_lengths[i]=cost_from_euc2d_raw(c,cn);
		} else {
			raw_lengths[i]=lengths[i];
		}
		c = cn;
	}
	sort(lengths,(unsigned)n,sizeof(double),lk_double_cmp);
	sort(raw_lengths,(unsigned)n,sizeof(double),lk_double_cmp);
	sort(length_t_lengths,(unsigned)n,sizeof(length_t),lk_length_t_cmp);
	for (i=0;i<n;i++) {
		ordered_double_len += lengths[i];
		raw_len += raw_lengths[i];
		validate_len += length_t_lengths[i];
	}
	free_mem(lengths); 
	free_mem(raw_lengths);
	free_mem(length_t_lengths);
	mem_deduct(n*(sizeof(double)+sizeof(double)+sizeof(length_t)));
	errorif( c != 0, "Not a tour");
}

@@
@@<Validate and print the result@@>=
if (verbose>=2) {
	printf("Instance name: %s\n",tsp_instance->name);
	printf("Instance comment: %s\n",tsp_instance->comment);
}
if ( should_show_tour ) { /* ``Are ya shure?'' */
	if ( do_weighted_perfect_matching ) {
		match_show(stdout);
	} else {
		int i, c;
		printf("Tour:\n");
		for ( i=0, c=0; i<n ; i++, c=tour_next(c) ) {
			printf("%d ",(original_city_num?original_city_num[c]:c)+1);	
				/* Use 1-based convention of TSPLIB, and maybe remap. */
			if ( (i % 10) == 9 || i==n-1 ) printf("\n"); 
		}
	}	
}
if ( verbose >=2 ) printf("Length: ");
if ( verbose ) printf( noround ? "%f\n" : "%.0f\n", (double)validate_len);
if ( verbose >= 10 ) {
	printf( "\tincumbent_len       == " length_t_spec "\n" @@|
			"\tvalidate_len        == " length_t_spec "\n" @@|
			"\tdouble_validate_len == %f\n" @@|
			"\tordered_double_len  == %f\n" @@|
			"\traw_len             == %f\n" @@|
			"\tdiscrepancy == (incumbent_len-ordered_double_len) == %-10g\n",
			length_t_pcast(incumbent_len),
			length_t_pcast(validate_len),
			double_validate_len, 
			ordered_double_len, 
			raw_len,
			((double)incumbent_len)-ordered_double_len );
}
errorif( !within_epsilon(((double)incumbent_len),ordered_double_len),
	"%s mistaken about improvement", 
	do_weighted_perfect_matching ?  "match_run()" : "jbmr_run()" );

@@
@@<|main| variables@@>=
length_t validate_len;
double double_validate_len, ordered_double_len, raw_len;


@@ Now let's print it to the PostScript output, if that stream is open.
@@<Validate and print the result@@>=
if ( ps_out ) {
	if ( do_weighted_perfect_matching ) {
		match_ps_out(ps_out,(const char *)"LK-opt");
	} else {
		int i, c,cn;
		fprintf(ps_out,"%%Here's the final tour\n");
		fprintf(ps_out,"(LK opt, tour len "length_t_spec") title\n",
			length_t_pcast(incumbent_len));
		fprintf(ps_out,"(%s) comment\n",tsp_instance->comment);
		for ( i=0, c=0; i<n ; i++, c=cn ) {
			cn = tour_next(c);
			errorif( c == 0 && i > 0, "Not a tour");
			fprintf(ps_out,"%f x %f y %f x %f y rawedge\n",
				tsp_instance->coord[cn].x[0],
				tsp_instance->coord[cn].x[1],
				tsp_instance->coord[c].x[0],
				tsp_instance->coord[c].x[1]);
		}
		fprintf(ps_out,"showpage\n");fflush(ps_out);
	}
	fprintf(ps_out,"end\ngrestore\n%%EOF\n");fclose(ps_out);
}


@@
@@<Subroutines@@>=
int
lk_double_cmp(const void *a, const void *b)
{
	const double da=*((const double*)a), db=*((const double*)b);
	if (da<db) return -1;
	if (da>db) return +1;
	return 0;
}

int
lk_length_t_cmp(const void *a, const void *b)
{
	const length_t da=*((const length_t*)a), db=*((const length_t*)b);
	if (da<db) return -1;
	if (da>db) return +1;
	return 0;
}

@@
@@<Exported subroutines@@>=
int lk_double_cmp(const void *a, const void *b);
int lk_length_t_cmp(const void *a, const void *b);

@@
@@<Test the $k$-d tree@@>=
#ifdef LK_CHECK_KDTREE
if ( E2_supports(tsp_instance) ) {
int i,c,d,*done=new_arr_of(int,n), last;
	length_t last_dist, next_dist;
for (c=0; c<n;c++) {
	if (verbose) printf("%d ",c); fflush(stdout);
	for (i=0;i<n;i++) {
		done[i]=0;
	}
	done[c]=1;
	last_dist=0;
	last = c;
	for(i=0;i<n-1;i++) {
		d=E2_nn(c);
		if (0<=d && d<n ) {
			next_dist=cost(c,d);
			errorif(last_dist>next_dist,
				"NN for %d out of order: #%d %d cost="length_t_spec", "
				"#%d %d cost="length_t_spec,
				c,i-1,last,length_t_pcast(last_dist),
				i,d,length_t_pcast(next_dist));

			if  (verbose>=500) {
				printf("nn(%d) #%d = %d dist "length_t_spec"\n",c,i,d,length_t_pcast(cost(c,d)));
			}
				
			last_dist=next_dist;
			last=d;
		} else {
			printf("Invalid city %d returned on nn query %d from %d\n",
				d,i,c);
		}
		errorif(done[d],"Shouldn't return %d on nn query at %d",d,c);
		E2_hide(d);
		done[d]=1;
	}
	d = E2_nn(c);
	errorif(d!=-1,"nn(%d) returned %d when all others hidden; should be -1.\n",
			c,d);
	E2_unhide_all();
}
free_mem(done);
if (verbose) printf("\nkd tree passed an integrity test on nearest-neighbour searching\n");
}
#endif



@@*Index.
@


1.250
log
@Check that the upper bound is given when computing held karp lower bounds.
Of course, I could always compute it on the fly....
@
text
@d1 47
a47 1
@@i copyrt.w
d53 4
d550 1
a550 1
const char *lk_rcs_id="$Id: lk.w,v 1.249 1998/05/29 21:01:10 neto Exp neto $";
@


1.249
log
@Off by a factor of 100 in calculation of percentage for Held Karp.
@
text
@d7 3
d500 1
a500 1
const char *lk_rcs_id="$Id: lk.w,v 1.248 1998/05/23 18:23:32 neto Exp neto $";
d792 1
d1231 5
@


1.248
log
@Doh.  Was discarding the held karp bound. Fixed. I hope
@
text
@d7 3
d497 1
a497 1
const char *lk_rcs_id="$Id: lk.w,v 1.247 1998/05/23 18:09:57 neto Exp neto $";
d1546 1
a1546 1
			((double)(upper_bound_value-held_karp_bound))/upper_bound_value, 
@


1.247
log
@Needed casts around length t stuff in held karp bounds.
@
text
@d7 3
d494 1
a494 1
const char *lk_rcs_id="$Id: lk.w,v 1.246 1998/05/23 17:31:25 neto Exp neto $";
d1536 1
a1536 1
	length_t lower_bound; 
d1539 1
a1539 1
	lower_bound = ascend(n,upper_bound_value);
d1542 2
a1543 2
		length_t_pcast(lower_bound_value),
			((double)(upper_bound_value-lower_bound_value))/upper_bound_value, 
@


1.246
log
@This now compiles to .o.
(The cleanup function needs access to do weighted perfect matching.
But it doesn't handle held karp only...)
@
text
@d7 5
d491 1
a491 1
const char *lk_rcs_id="$Id: lk.w,v 1.245 1998/05/23 16:22:53 neto Exp neto $";
d1538 4
a1541 2
		" (%.2f below upper bound " length_t_spec")\n",
		lower_bound_value, (upper_bound_value-lower_bound_value)/upper_bound_value, upper_bound_value);
@


1.245
log
@Added proper setup of held-karp lower bound.
Added options for upper bound.  Change -b to -l, a lower bound.
Added options for held karp computations.
@
text
@d7 5
d486 1
a486 1
const char *lk_rcs_id="$Id: lk.w,v 1.244 1998/05/21 15:46:08 neto Exp neto $";
d781 6
a786 6
@@<|main| variables@@>=
char *filename;
int mst_edge_lengths_only;
int do_weighted_perfect_matching;
int held_karp_only;
int held_karp_lambda_only;
d1529 1
a1529 1
	errorif(upper_bound<=0,"main: upper bound %d should be positive.",upper_bound);
d1531 1
a1531 1
	lower_bound = ascend(n,upper_bound);
d1534 1
a1534 1
		lower_bound, (upper_bound-lower_bound)/upper_bound, upper_bound);
d1536 1
d1548 3
@


1.244
log
@New interface to match run
@
text
@d7 3
d439 8
a446 1
See the famous 1973 paper (insert reference) by Shen Lin and Brian Kernighan
d448 12
a459 2
A more modern source is the chapter by Johnson and McGeoch (insert reference);
it describes the Lin-Kernighan (LK from now on) algorithm in the
d466 2
d481 1
a481 1
const char *lk_rcs_id="$Id: lk.w,v 1.243 1998/04/10 15:13:31 neto Exp neto $";
d538 1
d699 1
a699 1
Option \type{-b} or \type{--bound} 
d706 1
a706 1
specifying \type{-b optimal 14379}. 
d711 1
a711 1
Simliarly, \type{-b Held-Karp 702.3} might be used to get messages like
d716 16
d776 2
a777 2
@@<Module variables@@>=
static char *filename;
d780 2
d791 2
d802 4
a805 2
	bound_name = NULL;
	bound_value=1.0; /* Dummy. */
d815 1
a815 1
char *PostScript_filename, *bound_name;
d818 1
a818 1
double bound_value;
d826 1
a826 1
extern char *PostScript_filename, *bound_name;
d829 1
a829 1
extern double bound_value;
d854 2
a855 1
	printf(" -b --bound <name> <length> Give lower bound, enable milestones\n");
d860 5
d886 2
d926 16
d1169 1
a1169 1
@@ The bound option needs a name and a floating-point number.
d1173 1
a1173 1
if ( strcmp(argv[r],"-b")==0 || strcmp(argv[r],"--bound")==0 ) {
d1176 1
a1176 1
		fprintf(stderr,"Need a bound name\n");
d1185 22
a1206 1
	bound_name=dup_string(argv[r]);
d1208 1
a1208 1
	bound_value=atof(argv[r]);
d1212 1
d1382 3
d1423 2
a1424 1
	if ( bound_name != NULL ) printf("-b %s %f ", bound_name, bound_value);
d1515 28
d2239 1
a2239 1
		resource_report(stdout,0,last_resource_mark);
@


1.243
log
@Made safe for non-E2 instances
@
text
@d7 3
d459 1
a459 1
const char *lk_rcs_id="$Id: lk.w,v 1.242 1998/02/21 04:05:19 neto Exp neto $";
d2016 1
a2016 1
	match_run(3);
@


1.242
log
@Added support for Iterated LK (for TSP).
Also fixed some output stuff for matching.
@
text
@d7 4
d456 1
a456 1
const char *lk_rcs_id="$Id: lk.w,v 1.241 1998/01/23 21:04:55 neto Exp neto $";
d2357 2
a2358 1
{ int i,c,d,*done=new_arr_of(int,n), last;
@


1.241
log
@Now it compiles well with match module.
Fixed some printing minor errors.
@
text
@d7 4
d452 1
a452 1
const char *lk_rcs_id="$Id: lk.w,v 1.240 1997/12/20 20:44:12 neto Exp neto $";
d460 1
d739 1
a739 1
	iterate = 0;
d759 1
a759 1
int verbose, iterate, should_show_tour, should_show_version;
d770 1
a770 1
extern int verbose, iterate, should_show_tour, should_show_version;
d951 2
a952 2
	iterate = 20;
	if ( r+1<argc && is_number(argv[r+1]) ) iterate = atoi(argv[++r]);
d1287 1
a1287 1
	if ( iterate ) printf("-i %d ",iterate);@@#
d1472 1
a1472 1
int *original_city_num;
d2009 1
a2009 1
	match_run();
d2011 1
a2011 1
	jbmr_run();
d2014 1
a2014 1
@@ We need the interface to module \module{JBMR}.
d2019 4
a2088 7
@@ Finally, instead of running the TSP version of Lin-Kernighan, run
the weighted matching version of it.

@@<Run the Lin-Kernighan algorithm@@>=
if ( do_weighted_perfect_matching ) {
	match_run();
}
d2303 1
a2303 1
		match_ps_out(ps_out,(char *)"LK-opt");
@


1.240
log
@Changed variable "start tour" to "construction algorithm".
It's more descriptive and more accurate.
@
text
@d7 4
d448 1
a448 1
const char *lk_rcs_id="$Id: lk.w,v 1.239 1997/12/20 20:31:25 neto Exp neto $";
d806 1
a806 1
		   "                            rather than short tours");
d1466 5
d2055 1
a2055 1
	match_cleanup(n);
d2085 1
a2085 1
	match_run(n);
d2289 1
a2289 1
	do_weighted_perfect_matching ?  "jbmr_run()" : "match_run()" );
d2301 1
a2301 1
		match_ps_out(ps_out,"LK-opt");
@


1.239
log
@Import the matching header.
Fix raw lengths if CEIL 2D.
Export comparison functions for double and length t.
@
text
@d7 5
d444 1
a444 1
const char *lk_rcs_id="$Id: lk.w,v 1.238 1997/12/20 18:38:16 neto Exp neto $";
d740 1
a740 1
	start_tour = CONSTRUCT_GREEDY;
d751 1
a751 1
int representation, start_tour;
d762 1
a762 1
extern int representation, start_tour;
d991 2
a992 2
	if ( strcmp(argv[r],"greedy")==0 ) start_tour = CONSTRUCT_GREEDY;
	else if ( strcmp(argv[r],"canonical")==0 ) start_tour = CONSTRUCT_CANONICAL;
d994 1
a994 1
		start_tour = CONSTRUCT_RANDOM;
d1279 1
a1279 1
	switch(start_tour) {
d1283 1
a1283 1
	default: errorif(1,"Bad start_tour == %d\n",start_tour);
d1914 1
a1914 1
incumbent_len = construct(n,tour,start_tour,start_heuristic_param);
d1925 1
a1925 1
	switch( start_tour ) {
d1929 1
a1929 1
	default: errorif(1,"Unkown start tour parameter %d\n",start_tour);
d2052 1
a2052 1
incumbent_len = match_construct(start_tour,start_heuristic_param);
d2062 1
a2062 1
	switch(start_tour) {
@


1.238
log
@Added first draft of support for doing minimum weighted perfect matchings.
@
text
@d7 3
d439 1
a439 1
const char *lk_rcs_id="$Id: lk.w,v 1.237 1997/12/19 20:46:37 neto Exp neto $";
d2017 5
d2061 1
a2061 1
	default: sprintf(heuristic_name,"(unknown--Bug!)");
d2215 2
a2216 1
		if ( tsp_instance->edge_weight_type == EUC_2D)
d2218 3
d2223 3
a2225 3
	sort(lengths,(unsigned)n,sizeof(double),double_cmp);
	sort(raw_lengths,(unsigned)n,sizeof(double),double_cmp);
	sort(length_t_lengths,(unsigned)n,sizeof(length_t),length_t_cmp);
a2303 1
		fprintf(ps_out,"end\ngrestore\n%%EOF\n");fclose(ps_out);
d2305 1
d2310 1
a2310 2
@@<Module subroutines@@>=
int double_cmp(const void *a, const void *b);
d2312 1
a2312 1
double_cmp(const void *a, const void *b)
a2319 1
int length_t_cmp(const void *a, const void *b);
d2321 1
a2321 1
length_t_cmp(const void *a, const void *b)
d2328 5
@


1.237
log
@Fixed the calls to decluster mst and preprocess: I was passing the
instance to the wrong procedure.
@
text
@d7 4
d436 1
a436 1
const char *lk_rcs_id="$Id: lk.w,v 1.236 1997/12/13 21:31:04 neto Exp neto $";
d495 5
a499 1
	@@<Construct a starting tour@@>@@;
d538 1
a538 1
Option \type{-p} or \type{--postscript} has a mandatory filename argument.
d602 5
a606 2
Option \type{-t} or \type{--tour} tells us to print the tour when
we're done.  The default is to not print the tour, because I'm most
d609 1
a609 1
Option \type{-m} or \type{--mst-edge-lengths-only} tells us to 
d669 10
d716 1
d726 1
d784 3
a786 3
	printf(" --                         end options\n");
	printf(" -b --bound <name> <length> give lower bound, enable milestones\n");
	printf(" -c --candidate <p>         specify candidate cities\n");
d790 1
a790 1
	printf(" -h --help                  give this help, then exit\n");
d793 3
a795 1
	printf(" -m --mst-edge-lengths-only print the edge lengths in a minimum spanning tree\n");
d797 6
a802 5
	printf("    --maxdepth [d]          limit probe depth to d cities\n");
	printf("    --no-round              don't round distance computations\n");
	printf(" -p --postscript <file>     generate PostScript output and write to <file>\n");
	printf(" -q --quiet                 same as --verbose 0\n");
	printf(" -r --representation <rep>  specify tour representation (default is array)\n");
d804 6
a809 4
	printf(" -s --start <kind>          specify staring tour (default is best)\n");
	printf("      <kind> ::= greedy | random [seed]\n");
	printf("    --sfc                   reorder cities by Moore's space filling curve\n");
	printf(" -S --sort <kind>           specify sorting procedure (default is qsort)\n");
d811 2
a812 3
	printf(" -t --tour                  print the final tour\n");
	printf(" -v --verbose [n]           set verbose level (default is 5, n default is 100)\n");
	printf("    --version               print LK version number, then exit successfully\n");
d836 1
a836 1
if ( strcmp(argv[r],"-t")==0 || strcmp(argv[r],"--tour")==0 ) {
d844 1
a844 1
if ( strcmp(argv[r],"-m")==0 || strcmp(argv[r],"--mst-edge-lengths-only")==0 ) {
d849 11
d1058 1
a1058 1
if ( strcmp(argv[r],"-p")==0 || strcmp(argv[r],"--postscript")==0 ) {
d1266 2
a1267 1
	if ( should_show_tour ) printf("-t ");
d1269 1
a1269 1
	if ( NULL != PostScript_filename ) printf("-p %s ",PostScript_filename);
d1740 1
a1740 1
with integers $0,\ldots,tsp_instance->n-1$, inclusive.
d1859 3
d1863 3
d1888 1
d1894 4
a1897 2
if ( verbose >=50 ) printf("Cleaning up tour data structure\n");
if ( tour_cleanup != NULL ) (*tour_cleanup)();
d1913 2
a1914 1
if (ps_out && tsp_instance->coord && verbose >= 50 ) {
d1957 4
a1960 2
if ( verbose >=50 ) printf("Cleaning initial tour\n");
free_mem(tour);
d1986 5
a1990 1
jbmr_run();
d1999 1
a1999 1
jbmr_setup(n);
d2003 66
a2068 2
if ( verbose >=50 ) printf("Cleaning up jbmr structures\n");
jbmr_cleanup();
d2192 4
a2195 1
{ int i, c,cn;
d2233 11
a2243 7
	int i, c;
	printf("Tour:\n");
	for ( i=0, c=0; i<n ; i++, c=tour_next(c) ) {
		printf("%d ",(original_city_num?original_city_num[c]:c)+1);	
			/* Use 1-based convention of TSPLIB, and maybe remap. */
		if ( (i % 10) == 9 || i==n-1 ) printf("\n"); 
	}
d2248 5
a2252 5
	printf( "\tincumbent_len       == " length_t_spec "\n"
			"\tvalidate_len        == " length_t_spec "\n"
			"\tdouble_validate_len == %f\n"
			"\tordered_double_len  == %f\n"
			"\traw_len             == %f\n"
d2262 2
a2263 1
	"jbmr_run() mistaken about improvement" );
d2274 19
a2292 13
	int i, c,cn;
	fprintf(ps_out,"%%Here's the final tour\n");
	fprintf(ps_out,"(LK opt, tour len "length_t_spec") title\n",
		length_t_pcast(incumbent_len));
	fprintf(ps_out,"(%s) comment\n",tsp_instance->comment);
	for ( i=0, c=0; i<n ; i++, c=cn ) {
		cn = tour_next(c);
		errorif( c == 0 && i > 0, "Not a tour");
		fprintf(ps_out,"%f x %f y %f x %f y rawedge\n",
			tsp_instance->coord[cn].x[0],
			tsp_instance->coord[cn].x[1],
			tsp_instance->coord[c].x[0],
			tsp_instance->coord[c].x[1]);
a2293 2
	fprintf(ps_out,"showpage\n");fflush(ps_out);
	fprintf(ps_out,"end\ngrestore\n%%EOF\n");fclose(ps_out);
@


1.236
log
@Ooops, I put it in the wrong place!
@
text
@d7 3
d432 1
a432 1
const char *lk_rcs_id="$Id: lk.w,v 1.235 1997/12/13 21:28:15 neto Exp neto $";
d1572 1
a1572 1
	mst_len = decluster_mst(mst);
d1624 1
a1624 1
decluster_preprocess(tsp_instance,mst);
@


1.235
log
@decluster mst now takes the tsp instance argument instead of relying on
a global variable.
@
text
@d7 4
d429 1
a429 1
const char *lk_rcs_id="$Id: lk.w,v 1.234 1997/12/13 16:47:54 neto Exp neto $";
d1621 1
a1621 1
decluster_preprocess(mst);
d1636 1
a1636 1
mst = decluster_setup(tsp_instance,n);
@


1.234
log
@Updated to new interface with error module.
Made all module names upper case.
@
text
@d7 4
d425 1
a425 1
const char *lk_rcs_id="$Id: lk.w,v 1.233 1997/12/05 21:42:32 neto Exp neto $";
d1632 1
a1632 1
mst = decluster_setup(n);
@


1.233
log
@It's Moore's curve, dodo.  :)
@
text
@d7 3
d421 1
a421 1
const char *lk_rcs_id="$Id: lk.w,v 1.232 1997/11/14 22:53:44 neto Exp neto $";
d1297 1
a1297 1
although it may be faster.  See the \module{read} module for more
d1491 1
a1491 1
The \module{resource} module is a general purpose measurement tool.  We call
d1501 1
d1919 1
a1919 1
Problem'', (INSERT REFERENCE).  The code appears in module \module{jbmr},
d1926 1
a1926 1
@@ We need the interface to module \module{jbmr}.
d2017 9
a2025 1
cleanup = lk_cleanup;
@


1.232
log
@Output starting tour if verbose is high and postscript is on.
@
text
@d7 3
d418 1
a418 1
const char *lk_rcs_id="$Id: lk.w,v 1.231 1997/10/18 18:09:11 neto Exp $";
d437 1
a437 1
#define FIXINCLUDES_NEED_TIME_STUFF
d1375 1
a1375 1
		fprintf(ps_out,"(SFC(Neto) tour, len "length_t_spec") title\n",
d1377 1
d1587 1
d1863 1
d2128 1
@


1.231
log
@Convert to new protocol for nearest neighbours.
@
text
@d7 3
d415 1
a415 1
const char *lk_rcs_id="$Id: lk.w,v 1.230 1997/10/18 14:47:50 neto Exp neto $";
d1840 1
d1842 26
d2204 2
@


1.230
log
@Now we use E2 supports() for more intelligent construction or non-construction
of 2-d trees.
@
text
@d7 4
d412 1
a412 1
const char *lk_rcs_id="$Id: lk.w,v 1.229 1997/10/17 21:48:15 neto Exp neto $";
d1644 9
a1652 3
errorif(candidate_expr != CAND_NN, "Candidate structure %d not supported",candidate_expr);
errorif(cand_nn_k < 1, "Neighbourhood must be positive, but is %d",cand_nn_k);
nn_build(cand_nn_k,NN_PURE);
d1658 3
a1660 3
@@ We need to call the setup routine.
@@<Allocate the space for this instance@@>=
nn_setup(n,cand_nn_k);
a1661 1
@@ And the cleanup routine.
@


1.229
log
@Changed coord_2d structure.
@
text
@d7 3
d408 1
a408 1
const char *lk_rcs_id="$Id: lk.w,v 1.228 1997/10/17 21:01:11 neto Exp neto $";
d1511 10
a1520 7
begin_data_structures_mark =
last_resource_mark = resource_mark("Build the 2-d tree");
errorif( tsp_instance->edge_weight_type != EUC_2D, 
	"Only EUC_2D instances allowed for now.  Sorry");
E2_create(tsp_instance);
if ( ps_out ) { E2_postscript_show(ps_out); }
@@<Test the $k$-d tree@@>@@;
@


1.228
log
@Added begin data structures mark.
@
text
@d7 3
d405 1
a405 1
const char *lk_rcs_id="$Id: lk.w,v 1.227 1997/09/27 18:06:21 neto Exp neto $";
d1438 4
a1441 4
	a[0]=XNORM(tsp_instance->coord[ai].x);
	b[0]=XNORM(tsp_instance->coord[bi].x);
	a[1]=YNORM(tsp_instance->coord[ai].y);
	b[1]=YNORM(tsp_instance->coord[bi].y);
d1573 4
a1576 4
			tsp_instance->coord[city[0]].x,
			tsp_instance->coord[city[0]].y,
			tsp_instance->coord[city[1]].x,
			tsp_instance->coord[city[1]].y);
d2081 4
a2084 4
			tsp_instance->coord[cn].x,
			tsp_instance->coord[cn].y,
			tsp_instance->coord[c].x,
			tsp_instance->coord[c].y);
@


1.227
log
@Fixed RCS log behaviour.
@
text
@d7 3
d402 1
a402 1
const char *lk_rcs_id="$Id: lk.w,v 1.226 1997/09/12 21:30:04 neto Exp neto $";
d1505 1
d1514 7
@


1.226
log
@Code wasn't included! This caused seg faults.  (This is a CWEB scripto-level
bug.  oops).
@
text
@d5 6
a10 1
{\obeylines$Log: lk.w,v $
d399 1
a399 1
const char *lk_rcs_id="$Id: lk.w,v 1.225 1997/08/15 20:18:25 neto Exp neto $";
@


1.225
log
@Added Index major section.
@
text
@d6 3
d394 1
a394 1
const char *lk_rcs_id="$Id: lk.w,v 1.224 1997/08/15 16:59:29 neto Exp neto $";
d1569 1
@


1.224
log
@Print the MST to PostScript as well.
@
text
@d6 3
d391 1
a391 1
const char *lk_rcs_id="$Id: lk.w,v 1.223 1997/08/15 16:19:19 neto Exp neto $";
d2136 2
@


1.223
log
@Added -m (--mst-edge-lengths-only) to print the edge lengths and quit
@
text
@d6 3
d388 1
a388 1
const char *lk_rcs_id="$Id: lk.w,v 1.222 1997/08/14 20:19:46 neto Exp neto $";
d1517 1
d1534 1
a1534 2
	for ( i=0;i<n-1;i++) printf("%.15f\n", (double) (mst->edge[i].cost));
printf("Total: %f\n",(double)mst_len);
d1536 19
@


1.222
log
@Added symbol BUILD DECLUSTER STRUCTURES to internal conditional compilation.
@
text
@d6 3
d385 1
a385 1
const char *lk_rcs_id="$Id: lk.w,v 1.221 1997/06/19 19:41:34 neto Exp neto $";
d548 10
a557 1
we're done.
d564 1
a564 1
However, David Johnson's runs on Euclidean nputs do not do any rounding
d647 1
d656 1
d719 1
d722 3
d738 1
a738 1
	printf("    --version               print LK version number, then exit\n");
d767 8
d1258 6
d1483 3
a1485 10
The procedure |read_tsp_instance| reads the instance and provides us
with generalized |cost| and |pseudo_cost| functions.  (The |pseudo_cost|
function is only guaranteed to be monotonic in the |cost| function,
although it may be faster.  See the \module{read} module for more
information.)

Johnson and McGeoch, and Johnson \etal.~demonstrate the performance
benefit of an adjacency structure in an implementation of the Lin-Kernighan
algorithm.  We build it now.

a1494 4
last_resource_mark = resource_mark("Build the adjacency structure");
errorif(candidate_expr != CAND_NN, "Candidate structure %d not supported",candidate_expr);
errorif(cand_nn_k < 1, "Neighbourhood must be positive, but is %d",cand_nn_k);
nn_build(cand_nn_k,NN_PURE);
a1495 3
@@ We need the interface to the nearest neighbours module.
@@<Module headers@@>=
#include "nn.h"
a1496 3
@@ We need to call the setup routine.
@@<Allocate the space for this instance@@>=
nn_setup(n,cand_nn_k);
d1498 2
a1499 4
@@ And the cleanup routine.
@@<Cleanup code@@>=
if ( verbose >=50 ) printf("Cleaning up nn structure\n");
nn_cleanup();
d1501 2
d1504 1
a1504 2
@@ Declustering needs some preprocessing as well.
@@d BUILD_DECLUSTER_STRUCTURES 
d1510 32
a1541 3
#if BUILD_DECLUSTER_STRUCTURES
last_resource_mark = resource_mark("Build a MST (decluster)");
mst_len = decluster_mst(mst);
d1548 1
a1548 1
#if BUILD_DECLUSTER_STRUCTURES
d1557 1
a1557 1
#if BUILD_DECLUSTER_STRUCTURES
d1559 1
a1559 1
#endif
a1565 1
#if BUILD_DECLUSTER_STRUCTURES
a1567 1
#endif
d1570 2
a1571 1
I haven't made this inclusion directive optional because I want dependency
d1578 24
@


1.221
log
@Be a little more friendly on initial tour length.
@
text
@d6 3
d382 1
a382 1
const char *lk_rcs_id="$Id: lk.w,v 1.220 1997/06/17 21:45:20 neto Exp neto $";
d1490 5
d1496 1
a1496 1
#if JBMR_DECLUSTER_IN_ELIGIBILITY_TEST || JBMR_DECLUSTER_IN_GREEDY
d1505 1
a1505 1
#if JBMR_DECLUSTER_IN_ELIGIBILITY_TEST || JBMR_DECLUSTER_IN_GREEDY
d1514 1
a1514 1
#if JBMR_DECLUSTER_IN_ELIGIBILITY_TEST || JBMR_DECLUSTER_IN_GREEDY
d1523 1
a1523 1
#if JBMR_DECLUSTER_IN_ELIGIBILITY_TEST || JBMR_DECLUSTER_IN_GREEDY
@


1.220
log
@Put declustering configuration info in the version banner.
@
text
@d6 3
d379 1
a379 1
const char *lk_rcs_id="$Id: lk.w,v 1.219 1997/06/17 21:32:47 neto Exp neto $";
d1190 1
a1190 1
	if ( bound_name != NULL ) printf("-b %s %g ", bound_name, bound_value);
d1699 1
a1699 1
if (verbose>=10) printf("incumbent_len == "length_t_spec"\n",length_t_pcast(incumbent_len));
@


1.219
log
@Must include declevel.h
@
text
@d6 3
d376 1
a376 1
const char *lk_rcs_id="$Id: lk.w,v 1.218 1997/06/17 20:28:42 neto Exp neto $";
d1101 2
a1102 2
in file \file{configure.in}.  This version banner conforms to 
the GNU coding standards.
d1104 5
d1111 8
a1118 1
printf("LK %s\n",VERSION_STRING);
@


1.218
log
@Added support for milestones.
Made declustering stuff conditional.
@
text
@d6 4
d373 1
a373 1
const char *lk_rcs_id="$Id: lk.w,v 1.217 1997/06/16 20:45:00 neto Exp neto $";
d1504 3
a1506 1
information to always be compiled in.
d1508 1
@


1.217
log
@I need to remember the mst space.
@
text
@d6 3
d369 1
a369 1
const char *lk_rcs_id="$Id: lk.w,v 1.216 1997/06/16 20:24:52 neto Exp neto $";
d569 16
d638 2
d649 1
a649 1
char *PostScript_filename;
d652 1
d660 1
a660 1
extern char *PostScript_filename;
d663 1
d688 1
d952 22
d1168 2
d1466 1
d1471 1
d1475 1
d1480 1
d1484 1
d1486 1
d1493 1
d1496 1
d1499 2
@


1.216
log
@A first cut at doing declustering.
@
text
@d6 3
d366 1
a366 1
const char *lk_rcs_id="$Id: lk.w,v 1.215 1997/06/16 17:35:12 neto Exp neto $";
d1432 1
a1432 1
decluster_setup(n);
@


1.215
log
@Cleaned up output (again).
@
text
@d6 3
d363 1
a363 1
const char *lk_rcs_id="$Id: lk.w,v 1.214 1997/06/16 17:20:52 neto Exp neto $";
d1354 1
a1354 1
resource_setup(10);  /* 10 is magic: it is an upper bound on the 
d1393 1
d1411 32
@


1.214
log
@Split the validation and print section.
@
text
@d6 3
d360 1
a360 1
const char *lk_rcs_id="$Id: lk.w,v 1.213 1997/06/16 16:38:10 neto Exp neto $";
d1037 2
a1038 2
	@@<Print an equivalent command line@@>@@;
	@@<Print the current time@@>@@;
d1056 1
a1056 1
"GNU General Public License, version 2 or a later version.\n"@@;
d1659 1
a1659 1
		@@<Print the current time@@>@@;
d1801 10
a1810 11
if (verbose>0 && verbose <10) {
	if ( verbose >=2 ) printf("Length: ");
	printf( noround ? "%f\n" : "%.0f\n", (double)validate_len);
} else if (verbose>=10) {
	printf( "\n\tincumbent_len       == " length_t_spec 
			"\n\tvalidate_len        == " length_t_spec 
			"\n\tdouble_validate_len == %f"
			"\n\tordered_double_len  == %f"
			"\n\traw_len             == %f\n"
			"\n\tdiscrepancy == (incumbent_len-ordered_double_len) == %f\n",
			length_t_pcast(incumbent_len), 
d1815 1
a1815 1
			my_abs(((double)incumbent_len)-ordered_double_len) );
@


1.213
log
@I removed an extraneous print line (Edit bug).
@
text
@d6 3
d357 1
a357 1
const char *lk_rcs_id="$Id: lk.w,v 1.212 1997/06/16 16:33:44 neto Exp neto $";
d408 1
d1655 4
a1658 1
	if (verbose>=10) mem_report();
a1751 5
if (verbose>=2) {
	if (verbose>=10) @@<Print the current time@@>@@;
	printf("Instance name: %s\n",tsp_instance->name);
	printf("Instance comment: %s\n",tsp_instance->comment);
}
d1756 2
a1757 2
	length_t validate_len = 0;
	double double_validate_len = 0.0, ordered_double_len=0.0, raw_len=0.0;
a1759 6
		if ( should_show_tour ) {  /* ``Are ya shure?'' */
			if ( i==0 ) printf("Tour:\n");
			printf("%d ",(original_city_num?original_city_num[c]:c)+1);	
				/* Use 1-based convention of TSPLIB, and maybe remap. */
			if ( (i % 10) == 9 || i==n-1 ) printf("\n"); 
		}
d1781 33
a1813 19
	if (verbose>0 && verbose <10) {
		if ( verbose >=2 ) printf("Length: ");
		printf( noround ? "%f\n" : "%.0f\n", (double)validate_len);
	} else if (verbose>=10) {
		printf("\nincumbent_len == " length_t_spec 
				"   validate_len == " length_t_spec 
				"\ndouble_validate_len == %f"
				"   ordered_double_len == %f\n"
				"   raw_len == %f\n",
			length_t_pcast(incumbent_len), length_t_pcast(validate_len),
			double_validate_len, ordered_double_len, raw_len );
		printf("my_abs == %f\n",
			my_abs(((double)incumbent_len)-ordered_double_len));
		printf("within epsilon == %d\n",
				within_epsilon(((double)incumbent_len),ordered_double_len));
		fflush(stdout);
	}
	errorif( !within_epsilon(((double)incumbent_len),ordered_double_len),
		"jbmr_run() lied about improvement" );
d1815 8
@


1.212
log
@Print no decimal points when no-round option is *not* used.
(i.e. the right thing)
@
text
@d6 4
d354 1
a354 1
const char *lk_rcs_id="$Id: lk.w,v 1.211 1997/06/16 16:07:26 neto Exp neto $";
a1786 1
		printf("%f\n",(double)validate_len);
@


1.211
log
@Print length in double format when verbose < 10.
@
text
@d6 3
d350 1
a350 1
const char *lk_rcs_id="$Id: lk.w,v 1.210 1997/06/13 22:12:45 neto Exp neto $";
d1041 2
a1042 1
"Copyright (C) 1997 David M. Neto\n"@@;
a1046 1
"\nLK approximately solves the traveling salesman problem.\n"@@;
d1781 2
a1782 1
	if (verbose==1)
d1784 2
a1785 3
	else if (verbose>=2 && verbose <10)
		printf("Length: %f\n",(double)validate_len);
	else if (verbose>=10) {
@


1.210
log
@Fixed a spelling mistake.
@
text
@d6 3
d347 1
a347 1
const char *lk_rcs_id="$Id: lk.w,v 1.209 1997/06/13 21:59:58 neto Exp neto $";
d1779 1
a1779 1
		printf(length_t_spec"\n",length_t_pcast(validate_len));
d1781 1
a1781 1
		printf("Length: "length_t_spec"\n",length_t_pcast(validate_len));
@


1.209
log
@Refine verbose levels for some output.
@
text
@d6 3
d344 1
a344 1
const char *lk_rcs_id="$Id: lk.w,v 1.208 1997/06/13 21:49:29 neto Exp neto $";
d801 1
a801 1
argument chosen from a fixed list.  Arguement string \type{random} has
@


1.208
log
@Make 5 the default verbose.
Some things that were printed at verbose level 2 now pushed up to 10.
@
text
@d6 4
d341 1
a341 1
const char *lk_rcs_id="$Id: lk.w,v 1.207 1997/06/13 21:39:08 neto Exp neto $";
d1113 1
d1638 1
a1638 1
	mem_report();
d1665 1
a1665 1
printf("Machine is: %s\n",buf);
d1732 3
a1734 3
if (verbose>=5) {
	@@<Print the current time@@>@@;
	printf("Instance name   : %s\n",tsp_instance->name);
d1772 1
a1772 1
	if (verbose==1) 
d1774 1
a1774 1
	else if (verbose>=2)
@


1.207
log
@Fixed comments.
Prettied up some TeX stuff.
Terminate columns of numbers in printing tour.
Make sure tour is printed if given -t option, no matter what verbose
setting is.
@
text
@d6 7
d337 1
a337 1
const char *lk_rcs_id="$Id: lk.w,v 1.206 1997/06/13 21:16:06 neto Exp neto $";
d432 1
a432 1
used at all, then a default value of 2 is used.
d575 1
a575 1
@@d DEFAULT_VERBOSE 2
d652 1
a652 1
	printf(" -v --verbose [n]           set verbose level (default is 2, n default is 100)\n");
d988 1
a988 1
if ( verbose>=2 ) {
d1050 1
a1050 1
if ( verbose>=2 ) {
d1552 1
a1552 1
if (verbose>=2) printf("incumbent_len == "length_t_spec"\n",length_t_pcast(incumbent_len));
d1727 1
a1727 1
if (verbose>=2) {
d1769 3
a1771 1
	else if (verbose>=2) {
@


1.206
log
@Fixed comment about main.
put starting braces of functions in column 1.
Updated a section name to reflect reality (report results in only
one place).
@
text
@d6 6
d330 1
a330 1
const char *lk_rcs_id="$Id: lk.w,v 1.205 1997/06/13 21:01:59 neto Exp neto $";
d497 2
a498 1
$$\hbox{\it cost}(u,v) = \lfloor 0.5 + \sqrt{(u_x-v_x)^2+(u_y-v_y)^2} \rfloor.$$
d503 1
a503 1
$$\hbox{\it cost}(u,v) = \lfloor 0.5 + \sqrt{(u_x-v_x)^2+(u_y-v_y)^2} \rfloor.$$
d993 1
a993 1
	#if defined(OS_HAS_BROKEN_HEADERS)
d995 1
a995 1
	#endif
d1020 7
a1026 7
printf(
"Copyright (C) 1997 David M. Neto\n"
"LK comes with NO WARRANTY, to the extent permitted by law.\n"
"You may redistribute and/or modify copies of LK under the terms of the\n"
"GNU General Public License, version 2 or a later version.\n"
"For more information about these matters, see the file named COPYING.\n"
"\nLK approximately solves the traveling salesman problem.\n"
d1229 1
a1229 1
Bartholdi \& Platzman used a different curve in relation to the TSP, 
d1585 5
a1589 1
This is a local search algorithm.
d1595 1
a1595 2
@@ We need the interface to my implementation of the Johnson, Bentley,
McGeoch, and Rothberg.
d1600 1
a1600 1
@@ We need to call their setup and cleanup procedures.
a1638 5
#if 0 /* On May 16, 1997, I didn't end up needing this anymore! */
#if defined(__linux__)
	int gethostname(char *name, size_t len);
#endif
#endif
d1645 1
d1649 1
a1649 1
#endif
d1655 1
d1711 5
d1733 2
a1734 2
		if ( should_show_tour && verbose >= 100 ) {
			if ( i==0 ) printf("Tour: \n");
d1737 1
a1737 1
			if ( (i % 10) == 9 ) printf("\n");
@


1.205
log
@Fixed a variable name
@
text
@d6 3
d324 1
a324 1
const char *lk_rcs_id="$Id: lk.w,v 1.204 1997/06/13 20:59:29 neto Exp neto $";
d364 3
a366 12
The program does the following things, in sequence.

First, it parses its command line to determine which TSP instance to process,
and what options have been specified.

Second, it reads the given TSP instance, and allocates the memory space
required for the execution of the Lin-Kernighan algorithm.

Third, it builds the requisite data structures (nearest neighbour lists
and tour representation data type instance).

Fourth, it constructs a starting tour.
d368 2
a369 2
Fifth, it runs the Lin-Kernighan algorithm on the current tour, until
no more improvements can be made.
a370 3
Sixth, it stops the timers, and reports the elapsed time and gives the
resulting tour.

d373 2
a374 1
main(int argc, char **argv) {
d384 1
a384 1
	@@<Stop the timers and report the results@@>@@;
d723 2
a724 1
is_number(char *p) {
d1254 2
a1255 1
cmp_sfc_Moore(const void *voida, const void *voidb) {
d1605 1
a1605 1
@@<Stop the timers and report the results@@>=
d1661 2
a1662 1
static void lk_cleanup(void) {
d1746 1
a1746 1
	mem_deduct(n*(sizeof(double)+sizeof(double)+sizeof(length_t));
@


1.204
log
@Make verbose==1 output only the length of the tour.
Make verbose==2 the default, and it's quite quiet.
@
text
@d6 4
d321 1
a321 1
const char *lk_rcs_id="$Id: lk.w,v 1.203 1997/06/13 20:32:09 neto Exp neto $";
d1750 1
a1750 1
	free_mem(length_t_len);
@


1.203
log
@Don't print starting incumbent len if verbose==0
@
text
@d6 3
d317 1
a317 1
const char *lk_rcs_id="$Id: lk.w,v 1.202 1997/06/13 20:28:08 neto Exp neto $";
d423 1
a423 1
used at all, then a default value of 1 is used.
d565 1
a565 1
@@d DEFAULT_VERBOSE 1
d642 1
a642 1
	printf(" -v --verbose [n]           set verbose level (default is 1, n default is 100)\n");
d977 1
a977 1
if ( verbose ) {
d1039 1
a1039 1
if ( verbose ) {
d1540 1
a1540 1
if (verbose) printf("incumbent_len == "length_t_spec"\n",length_t_pcast(incumbent_len));
d1609 6
a1614 4
{ int i;
	for (i=0;i<last_resource_mark;i++) {
		resource_report(stdout,i,i+1);
	}
d1618 2
a1620 2
mem_report();
@@<Print the machine name@@>@@;
d1709 1
a1709 1
if (verbose) {
d1717 1
d1729 3
a1731 3
		double_validate_len += (double)cost(c,cn);
		validate_len += cost(c,cn);
		lengths[i]=(double)cost(c,cn);
d1736 3
a1738 2
	qsort(lengths,(unsigned)n,sizeof(double),double_cmp);
	qsort(raw_lengths,(unsigned)n,sizeof(double),double_cmp);
d1742 1
d1744 1
a1744 1
	free_mem(lengths);
d1746 2
d1749 3
a1751 1
	if (verbose) {
d1797 10
@


1.202
log
@Removed flushes of stdout after resource mark calls.
Made checking kd tree quieter if verbose==0
@
text
@d6 4
d314 1
a314 1
const char *lk_rcs_id="$Id: lk.w,v 1.201 1997/06/13 20:16:23 neto Exp neto $";
d1537 1
a1537 1
printf("incumbent_len == "length_t_spec"\n",length_t_pcast(incumbent_len));
@


1.201
log
@Sorted, minor editing on help text.
Made it really quiet when verbose==0.
@
text
@d6 4
d310 1
a310 1
const char *lk_rcs_id="$Id: lk.w,v 1.200 1997/06/13 19:49:27 neto Exp neto $";
d1111 1
a1111 1
last_resource_mark = resource_mark("Reading the instance");fflush(stdout);
d1340 1
a1340 1
last_resource_mark = resource_mark("Build the 2-d tree");fflush(stdout);
d1346 1
a1346 1
last_resource_mark = resource_mark("Build the adjacency structure");fflush(stdout);
d1530 1
a1530 1
last_resource_mark = resource_mark("Construct starting tour");fflush(stdout);
d1576 1
a1576 1
last_resource_mark = resource_mark("Lin-Kernighan");fflush(stdout);
d1601 1
a1601 1
last_resource_mark = resource_mark("The end");fflush(stdout);
d1792 1
a1792 1
printf("%d ",c); fflush(stdout);
d1829 1
a1829 1
printf("\nkd tree passed an integrity test on nearest-neighbour searching\n");
@


1.200
log
@Made it a little quiter.
@
text
@d6 3
d306 1
a306 1
const char *lk_rcs_id="$Id: lk.w,v 1.199 1997/06/13 18:44:11 neto Exp neto $";
d404 2
a405 1
Option \type{-V} or \type{--version} prints out version information.
d481 1
a481 1
Option \type{--noround} tells us to avoid rounding computed distances.  
d617 1
a617 1
	printf(" -h --help                  give this help and quit\n");
d619 2
a620 1
	printf(" --noround                  Do not round Euclidean distance computations\n");
d624 1
a624 1
	printf("      <rep> ::= array | two-level | tld | splay\n");
d627 1
d632 1
a632 4
	printf(" -V --version               print version\n");
	printf("\n");
	printf("    --sfc                   reorder cities by a space-filling-curve\n");
	printf("    --maxdepth [d]          limit probe depth to d cities\n");
d648 1
a648 1
if ( strcmp(argv[r],"--noround")==0 ) {
d665 1
a665 1
if ( strcmp(argv[r],"-V")==0 || strcmp(argv[r],"--version")==0 ) {
d667 2
d1011 1
a1011 1
"\nLK approximately solves the traveling salesman problem\n"
d1031 1
a1031 1
	if ( should_show_version ) printf("-V ");
d1033 1
a1033 1
	if ( noround ) printf("--noround ");
d1696 5
a1700 3
@@<Print the current time@@>@@;
printf("Instance name   : %s\n",tsp_instance->name);
printf("Instance comment: %s\n",tsp_instance->comment);
d1731 14
a1744 12
	printf("\nincumbent_len == " length_t_spec 
			"   validate_len == " length_t_spec 
			"\ndouble_validate_len == %f"
			"   ordered_double_len == %f\n"
			"   raw_len == %f\n",
		length_t_pcast(incumbent_len), length_t_pcast(validate_len),
		double_validate_len, ordered_double_len, raw_len );
	printf("my_abs == %f\n",
		my_abs(((double)incumbent_len)-ordered_double_len));
	printf("within epsilon == %d\n",
			within_epsilon(((double)incumbent_len),ordered_double_len));
	fflush(stdout);
@


1.199
log
@Fixed up the parens matching hack (for editors).
@
text
@d6 3
d303 1
a303 1
const char *lk_rcs_id="$Id: lk.w,v 1.198 1997/06/13 18:17:30 neto Exp neto $";
d625 1
a625 1
	printf(" -v --verbose [n]           set verbose level (default is 0, n default is 100)\n");
d963 23
a985 21
	printf("LK, a program for approximately solving the traveling salesman problem\n");
	/* printf("Copyright 1997, David Michael Neto"); */
	printf("%s\n",compile_compile);
	printf("%s\n",compile_link);
	printf("%s\n",array_rcs_id);
	printf("%s\n",construct_rcs_id);
	printf("%s\n",dict_rcs_id);
	printf("%s\n",dsort_rcs_id);
	printf("%s\n",error_rcs_id);
#if defined(OS_HAS_BROKEN_HEADERS)
	printf("%s\n",fixincludes_rcs_id);
#endif
	printf("%s\n",jbmr_rcs_id);
	printf("%s\n",kdtree_rcs_id);
	printf("%s\n",length_rcs_id);
	printf("%s\n",lk_rcs_id);
	printf("%s\n",memory_rcs_id);
	printf("%s\n",nn_rcs_id);
	printf("%s\n",pool_rcs_id);
	printf("%s\n",read_rcs_id);
	printf("%s\n",resource_rcs_id);
d990 20
d1102 1
d1259 1
a1259 1
@@q outside of strings.  I've still used @@q"("@@> here in case you're using@@>
a1299 1
last_resource_mark = resource_mark("The very beginning");fflush(stdout);
@


1.198
log
@It's not Neto's curve, it's Moore's curve.
I've moved the origin to 6 o'clock instead of at the origin.  This
may help cache behaviour.
(Because the 0/1 boundary is at the edge of the square instead of
right in the middle.).
@
text
@d6 7
d300 1
a300 1
const char *lk_rcs_id="$Id: lk.w,v 1.197 1997/05/16 21:15:06 neto Exp neto $";
d1232 7
a1238 4
	errorif(a[0]<0 || a[0]>=1,"cmp_sfc_Moore: a[0] out of range"/*(*/" [0,1): %f",a[0]);
	errorif(a[1]<0 || a[1]>=1,"cmp_sfc_Moore: a[1] out of range"/*(*/" [0,1): %f",a[1]);
	errorif(b[0]<0 || b[0]>=1,"cmp_sfc_Moore: b[0] out of range"/*(*/" [0,1): %f",b[0]);
	errorif(b[1]<0 || b[1]>=1,"cmp_sfc_Moore: b[1] out of range"/*(*/" [0,1): %f",b[1]);
@


1.197
log
@Now I don't need special behaviour for Linux regarding getpagesize.
@
text
@d6 3
d293 1
a293 1
const char *lk_rcs_id="$Id: lk.w,v 1.196 1997/05/16 21:13:33 neto Exp neto $";
d1133 1
a1133 1
	sort(original_city_num,(size_t)n,sizeof(int),cmp_sfc_neto);
d1175 1
a1175 1
curve.  As far as I know, this curve is original to me, David Neto.  
d1182 7
d1206 1
a1206 1
int cmp_sfc_neto(const void *voida, const void *voidb);
d1208 1
a1208 1
cmp_sfc_neto(const void *voida, const void *voidb) {
d1215 1
a1215 1
		 {0,1,3,2},{2,3,1,0},{2,1,3,0},{2,1,3,0},{2,1,3,0}};
d1225 4
a1228 4
	errorif(a[0]<0 || a[0]>=1,"cmp_sfc_neto: a[0] out of range"/*(*/" [0,1): %f",a[0]);
	errorif(a[1]<0 || a[1]>=1,"cmp_sfc_neto: a[1] out of range"/*(*/" [0,1): %f",a[1]);
	errorif(b[0]<0 || b[0]>=1,"cmp_sfc_neto: b[0] out of range"/*(*/" [0,1): %f",b[0]);
	errorif(b[1]<0 || b[1]>=1,"cmp_sfc_neto: b[1] out of range"/*(*/" [0,1): %f",b[1]);
@


1.196
log
@Now I don't need special behaviour for Linux regarding gethostname.
@
text
@d6 3
d290 1
a290 1
const char *lk_rcs_id="$Id: lk.w,v 1.195 1997/05/16 20:37:20 neto Exp neto $";
@


1.195
log
@Put in some support from configure.
@
text
@d6 3
d287 1
a287 1
const char *lk_rcs_id="$Id: lk.w,v 1.194 1997/05/16 18:11:41 neto Exp neto $";
d1565 1
d1568 1
@


1.194
log
@Break locks by david and neto.
Include <config.h> and "lkconfig.h"
@
text
@d6 4
d284 1
a284 1
const char *lk_rcs_id="$Id: lk.w,v 1.193 1997/05/16 18:09:40 neto Exp neto $";
d296 1
a296 1
#if defined(FIX_INCLUDES)
d953 1
a953 1
#if defined(FIX_INCLUDES)
d1037 3
a1039 1
{ time_t now = time(NULL);
d1041 1
d1046 1
d1048 1
d1556 1
d1558 2
d1561 1
@


1.193
log
@Include <config.h> and lkconfig.h
@
text
@d6 3
d280 1
a280 1
const char *lk_rcs_id="$Id: lk.w,v 1.192 1997/02/11 16:08:50 neto Exp neto $";
@


1.192
log
@Fixed parsing of start tour.
@
text
@d6 3
d261 1
a261 1
you should also read the implementation report by Johnson, Bently, McGeoch
d266 2
d277 1
a277 1
const char *lk_rcs_id="$Id: lk.w,v 1.191 1997/02/10 19:32:36 neto Exp neto $";
d936 1
a936 1
	extern char *compile; /* Compiler options */
d938 3
a940 2
	/* printf("Copyright 1996, David Michael Neto"); */
	printf("%s\n",compile);
@


1.191
log
@Added a grestore to close out postscript .
@
text
@d5 4
a8 1
{\obeylines$Log:	lk.w,v $
d272 1
a272 1
const char *lk_rcs_id="$Id: lk.w,v 1.190 97/01/27 16:43:48 neto Exp Locker: neto $";
d748 1
a748 1
	if ( strcmp(argv[r],"canonical")==0 ) start_tour = CONSTRUCT_CANONICAL;
@


1.190
log
@Made lk cleanup prototype and definition match in storage class modifier.
@
text
@d6 3
d269 1
a269 1
const char *lk_rcs_id="$Id: lk.w,v 1.189 97/01/27 16:41:02 neto Exp Locker: neto $";
d1679 1
a1679 1
	fprintf(ps_out,"end\n%%EOF\n");fclose(ps_out);
@


1.189
log
@Better output of intermediate PostScript.
@
text
@d5 4
a8 1
{\obeylines$Log: lk.w,v $
d266 1
a266 1
const char *lk_rcs_id="$Id: lk.w,v 1.188 1997/01/21 22:30:17 david Exp david $";
d1563 2
a1564 2
@@<Subroutines@@>=
void lk_cleanup(void) {
@


1.188
log
@Fixed an errorif call.
@
text
@d6 3
d263 1
a263 1
const char *lk_rcs_id="$Id: lk.w,v 1.187 1997/01/21 21:55:55 david Exp david $";
d1109 3
d1121 2
d1660 3
d1672 2
a1673 1
	fprintf(ps_out,"end showpage\n%%EOF\n");fclose(ps_out);
@


1.187
log
@Added standard copyright notice by including copyrt.w
@
text
@d6 3
d260 1
a260 1
const char *lk_rcs_id="$Id: lk.w,v 1.186 1997/01/21 17:48:24 david Exp david $";
d698 2
a699 1
	error(1,"Option --maxdepth requires JBMR_LIMIT_PROBE_DEPTH compilation flag.\n");
@


1.186
log
@Output the tour to the PostScript output stream, if open.
@
text
@d1 1
d6 3
d257 1
a257 1
const char *lk_rcs_id="$Id: lk.w,v 1.184 1997/01/21 17:23:46 david Exp david $";
@


1.185
log
@Really fixed it.  Oops.
@
text
@a1508 1
if ( ps_out ) {fprintf(ps_out,"end showpage\n%%EOF\n");fclose(ps_out);}
d1638 16
@


1.184
log
@Fixed printing out of start tour option, w.r.t. canonical.
@
text
@d5 3
d253 1
a253 1
const char *lk_rcs_id="$Id: lk.w,v 1.183 1997/01/21 16:33:44 david Exp david $";
d958 1
@


1.183
log
@Added canonical back again.
Fixed error messages about sorting options.
@
text
@d5 4
d250 1
a250 1
const char *lk_rcs_id="$Id: lk.w,v 1.182 1997/01/21 16:22:34 david Exp david $";
@


1.182
log
@Make printing of SFC results optional.
@
text
@d5 3
d246 1
a246 1
const char *lk_rcs_id="$Id: lk.w,v 1.180 1997/01/21 16:10:23 david Exp david $";
d397 1
a397 1
%\type{canonical} (tour $1,2,3,\ldots,n$), 
d402 3
d715 1
a715 1
		fprintf(stderr, "Need one of {greedy,random [seed]}\n");
d721 1
d727 1
a727 1
		fprintf(stderr, "Need one of {ai,canonical,greedy,random [seed],best}\n");
d739 1
a739 1
		fprintf(stderr, "Need one of {greedy,random [seed]}\n");
d749 1
a749 1
		fprintf(stderr, "Need one of {ai,canonical,greedy,random [seed],best}\n");
@


1.181
log
@Fixed a parse error.
@
text
@d1081 1
d1093 1
@


1.180
log
@Fixed ordering and normalization in SFC comparison function.
@
text
@d5 3
d243 1
a243 1
const char *lk_rcs_id="$Id: lk.w,v 1.179 1997/01/21 15:37:41 david Exp david $";
d1121 1
a1121 1
@@d XNORM(V) tsp_instance->xmax==tsp_instance->xmin ? 0.0 : 
d1123 1
a1123 1
@@d YNORM(V) tsp_instance->ymax==tsp_instance->ymin ? 0.0 :
@


1.179
log
@Fixed the rewrite rule and the comparison rule for SFC when a and
b compare as different.
@
text
@d5 4
d240 1
a240 1
const char *lk_rcs_id="$Id: lk.w,v 1.177 1997/01/21 00:18:10 david Exp david $";
d1119 1
a1119 1
	((tsp_instance->xmax-(V))/(tsp_instance->xmax-tsp_instance->xmin)/(1+10*DBL_EPSILON));
d1121 1
a1121 1
	((tsp_instance->ymax-(V))/(tsp_instance->ymax-tsp_instance->ymin)/(1+10*DBL_EPSILON));
d1154 1
a1154 1
		if ( aq != bq ) return order[lastq][bq]-order[lastq][aq];
@


1.178
log
@Second try at sfc sorter.
@
text
@d1132 2
a1133 2
		 {0,1,3,2},{2,3,1,0},{2,1,3,0},{2,1,3,0},{7,10,2,0}};
	int rewrite[12][4] = 
d1136 1
a1136 1
		 {2,1,7,6},{9,4,5,10},{7,10,6, 3},{7,10,6,5}};
@


1.177
log
@Fail if --maxdepth option given without proper compilation flag.
@
text
@d5 3
d236 1
a236 1
const char *lk_rcs_id="$Id: lk.w,v 1.176 1997/01/20 23:49:31 david Exp david $";
d1105 1
a1125 1
	int c=0, lastbit=1;
d1128 9
a1136 1
	int av,bv;
d1142 4
a1145 4
errorif(a[0]<0 || a[0]>=1,"cmp_sfc_neto: a[0] out of range"/*(*/" [0,1): %f",a[0]);
errorif(a[1]<0 || a[1]>=1,"cmp_sfc_neto: a[1] out of range"/*(*/" [0,1): %f",a[1]);
errorif(b[0]<0 || b[0]>=1,"cmp_sfc_neto: b[0] out of range"/*(*/" [0,1): %f",b[0]);
errorif(b[1]<0 || b[1]>=1,"cmp_sfc_neto: b[1] out of range"/*(*/" [0,1): %f",b[1]);
d1148 6
a1153 9
		av = a[c&1] >= 0.5; bv = b[c&1] >= 0.5;
		if ( av != bv ) {
			if (lastbit ^ (c&1)) return av-bv; /* Forward comparison. */
			else return bv-av;	/* Reverse comparison. */
		}
		lastbit = av;
		a[c&1] = (2*a[c&1])-av;
		b[c&1] = (2*b[c&1])-bv;
		c++;
@


1.176
log
@Changed max\_probe\_depth to max\_generic\_flips
@
text
@d5 3
d233 1
a233 1
const char *lk_rcs_id="$Id: lk.w,v 1.175 1997/01/20 19:50:46 david Exp david $";
d667 3
@


1.175
log
@Fixed setting probe depth.
@
text
@d5 3
d230 1
a230 1
const char *lk_rcs_id="$Id: lk.w,v 1.174 1997/01/20 19:45:56 david Exp david $";
d421 3
a423 1
It asks us to limit the probe depth to at most $d$ cities.
d425 1
a425 1
by specifiying that probes should stop at 50 or 100 cities.  
d659 1
a659 1
goes into |max_probe_depth|.  
d664 2
a665 2
	max_probe_depth = 50;
	if ( r+1<argc && is_number(argv[r+1]) ) max_probe_depth = atoi(argv[++r]);
d671 5
a675 1
int max_probe_depth;
d680 1
a680 1
max_probe_depth=INT_MAX;
d958 1
a958 1
	if ( max_probe_depth != INT_MAX ) printf("--maxdepth %d ", max_probe_depth);
@


1.174
log
@Fixed limit.h to limits.h
@
text
@d5 3
d227 1
a227 1
const char *lk_rcs_id="$Id: lk.w,v 1.173 1997/01/20 19:44:31 david Exp david $";
d660 1
a660 1
	if ( r+1<argc && is_number(argv[r+1]) ) verbose = atoi(argv[++r]);
@


1.173
log
@Added a maxdepth option.
@
text
@d5 3
d224 1
a224 1
const char *lk_rcs_id="$Id: lk.w,v 1.172 1997/01/17 22:11:41 neto Exp $";
d672 1
a672 1
#include <limit.h>
@


1.172
log
@Modifying sfc comparison function.  Still buggy.
Need to use both bits at the same time (x and y) and use table
lookup.
Added printing of labels to the postscript debugging output.
@
text
@d5 6
d221 1
a221 1
const char *lk_rcs_id="$Id: lk.w,v 1.170 1997/01/17 19:43:19 neto Exp $";
d411 13
d542 1
d647 24
d942 2
@


1.171
log
@Print debugging postscript out in case of space filling curve.
@
text
@d1008 2
d1011 1
d1044 1
a1044 1
	((tsp_instance->xmax-(V))/(tsp_instance->xmax-tsp_instance->xmin)/(1+DBL_EPSILON));
d1046 1
a1046 1
	((tsp_instance->ymax-(V))/(tsp_instance->ymax-tsp_instance->ymin)/(1+DBL_EPSILON));
d1055 1
a1055 1
	int c=0;
d1057 2
a1058 1
	double a[2],b[2], av, bv, twicea,twiceb, fraca, fracb;
d1064 4
d1070 4
a1073 8
		twicea = 2*a[c&1]; @@+twiceb = 2*b[c&1];
		fraca = fmod(twicea,(double)1.0);@@+ while (fraca<0) fraca+=1;
		fracb = fmod(twiceb,(double)1.0);@@+ while (fracb<0) fracb+=1;
		av = twicea-fraca;
		bv = twiceb-fracb;
		if ( av!= bv ) {
			if (c&2) return sgn(bv-av);
			else return sgn(av-bv);
d1075 3
a1077 2
		a[c&1] = fraca;
		b[c&1] = fracb;
@


1.170
log
@MAXHOSTNAMELEN not defined under Solaris.
@
text
@d5 3
d215 1
a215 1
const char *lk_rcs_id="$Id: lk.w,v 1.169 1997/01/16 22:19:02 neto Exp $";
d1004 8
d1404 1
a1404 9
{
#if !defined(MAXHOSTNAMELEN)  /* Not defined under Solaris for some reason. */
#define MAXHOSTNAMELEN 50
#endif
char buf[MAXHOSTNAMELEN+1];
gethostname(buf,MAXHOSTNAMELEN);
buf[MAXHOSTNAMELEN]=0;
printf("Machine is: %s\n",buf);
}
d1407 1
d1415 16
@


1.169
log
@Print the wall clock time afterward too.
@
text
@d4 4
a7 1
{\obeylines$Log:	lk.w,v $
d212 1
a212 1
const char *lk_rcs_id="$Id: lk.w,v 1.168 97/01/16 14:20:22 neto Exp $";
d1393 5
a1397 1
{char buf[MAXHOSTNAMELEN+1];
@


1.168
log
@Added space filling curve code.
@
text
@d5 3
d209 1
a209 1
const char *lk_rcs_id="$Id: lk.w,v 1.167 96/12/16 16:56:30 neto Exp $";
d1461 1
@


1.167
log
@Now it passes gcc with lots of warnings turned on.
@
text
@d5 3
d206 1
a206 1
const char *lk_rcs_id="$Id: lk.w,v 1.166 96/12/13 15:14:03 neto Exp Locker: neto $";
d272 1
d306 1
d389 6
d396 1
d512 2
d542 2
d552 21
d887 3
d966 100
d1467 1
a1467 1
		if ( verbose >= 100 ) {
d1469 2
a1470 1
			printf("%d ",c+1);	/* Use 1-based convention of TSPLIB */
@


1.166
log
@Fixed a parameter mistake in printing.
@
text
@d5 3
d203 1
a203 1
const char *lk_rcs_id="$Id: lk.w,v 1.165 96/12/13 15:08:50 neto Exp $";
d218 1
d222 1
d1340 2
a1341 2
	qsort(lengths,n,sizeof(double),double_cmp);
	qsort(raw_lengths,n,sizeof(double),double_cmp);
d1368 1
d1372 1
a1372 1
	double da=*((double*)a), db=*((double*)b);
@


1.165
log
@Fixed typo on variable name.
@
text
@d5 3
d200 1
a200 1
const char *lk_rcs_id="$Id: lk.w,v 1.164 96/12/13 14:49:28 neto Exp $";
d1347 1
a1347 1
			"   ordered_double_len == %f\n",
@


1.164
log
@Added raw length computation.
@
text
@d5 3
d197 1
a197 1
const char *lk_rcs_id="$Id: lk.w,v 1.163 96/12/12 14:01:35 neto Exp Locker: neto $";
d1345 1
a1345 1
			"   raw_length == %f\n",
d1347 1
a1347 1
		double_validate_len, ordered_double_len, raw_length );
@


1.163
log
@Fixed a CWEB typo.
@
text
@d5 3
d194 1
a194 1
const char *lk_rcs_id="$Id: lk.w,v 1.162 96/12/12 14:01:09 neto Exp $";
d1311 1
d1313 1
a1313 1
	double double_validate_len = 0.0, ordered_double_len=0.0;
d1325 2
d1330 5
a1334 1
	for (i=0;i<n;i++) ordered_double_len += lengths[i];
d1336 1
d1342 1
d1344 1
a1344 1
		double_validate_len, ordered_double_len );
@


1.162
log
@Print the current time, too.
@
text
@d5 3
d191 1
a191 1
const char *lk_rcs_id="$Id: lk.w,v 1.161 96/12/05 16:13:54 neto Exp $";
d848 1
a848 1
@@<Print the current time@@>@@=
@


1.161
log
@Free the lengths array.
@
text
@d5 3
d188 1
a188 1
const char *lk_rcs_id="$Id: lk.w,v 1.160 96/12/05 16:00:59 neto Exp $";
d781 1
d840 13
@


1.160
log
@Fixed printf.
@
text
@d5 3
d185 1
a185 1
const char *lk_rcs_id="$Id: lk.w,v 1.159 96/12/05 15:57:08 neto Exp $";
d1305 1
@


1.159
log
@Fixed prototype for double\_cmp, and made it a module subroutine so that
it would be defined before used.
@
text
@d5 4
d182 1
a182 1
const char *lk_rcs_id="$Id: lk.w,v 1.158 96/12/05 15:55:57 neto Exp $";
d1305 1
a1305 1
			"\ndouble_validate_len == %f\n",
@


1.158
log
@Add the lengths in smallest-to-largest order.   This is the best
numerically-wise.
@
text
@d5 4
d178 1
a178 1
const char *lk_rcs_id="$Id: lk.w,v 1.157 96/12/05 15:35:46 neto Exp $";
d1316 3
a1318 3
@@<Subroutines@@>=
double
double_cmp(void *a, void *b)
@


1.157
log
@Seem to have fixed the validation routine.
@
text
@d5 3
d174 1
a174 1
const char *lk_rcs_id="$Id: lk.w,v 1.156 96/12/05 15:29:19 neto Exp $";
d1276 1
d1278 1
a1278 1
	double double_validate_len = 0.0;
d1289 1
d1292 2
d1297 2
a1298 1
			"   double_validate_len == %f\n",
d1300 1
a1300 1
		double_validate_len );
d1302 1
a1302 1
		my_abs(((double)incumbent_len)-double_validate_len));
d1304 1
a1304 1
			within_epsilon(((double)incumbent_len),double_validate_len));
d1306 1
a1306 1
	errorif( !within_epsilon(((double)incumbent_len),double_validate_len),
d1308 12
@


1.156
log
@Dumb dumb dubm.  +=
@
text
@d5 3
d171 1
a171 1
const char *lk_rcs_id="$Id: lk.w,v 1.155 96/12/05 15:27:51 neto Exp $";
d1290 1
a1290 1
			"   double_validate_len == %lf\n",
@


1.155
log
@Need more casts.
.l
@
text
@d5 4
d168 1
a168 1
const char *lk_rcs_id="$Id: lk.w,v 1.154 96/12/05 15:25:37 neto Exp $";
d1271 1
a1271 1
	double double_validate_len = 0;
d1280 1
a1280 1
		double_validate_len = (double)cost(c,cn);
@


1.154
log
@Need to cast the cost function to double.
@
text
@d5 3
d164 1
a164 1
const char *lk_rcs_id="$Id: lk.w,v 1.153 96/12/05 15:00:38 neto Exp $";
d1286 2
a1287 1
	printf("my_abs == %f\n",my_abs(incumbent_len-double_validate_len));
d1289 1
a1289 1
			within_epsilon(incumbent_len,double_validate_len));
d1291 1
a1291 1
	errorif( !within_epsilon(incumbent_len,double_validate_len),
@


1.153
log
@Changed validation to use compute both a length\_t validation variable
and a double-valued validation variable.  For now, use the double-valued
one to do the check.
@
text
@d5 5
d161 1
a161 1
const char *lk_rcs_id="$Id: lk.w,v 1.152 96/12/05 14:54:59 neto Exp Locker: neto $";
d1273 1
a1273 1
		double_validate_len = cost(c,cn);
@


1.152
log
@Added name and comment to output.
@
text
@d5 3
d156 1
a156 1
const char *lk_rcs_id="$Id: lk.w,v 1.151 96/12/05 14:41:05 neto Exp $";
d1259 1
d1268 1
d1274 9
a1282 5
			"     validate_len == " length_t_spec "\n",
		length_t_pcast(incumbent_len), length_t_pcast(validate_len) );
	printf("my_abs == %f\n",my_abs(incumbent_len-validate_len));
	printf("within epsilon == %d\n",within_epsilon(incumbent_len,validate_len));
	errorif( !within_epsilon(incumbent_len,validate_len),
@


1.151
log
@Added option --noround
@
text
@d5 3
d153 1
a153 1
const char *lk_rcs_id="$Id: lk.w,v 1.150 96/11/08 15:49:55 neto Exp Locker: neto $";
d1252 2
@


1.150
log
@Added some length\_t\_pcast in places.
@
text
@d5 3
d150 1
a150 1
const char *lk_rcs_id="$Id: lk.w,v 1.149 96/09/19 15:41:47 neto Exp $";
d317 13
d383 1
d393 1
d403 1
d433 1
d457 8
d763 1
d1238 4
a1241 1
by as much as it says it did.  
d1245 3
d1266 4
a1269 1
	errorif( incumbent_len != validate_len, "jbmr_run() lied about improvement" );
@


1.149
log
@Added string.h to header list.
Removed assert.h
@
text
@d5 4
d147 1
a147 1
const char *lk_rcs_id="$Id: lk.w,v 1.148 96/09/18 17:16:52 neto Exp Locker: neto $";
d1071 1
a1071 1
printf("incumbent_len == "length_t_spec"\n",incumbent_len);
d1230 1
a1230 1
		incumbent_len, validate_len );
d1254 2
a1255 2
				c,i-1,last,last_dist,
				i,d,next_dist);
@


1.148
log
@Better name for upper limit on resource marks: last\_resource\_mark.
Also, report a summary from the very beginning to the very end.
@
text
@d5 4
d143 1
a143 1
const char *lk_rcs_id="$Id: lk.w,v 1.147 96/09/18 16:42:38 neto Exp $";
d153 1
a153 1
#include <assert.h>
@


1.147
log
@Fixed calling problem with resource\_report.  Duh.
@
text
@d5 3
d139 1
a139 1
const char *lk_rcs_id="$Id: lk.w,v 1.146 96/09/18 16:39:49 neto Exp Locker: neto $";
d838 1
a838 1
number_of_resource_marks = resource_mark("The very beginning");fflush(stdout);
d844 1
a844 1
@@ We also need to declare |number_of_resource_marks|, which counts
d849 1
a849 1
static int number_of_resource_marks;
d870 1
a870 1
number_of_resource_marks = resource_mark("Build the 2-d tree");fflush(stdout);
d876 1
a876 1
number_of_resource_marks = resource_mark("Build the adjacency structure");fflush(stdout);
d1060 1
a1060 1
number_of_resource_marks = resource_mark("Construct starting tour");fflush(stdout);
d1106 1
a1106 1
number_of_resource_marks = resource_mark("Lin-Kernighan");fflush(stdout);
d1131 1
a1131 1
number_of_resource_marks = resource_mark("The end");fflush(stdout);
d1133 1
a1133 1
	for (i=0;i<number_of_resource_marks;i++) {
d1135 3
@


1.146
log
@Be a little more intelligent about reporting resource statistics.
@
text
@d5 3
d136 1
a136 1
const char *lk_rcs_id="$Id: lk.w,v 1.145 96/09/18 16:22:10 neto Exp $";
d1131 1
a1131 1
		resource_report(i,i+1);
@


1.145
log
@Added a resource mark at the very beginning of the run, to capture
memory usage of the read routine.
@
text
@d5 4
d133 1
a133 1
const char *lk_rcs_id="$Id: lk.w,v 1.144 96/09/17 14:28:52 neto Exp Locker: neto $";
d832 1
a832 1
resource_mark("The very beginning");fflush(stdout);
d838 7
d864 1
a864 1
resource_mark("Build the 2-d tree");fflush(stdout);
d870 1
a870 1
resource_mark("Build the adjacency structure");fflush(stdout);
d1054 1
a1054 1
resource_mark("Construct starting tour");fflush(stdout);
d1100 1
a1100 1
resource_mark("Lin-Kernighan");fflush(stdout);
d1125 6
a1130 5
resource_mark("The end");fflush(stdout);
resource_report(stdout,0,1);
resource_report(stdout,1,2);
resource_report(stdout,2,3);
resource_report(stdout,3,4);
@


1.144
log
@More feedback about shutdown sequence.  It seems to take a while.
@
text
@d5 3
d129 1
a129 1
const char *lk_rcs_id="$Id: lk.w,v 1.143 96/09/17 14:07:18 neto Exp Locker: neto $";
d828 1
@


1.143
log
@Added conditional compilation if structure around a use of 
a twolevel debugging name.
@
text
@d5 4
d126 1
a126 1
const char *lk_rcs_id="$Id: lk.w,v 1.142 96/09/12 14:15:07 neto Exp $";
d870 1
d1031 1
d1063 1
d1100 1
@


1.142
log
@Fixed an unterminated preprocessor else.
@
text
@d5 3
d122 1
a122 1
const char *lk_rcs_id="$Id: lk.w,v 1.141 96/09/12 14:08:10 neto Exp $";
d1009 1
d1013 3
@


1.141
log
@Removed duplicate const in prototype.
@
text
@d5 3
d119 1
a119 1
const char *lk_rcs_id="$Id: lk.w,v 1.140 96/09/12 14:05:44 neto Exp $";
d974 1
@


1.140
log
@Added twolevel debugging routines.
@
text
@d5 3
d116 1
a116 1
const char *lk_rcs_id="$Id: lk.w,v 1.139 96/09/11 16:37:48 neto Exp $";
d922 1
a922 1
void (*tour_set)(const int const *) = NULL;
d932 1
a932 1
extern void (*tour_set)(const int const *);
@


1.139
log
@Strengthened tour\_set prototype.
@
text
@d5 3
d113 1
a113 1
const char *lk_rcs_id="$Id: lk.w,v 1.138 96/09/10 16:21:26 neto Exp $";
d230 3
a232 1
\type{splay}, \type{two-level}, 
d239 4
d244 1
d360 1
d383 1
a383 1
	printf("      <rep> ::= array | two-level | splay\n");
d521 1
a521 1
		fprintf(stderr, "Need one of {array,splay [level],two-level}\n");
d529 2
d542 1
a542 1
		fprintf(stderr, "Need one of {array,splay [level],two-level}\n");
d724 1
d933 2
a934 1
@@ Currently, only the \type{array} and \type{two-level} representations
d957 12
d970 1
a970 1
	errorif(1,"Only array and two-level representations are currently supported");
d993 3
a995 1
	twolevel_setup(n, n < 50 ? n : (n < 1000 ? 50 : (n > 100000 ? 200 :  100)));
d997 5
d1003 1
@


1.138
log
@Added handling of two-level representation.
@
text
@d5 3
d110 1
a110 1
const char *lk_rcs_id="$Id: lk.w,v 1.137 96/08/23 17:24:32 david Exp Locker: neto $";
d905 1
a905 1
void (*tour_set)(int *) = NULL;
d915 1
a915 1
extern void (*tour_set)(int *);
@


1.137
log
@Removed the period from the etal macro
@
text
@d4 4
a7 1
{\obeylines$Log: lk.w,v $
d107 1
a107 1
const char *lk_rcs_id="$Id: lk.w,v 1.136 1996/08/23 15:40:41 david Exp david $";
d119 1
d125 1
d226 1
a226 1
Only \type{array} is supported for now.
d652 1
a652 1
#if defined(FIXINCLUDES)
d916 2
a917 3
@@ We may add an option to the program to allow the user to choose which
oriented tour implentation to use.  But for now, we just use the
array implementation.
d920 2
d929 13
d943 1
a943 1
@@ But first we need to include this array-based tour interface.
d946 1
d952 6
d959 10
a968 1
tour_setup(tsp_instance->n);
d970 1
a986 1
@@
@


1.136
log
@Fixed for linux.  Unistd declares gethostname and getpagesize only
if \_\_USE\
_BSD is defined.  So I doit manually.
@
text
@d4 5
a8 1
{\obeylines$Log:	lk.w,v $
d104 1
a104 1
const char *lk_rcs_id="$Id: lk.w,v 1.135 96/08/20 11:30:40 neto Exp $";
d225 1
a225 1
Fredman \etal~for the details on this.
d808 1
a808 1
Johnson and McGeoch, and Johnson \etal\ demonstrate the performance
d842 1
a842 1
Fredman \etal\ introduce this ADT, experimented with various 
@


1.135
log
@Added unistd.h for gethostname
@
text
@d5 3
d100 1
a100 1
const char *lk_rcs_id="$Id: lk.w,v 1.134 96/08/16 16:59:37 neto Exp $";
d1028 3
@


1.134
log
@Report the fixincludes rcs id only if we actually compiled it in.
@
text
@d5 3
d97 1
a97 1
const char *lk_rcs_id="$Id: lk.w,v 1.133 96/08/16 16:56:43 neto Exp $";
d1024 1
@


1.133
log
@Was including fixincludes twice erroneously.
@
text
@d5 3
d94 1
a94 1
const char *lk_rcs_id="$Id: lk.w,v 1.132 96/08/16 16:49:58 neto Exp $";
d106 1
a107 1
#define FIXINCLUDES_USE_RCS_ID
d637 1
d639 1
@


1.132
log
@Added fixincludes to the rcs list
@
text
@d5 3
d91 1
a91 1
const char *lk_rcs_id="$Id: lk.w,v 1.131 96/08/16 13:36:01 neto Exp $";
d104 1
d106 1
a746 3
#define FIXINCLUDES_USE_RCS_ID
#include "fixincludes.h"
#undef FIXINCLUDES_USE_RCS_ID
@


1.131
log
@only need gethostname
@
text
@d5 3
d88 1
a88 1
const char *lk_rcs_id="$Id: lk.w,v 1.130 96/08/16 13:32:04 neto Exp $";
d629 1
d742 3
@


1.130
log
@Fixed the semantics of fwrite.
@
text
@d5 3
d85 1
a85 1
const char *lk_rcs_id="$Id: lk.w,v 1.129 96/08/16 13:04:58 neto Exp $";
d97 1
a97 1
#define FIXINCLUDES_NEED_RESOURCE_STUFF
d99 1
a99 1
#undef FIXINCLUDES_NEED_RESOURCE_STUFF
@


1.129
log
@Added fixincludes.
@
text
@d5 3
d82 1
a82 1
const char *lk_rcs_id="$Id: lk.w,v 1.128 96/08/16 12:42:06 neto Exp $";
d708 1
a708 1
	int count;
d713 5
a717 2
	while ( (count=fread(buf,1,8192,prolog)) > 0 ) {
		fwrite(buf,1,count,ps_out);
@


1.128
log
@Converted putchar to printf.  Otherwise, I'd never get a prototype
for SunOS' \_flusbuf.
@
text
@d5 4
d79 1
a79 1
const char *lk_rcs_id="$Id: lk.w,v 1.127 96/08/15 14:45:51 neto Exp $";
d91 3
@


1.127
log
@Enable  definition of length\_rcs\_id
@
text
@d5 3
d75 1
a75 1
const char *lk_rcs_id="$Id: lk.w,v 1.126 96/08/15 13:29:00 neto Exp $";
d676 1
a676 1
	putchar('\n');
d1049 1
a1049 1
			if ( (i % 10) == 9 ) putchar('\n');
@


1.126
log
@Make it pass -Wall
@
text
@d5 3
d72 1
a72 1
const char *lk_rcs_id="$Id: lk.w,v 1.125 96/08/15 12:36:18 neto Exp $";
d716 1
d718 1
@


1.125
log
@No longer use the "upper" module.
@
text
@d5 3
d69 1
a69 1
const char *lk_rcs_id="$Id: lk.w,v 1.124 96/08/14 15:16:42 neto Exp $";
d518 3
a520 2
			strcmp(argv[r],"nn")!=0 && strcmp(argv[r],"nq")!=0 &&
			strcmp(argv[r],"del")!=0 ) {
d634 5
a638 5
	verbose != DEFAULT_VERBOSE && printf("-v %d ",verbose);
	should_show_version	&& printf("-V ");
	should_show_tour && printf("-t ");
	PostScript_filename && printf("-p %s ",PostScript_filename);
	iterate && printf("-i %d ",iterate);@@#
d648 8
a655 5
	candidate_expr & CAND_NN && printf("nn %d %s",cand_nn_k, 
		candidate_expr & (CAND_NQ|CAND_DEL) ? "or ": "");
	candidate_expr & CAND_NQ && printf("nq %d %s",cand_nq_k, 
		candidate_expr & CAND_DEL ? "or ": "");
	candidate_expr & CAND_DEL && printf("del %d ",cand_del_d);
@


1.124
log
@Fixed printing of command line.
@
text
@d5 3
d66 1
a66 1
const char *lk_rcs_id="$Id: lk.w,v 1.123 96/08/14 14:45:14 neto Exp $";
a611 1
	printf("%s\n",upper_rcs_id);
a620 1
#include "upper.h"
@


1.123
log
@Really fixed it this time.
@
text
@d5 3
d63 1
a63 1
const char *lk_rcs_id="$Id: lk.w,v 1.122 96/08/14 14:41:38 neto Exp $";
d640 1
a640 1
	if ( sort == dsort ) printf("-S dsort");
@


1.122
log
@Fixed cast of qsort.
@
text
@d5 3
d60 1
a60 1
const char *lk_rcs_id="$Id: lk.w,v 1.121 96/08/14 14:37:27 neto Exp $";
d265 1
a265 1
	sort = (int (*)(const void *, size_t, size_t, int(*)(const void*,const void*)))qsort;
d432 1
a432 2
		sort = (int (*)(const void *, size_t, size_t, 
				int(*)(const void*,const void*)))qsort;
@


1.121
log
@Fix the declaration of sort to match ANSI (use void instead of char).
@
text
@d5 3
d57 1
a57 1
const char *lk_rcs_id="$Id: lk.w,v 1.120 96/08/14 13:48:56 neto Exp $";
d262 1
a262 1
	sort = qsort;
d429 2
a430 1
		sort = (int(*)(const void*,const void*))qsort;
@


1.120
log
@Add an option to specify sorting procedure.
@
text
@d5 3
d54 1
a54 1
const char *lk_rcs_id="$Id: lk.w,v 1.119 96/08/02 14:38:42 neto Exp $";
d268 1
a268 1
void (*dsort)(char *a, size_t n, size_t es, int(*cmp)());
d277 1
a277 1
extern void (*dsort)(char *a, size_t n, size_t es, int(*cmp)());
d425 2
a426 1
	if ( strcmp(argv[r],"qsort")==0 ) sort = qsort;
@


1.119
log
@Update documentation and printing of command line to reflect new
construct implementation.
.\
@
text
@d5 5
d51 1
a51 1
const char *lk_rcs_id="$Id: lk.w,v 1.118 96/08/02 14:10:52 neto Exp $";
d190 10
d256 1
d265 1
d274 1
d309 2
d388 2
a389 1
argument chosen from a fixed list.
d411 25
d585 1
d626 2
@


1.118
log
@Update command line switches to match what construct offers.
Updated the construct() call.
@
text
@d5 4
d46 1
a46 1
const char *lk_rcs_id="$Id: lk.w,v 1.117 96/07/30 16:29:32 neto Exp $";
d179 4
a182 4
\type{canonical} (tour $1,2,3,\ldots,n$), 
\type{greedy} (unsupported), 
\type{ai} (arbitrary insertion), 
and \type{best} (best of the above---the default).
d290 1
a290 1
	printf("      <kind> ::= ai | canonical | greedy | random [seed] | best\n");
d373 1
a373 1
		fprintf(stderr, "Need one of {ai,canonical,greedy,random [seed],best}\n");
d576 1
a576 1
	case CONSTRUCT_RANDOM: printf("-s random %l ",start_heuristic_param); break;
@


1.117
log
@Flush stdout after each call to resource\_mark
@
text
@d5 3
d42 1
a42 1
const char *lk_rcs_id="$Id: lk.w,v 1.116 96/07/29 17:08:19 neto Exp $";
d234 2
a235 2
	start_tour = START_BEST;
	start_random_seed = 42L;
d242 1
a242 1
long start_random_seed;
d250 1
a250 1
extern long start_random_seed;
a268 5
#define START_BEST		1	/* Starting tour types */
#define START_CANONICAL	2
#define START_RANDOM	3
#define START_GREEDY	4
#define START_AI		5
d373 2
a374 4
	if ( strcmp(argv[r],"ai")==0 ) start_tour = START_AI;
	else if ( strcmp(argv[r],"canonical")==0 ) start_tour = START_CANONICAL;
	else if ( strcmp(argv[r],"greedy")==0 ) start_tour = START_GREEDY;
	else if ( strcmp(argv[r],"best")==0 ) start_tour = START_BEST;
d376 2
a377 2
		start_tour = START_RANDOM;
		if ( r+1<argc && is_number(argv[r+1]) ) start_random_seed = atol(argv[++r]);
d571 2
a572 5
	case START_BEST: printf("-s best "); break;
	case START_AI: printf("-s ai "); break;
	case START_CANONICAL: printf("-s canonical "); break;
	case START_RANDOM: printf("-s random "); break;
	case START_GREEDY: printf("-s greedy "); break;
d825 1
a825 1
incumbent_len = construct(n,tour,start_tour == START_RANDOM);
@


1.116
log
@Fixed to compile
@
text
@d5 3
d39 1
a39 1
const char *lk_rcs_id="$Id: lk.w,v 1.115 96/07/29 16:20:02 neto Exp $";
d699 1
a699 1
resource_mark("Build the 2-d tree");
d705 1
a705 1
resource_mark("Build the adjacency structure");
d830 1
a830 1
resource_mark("Construct starting tour");
d876 1
a876 1
resource_mark("Lin-Kernighan");
d900 1
a900 1
resource_mark("The end");
@


1.115
log
@Added *\_rcs\_id.
Made sure RCS log is activated within this file.
@
text
@d4 5
a8 1
{\obeylines$Log$
a26 1
const char lk_rcs_id[]="$Id$";
d36 1
d53 1
a53 1
extern const char *lk_rcs_id[];
d549 8
@


1.114
log
@Report compiler options together with command line options.
@
text
@d2 1
d4 3
d23 1
d34 1
d49 1
d61 1
d87 1
d99 1
d512 36
a547 1
@@ If verbose mode is on at all, then we should print out a complete
d551 1
a551 1
@@<Parse the command line@@>=
d553 1
a553 2
	extern char *compile;
	printf("%s\n%s ",compile,argv[0]);
@


1.113
log
@Isolated debugging output with verbose.  But give some feedback during
testing.
@
text
@d508 2
a509 1
	printf("%s ",argv[0]);
@


1.112
log
@Better diagnostic on kdtree check.
@
text
@d933 1
d950 3
a952 1
			printf("nn(%d) #%d = %d dist "length_t_spec"\n",c,i,d,length_t_pcast(cost(c,d)));
d964 3
d970 1
a970 1
printf("kd tree passed an integrity test on nearest-neighbour searching\n");
@


1.111
log
@Made checking the kdtree conditional.
@
text
@d941 1
a941 1
		if (0<=d&&d<n ) {
d948 2
d954 2
a955 1
			;
@


1.110
log
@Better message on nn failure.
@
text
@d929 1
a940 3
#if 0
		printf("nn(%d) #%d is %d",c,i,d);
#endif
a941 3
#if 0
			printf(" at distance"length_t_spec"\n",cost(c,d));
#endif
d952 1
a952 3
#if 0
			printf(", i.e. undefined\n");
#endif
d963 1
@


1.109
log
@Added PostScript output of buckets.
@
text
@d851 1
a851 1
if ( ps_out ) fclose(ps_out);
d929 1
a929 1
{ int i,c,d,*done=new_arr_of(int,n);
d937 1
d940 1
a940 1
#if 1
d944 1
a944 1
#if 1
d947 7
a953 1
			errorif(last_dist>(next_dist=cost(c,d)),"Bug");
d955 1
d957 1
a957 1
#if 1
d968 1
a968 1
printf("kd tree passed some integrity tests\n");
a969 1
	
@


1.108
log
@Changed read/write to fread/fwrite.
That prolog part works now, but I may want to move that to the reading
routine.
@
text
@d568 1
a568 1
	prolog=fopen("prolog.ps","r");
a570 1
		printf("Prolog block written\n");
a575 1
fclose(ps_out);
d643 1
d851 1
d962 1
@


1.107
log
@Added testing of the kd tree.
Added code to write the prolog to the postscript file.
@
text
@d568 7
a574 2
	errorif( (prolog=fopen("prolog.ps","r"))==NULL,"Couldn't open prolog.ps for reading");
	while ( (count=read(prolog,buf,8192)) > 0 ) write(ps_out,buf,count);
d577 1
@


1.106
log
@Accomodate the extra resource mark; report it.
@
text
@d563 3
d568 2
d639 1
d921 35
@


1.105
log
@Inserted call to build 2-d tree.
@
text
@d833 1
@


1.104
log
@Fixed a bug with -c processing.  It was gobbling up one too many arguments.
@
text
@d630 4
@


1.103
log
@Finished command line argument handling.
Now I have to add code to handle all that the command line allows us
to specify!
@
text
@d457 4
d462 2
a463 2
		r+=2;
	} while( r+1<argc && strcmp(argv[r],"or")==0 && r++);
a627 1
For now, we'll just use the first 20 nearest neighbours.
@


1.102
log
@Almost finished with command line switches.
@
text
@d116 1
a116 1
used at all, then a default value of 0 is used.
d178 1
a178 1
	char *filename = NULL;
d182 1
d197 1
d199 5
d205 1
a205 2
{
	verbose = 0;
a216 1
}
d463 9
d505 3
a507 3
	printf("-v %d ",verbose);
	should_show_version	&& printf("-V %d ",verbose);
	should_show_tour && printf("-t %d ",verbose);
d509 1
a509 1
	iterate && printf("-i %d ",iterate);
d511 29
a539 2
	case START_BEST:
	printf("-s "
a541 1
#include "memory.h"
d554 9
a562 1
tsp_instance = read_tsp_file( TSPLIB_filename );
d565 1
a565 1
@@ We need to declare that module-level variable |n|.
d568 1
a583 8
@@ The reading routine needs a |debug| variable which points to a 
the file to write PostScript debugging output.  Set |debug==NULL| to
avoid generating that output.

@@<Global variables@@>=
FILE *debug = NULL;


d628 3
a630 1
nn_build(20,NN_PURE);
d638 1
a638 1
nn_setup(n,20);
d754 1
a754 1
incumbent_len = construct(n,tour,random_initial_tour);
d756 1
@


1.101
log
@Added some command line switch stuff.  I'm going to lunch now.
@
text
@d26 1
d110 1
a110 2
Option \type{-V} or \type{--version} prints out version information,
then quits.
d135 4
d181 1
a181 1
			@@<Parse the options@@>@@;
d183 8
a190 4
			errorif(filecount,"Only one input file allowed, but you specified:"
				"\"%s\" \"%s\"\n", filename?filename:"-", argv[r] );
			if ( more_options && strcmp(argv[r],"-")==0 ) /* Use |stdin| */
			else filename = argv[r];
d201 2
d215 2
a216 1
int verbose, iterate, representation, start_tour;
d219 1
d223 3
a225 1
extern int verbose, iterate, representation;
d227 1
d232 6
a237 2
#define REP_SPLAY		2	
#define REP_TWO_LEVEL	3
d242 1
d250 2
a251 2
@@  The help is the easiest part.
@@<Parse the options@@>=
d276 1
a276 1
@@<Parse the options@@>=
d282 16
d299 1
a299 1
@@<Parse the options@@>=
d307 1
a307 1
@@<Parse the options@@>=
d318 1
a318 1
@@<Subroutines@@>=
d330 1
a330 1
@@
d335 2
a336 2
let's do the \type{--iterate} option as well.
@@<Parse the options@@>=
d344 2
a345 2
argument from a fixed list.
@@<Parse the options@@>=
d347 5
a351 3
	errorif(r+1>=argc,
		"Option %s requires an argument (ai,canonical,greedy,random [seed],best)\n",
		argv[r]);
d359 5
a363 1
		if ( r+1<argc && is_number(argv[r]) ) start_random_seed = atol(argv[++r]);
d368 32
d401 1
a401 1
@@<Parse the options@@>=
d403 5
a407 1
	errorif(r+1>=argc,"Option %s needs a file name argument",argv[r]);
d411 2
a412 1
			"Warning: %s already specified as PostScript output file; %s overrides\n", 
d420 3
a422 2
@@ The first argument of the program is the name of the TSPLIB file that
contains the instance to be processed.  This argument is mandatory.
d424 33
a456 2
The second argument is optional.  It is a ``verbosity'' level.  A value
of 0 produces no output.
d458 5
a462 1
If no arguments are given, then a usage string is printed.
d464 11
a474 11
@@<Parse the command line@@>=
errorif( argc < 2 || argc > 4, 
	"Usage %s: <TSPLIB-instance> [<verbosity-level> [<random-initial-tour?>] ",
	argv[0]);
TSPLIB_filename = dup_string(argv[1]);
if ( argc > 2 ) {
	verbose = atoi(argv[2]);
	if ( argc > 3 ) {
		random_initial_tour = atoi(argv[3]);
	} else {
		random_initial_tour = 0;
d476 6
a481 2
} else {
	verbose = 100;
a482 2
printf("verbose: %d\n",verbose);
printf("random initial tour: %s\n", random_initial_tour ? "Yes" : "No" );
d484 3
a486 2
@@ We've used some general purpose memory allocation and error-checking
functions.  Their interfaces are given in the following header files.
d488 13
a500 2
@@<Early module headers@@>=
#include "error.h"
d503 1
a503 3
@@ We also need to declare the global variables we've just initialized.
After this initialization, these variables are unchanged for the remainder
of the execution of this program.
d505 1
a505 12
@@<Global variables@@>=
char *TSPLIB_filename;
int verbose;

@@ @@<Module variables@@>=
static int random_initial_tour;

@@ @@<Exported variables@@>=
extern char *TSPLIB_filename;
extern int verbose;

@@ Now we read the instance into a structure that is read-only for the rest
d715 9
d862 1
@


1.100
log
@This version works.  
Needs improvement:
	command-line switches
	faster tabu check
	allow Papadimitriou tabu rule
	faster preprocessing
	different candidate lists
@
text
@d43 1
d89 252
d684 1
a684 1
void lk_cleanup(void);
@


1.10
log
@Print the tour as well.
@
text
@@


1.9
log
@Print the host name.
@
text
@d83 1
a83 1
	@@<Validate the result@@>@@;
d464 1
a464 1
@@<Validate the result@@>=
d469 5
d479 1
a479 1
	printf("incumbent_len == " length_t_spec 
@


1.8
log
@Fixed variable name.
@
text
@d405 9
@


1.7
log
@Allow an option to specify only a random initial tour.
@
text
@d104 1
a104 1
		random_initial = atoi(argv[3]);
@


1.6
log
@Show the verbose value, no matter what.
@
text
@d97 3
a99 2
errorif( argc < 2 || argc > 3, 
		"Usage %s: <TSPLIB-instance> [<verbosity-level>]",argv[0]);
d103 5
d112 1
d129 3
d342 1
a342 1
incumbent_len = construct(n,tour);
@


1.5
log
@Provide an optional verbose value of 100.
@
text
@d105 1
@


1.4
log
@Don't count validation time.
@
text
@d102 2
@


1.3
log
@Added include to construct.h (to get the definition for construct()
so that incumbent_len is set poroperly)
Refine the comment abuot between query.
@
text
@d82 1
a83 1
	@@<Stop the timers and report the results@@>@@;
@


1.2
log
@Initial implementation of LK.  This is buggy.
@
text
@d203 1
a203 2
@@
	@@<Build the data structures@@>=
d243 1
a243 1
city $b$ before city $c$?''
d330 1
d332 3
@


1.1
log
@Initial revision
@
text
@d82 1
d433 21
@
