head	1.4;
access;
symbols
	zero-four-zero:1.4;
locks
	neto:1.4;


1.4
date	98.05.21.19.29.35;	author neto;	state Exp;
branches;
next	1.3;

1.3
date	98.05.21.19.24.58;	author neto;	state Exp;
branches;
next	1.2;

1.2
date	98.05.21.19.22.41;	author neto;	state Exp;
branches;
next	1.1;

1.1
date	95.11.17.16.06.40;	author neto;	state Exp;
branches;
next	;


desc
@Kruskal's algorithm.
@


1.4
log
@Fixed up standard CWEB thingies and Log stuff.
@
text
@@@i webdefs.w
@@i copyrt.w
@@i types.w

{\obeylines
$Log: kruskal.w,v $
Revision 1.3  1998/05/21 19:24:58  neto
Cleaned up namespace pollution.
Include standard CWEB goodies.
}



@@* Kruskal's algorithm.
This is is an $O( e \log e )$ algorithm for finding a minimum spanning tree.
It is as follows.  First sort the edges into ascending order.  Then scan
this list beginning with the lowest-cost edge, adding each edge in turn
which does not create a cycle in the current forest.  Stop when 
|n-1| edges have been added, or when the edge list has been exhausted.  If
the edge list is exhausted before |n-1| have been added, then the original
graph was disconected, in which case a minimum length spanning forest has
been computed.

Actually, this module uses Kruskal's algorithm to compute minimum 1-trees
with given restrictions.

@@ The outline of this module is as follows:
@@c
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <assert.h>
#include <sys/time.h>
#include <sys/resource.h>
#include "tsp.h"
#include "kruskal.h"
#include "ee.h"
#include "memory.h"
#include "config.h"
#include "lkconfig.h"
#include "length.h"
#include "read.h" /* For |cost| */
#include "error.h"@@#

extern int verbose;
@@<Type definitions@@>@@;
@@<Module-level variables@@>@@;
@@<Global variables@@>@@;
@@<Local subroutines@@>@@;
@@<Subroutines@@>@@;

@@ The exported interface is contained in the {\tt kruskal.h} header file,
which has the following form.

@@(kruskal.h@@>=
@@<Exported routines@@>@@;


@@ If the graph is disconnected, the |kruskal_onetree| routine returns 
|prune_len|, so that any ascent is terminated.

@@ We count the number of 1-trees computed by this routine.
We also mark the time of first entry to this module.

@@<Global variables@@>=
unsigned long kruskal_count;
#if 0
struct rusage r_kruskal;
#endif

@@
This MST algorithm will be called many times with the same
underlying vertex set, though the edges will be changing slightly
over time.
We allocate the per-vertex auxiliary space
only once, and reuse it on each call to |kruskal|.
This allocation is done within |kruskal_setup| which should be called exactly
once for each new underlying graph before |kruskal| is called for that graph.

Also, |kruskal_cleanup| should be called
after the results of a call to |kruskal| are last used, but before
a new underlying graph is worked on.


@@<Subroutines@@>=
void
kruskal_setup(const int num_vertices, const int num_teams)
{   int i;
    n = num_vertices;
    p = num_teams;
	kruskal_count = 0;
    @@<Allocate the storage needed for |p| teams for a graph of size |n|@@>@@;
}

void
kruskal_cleanup(void)
{   int i;
    @@<Recycle the auxiliary storage@@>@@;
}

@@ We make these initialization and termination routines publicly available.
@@<Exported routines@@>=
void kruskal_setup(const int num_vertices, const int num_teams);
void kruskal_cleanup(void);

@@
@@<Module-level variables@@>=
static int n;   /* The number of vertices. */
static int p;   /* The number of concurrent teams. */

@@ There is a structure associated with each
vertex and for each concurrent team working on a 1-tree problem,
Its members will be described one by one below.

@@<Type definitions@@>=
typedef struct kruskal_vertex_s {
    @@<|kruskal_vertex_t| fields@@>@@;
} kruskal_vertex_t;

@@
@@<Module-level variables@@>=
static kruskal_vertex_t **kv;

@@
@@<Allocate the storage needed for |p| teams for a graph of size |n|@@>=
    kv = new_arr_of(kruskal_vertex_t *,p);
    for (i=0;i<p;i++) {
        kv[i] = new_arr_of(kruskal_vertex_t,n);
    }

@@
@@<Recycle the auxiliary storage@@>=
    for (i=0;i<p;i++) {
        free_mem(kv[i]);
    }
    free_mem(kv);

@@ To detect cycles in the graph, we use a merge/find abstract data type.
Initially, each vertex is in a component by itself.  
When $(i,j)$ is added, we merge the components containing $i$ and $j$.
A cycle would be created by adding $(i,j)$ if and only if $i$ and $j$
are already in the same cycle.

The identity of the component containing $i$ is given by |find(i)|, and
components are merged by calling |merge(i,j)|.

To implement this scheme efficiently, we use a |parent| pointer and
a |count| in each vertex.

@@<|kruskal_vertex_t| fields@@>=
struct kruskal_vertex_s *parent;
unsigned int count;

@@
Initially, each vertex is in a component by itself.
@@<Initialize vertex |i|@@>=
kvv[i].parent = kvv + i;	/* Root points to itself. */
kvv[i].count = 1;
onetree[i].edges = NULL;
onetree[i].degree_less2 = -2;
onetree[i].a_fixed_in_dest = -1;

@@  During a |find|,
we remember the path we traverse using an array of |kruskal_vertex_t| pointers.
But because of weighted merging, no
path is longer than $\lceil \log_2 n \rceil +1$.  I assume that
there are no more than $2^{64}$ vertices in the graph, so a $66$
element path array should be large enough.

Suppose we are compressing a long path.
Then the last two nodes stored in the |path| array are the root and
one of its children.  But they already have the correct |parent| pointer,
so we avoid ``updating'' them.
This way we avoid invalidating those cache lines, which is especially
important in the parallel setting.
(We cover the short path case with the test |path_length >0| at
the head of the |while| loop.)

We allocate 
the |path| array only once 
instead of on each call to |find|.

@@<Module-level variables@@>=
static kruskal_vertex_t ***path;

@@
@@<Allocate the storage needed for |p| teams for a graph of size |n|@@>=
path = new_arr_of( kruskal_vertex_t **, p);
for ( i=0;i<p;i++){
	path[i] = new_arr_of(kruskal_vertex_t *,66);
}


@@
@@<Local subroutines@@>=
static kruskal_vertex_t *
find(const int team_num, kruskal_vertex_t *v)
{
    kruskal_vertex_t *p;
    int path_length;

    for ( path_length = 0, p=v->parent; p != v ;  ) {
        path[team_num][path_length++]=v; /* Construct the path for later compression. */
        v = p; /* Go up the tree. */
        p = p->parent;
    }
    path_length -= 2;   /* Don't write to the root or its child. */
    while ( path_length >0 ) {
        path[team_num][--path_length]->parent = p;
    }
    return p;
}


@@ Merging is easy.
We make the smaller subtree a child of the larger, and
return the child.  The parent can be recovered easily.

@@<Local subroutines@@>=
static kruskal_vertex_t *
merge(const int team_num, kruskal_vertex_t *u, kruskal_vertex_t *v)
{
    kruskal_vertex_t *root, *child;
    root = find(team_num,u);
    child = find(team_num,v);
    if ( child->count > root->count ) { /* Swap them. */
        kruskal_vertex_t *t=root; root=child; child=t;
    }
/* Now there are at least as many nodes below |root| as there are below |child|.
 */
    child->parent = root;
    root->count += child->count;
    return child;
}



@@ This is the |kruskal_onetree| routine itself.
@@<Subroutines@@>=
double
kruskal_onetree(search_node_t *bbnode, 
    edge_list_t *edge, onetree_node_t *onetree, double *lambda,
    const int use_edge_exchanges)
{
    int i, j, next_v, rows_to_process, edges_to_n_minus_1 = 0, num_edges;
    double d, tot_len;
    extern int verbose;
    extern unsigned long count_onetree;
    kruskal_vertex_t *kvv;
	ee_t *ee;		/* Eligible Edge */
	ee_t **eep;		/* Eligible Edge Pointer */
	ee_t *fie;		/* Fixed In Edge */
	ee_t **fiep;	/* Fixed In Edge Pointer */
	int nfie, nee;	/* Number Fixed In Edges, Number Eligible Edges */

	if ( kruskal_count == 0 ) {
#if 0
		getrusage(RUSAGE_SELF,&r_kruskal);
#endif
	}
	kruskal_count++;

	@@<Make team-specific initializations@@>@@;
	kvv = kv[team_num];

    count_onetree++;

    for (i=0;i<n;i++) {
        @@<Initialize vertex |i|@@>@@;
    }
    tot_len = 0.0;
    num_edges = 0;

    @@<Process the fixed in and fixed out edges@@>@@;

	@@<Find a minimum spanning tree over the first |n-1| vertices@@>@@;

    @@<Add the two shortest non-excluded edges incident upon |n-1|@@>@@;

    errorif( num_edges != n,"num_edges == %d != %d == n", num_edges, n);

    return tot_len;
}

@@ Make this routine publicly available.
@@<Exported routines@@>=
double kruskal_onetree(search_node_t *bbnode,
    edge_list_t *edge, onetree_node_t *onetree, double *lambda,
    const int use_edge_exchanges);

@@
@@<Make team-specific initializations@@>=
kvv = kv[team_num];

@@ The available edges are stored in the array |available_edge| with
corresponding counts |num_available_edges| and |num_available_not_nm1|
as described in {\sc ee}.

When arriving for the first time with these constraints, we build a table
of the fixed in edges and a table of the eligible but not fixed in edges.

@@<Process the fixed in and fixed out edges@@>=
if ( last_node[team_num] != bbnode ) {
	last_node[team_num] = bbnode;
	@@<Build the fixed in and available tables@@>@@;
}
nee = num_ee[team_num];
nfie = num_fie[team_num];
for ( i=0; i<nfie ; i++ ) {
	const int u = fie[i].e.from;
	const int v = fie[i].e.to;
	const double d = cost(u,v)+lambda[u]+lambda[v];
	errorif(find(team_num,kvv+u)==find(team_num,kvv+v),
		"Fixed in edge (%d,%d)creates a cycle",u,v);
	if ( u != n-1 && v != n-1 ) {
		onetree[u].a_fixed_in_dest = v;
		onetree[v].a_fixed_in_dest = u;
		errorif(kvv[u].fixed_in_deg>=2,"");
		errorif(kvv[v].fixed_in_deg>=2,"");
		kvv[u].fixed_in_deg++;
		kvv[v].fixed_in_deg++;
		@@<Use the edge from |u| to |v| len |d|@@>@@;
	}
}

@@
@@<|kruskal_vertex_t| fields@@>=
search_node_t *in, *out;

@@
@@<Build the fixed in and available tables@@>=
for ( i=0;i<n;i++ ) {
	kvv[i].in = NULL;
	kvv[i].out = NULL;
}
{	search_node_t *here;
	for ( here = bbnode ; here ; here=here->parent) {
		const int from = here->e.from;
		const int to = here->e.to;
		
		switch( here->in_out ) {
		case FIXED_IN:
			if ( kvv[from].in == NULL ) kvv[from].in = here;
			if ( kvv[to].in == NULL ) kvv[to].in = here;
			break;
		case FIXED_OUT:
			if ( kvv[from].out == NULL ) kvv[from].out = here;
			if ( kvv[to].out == NULL ) kvv[to].out = here;
			break;
		}
	}
	@@<Allocate more space if necessary @@>@@;

	nee = 0;
	nfie = 0;
	for (i=0;i<num_available_edges; i++) {
		in_out_t in_out = FIXED_NEITHER;
		const int from = available_edge[i].from;
		const int to = available_edge[i].to;
		for ( here=kvv[from].in ; here && in_out == FIXED_NEITHER ; ) {
			if ( (from == here->e.from && to == here->e.to)  || 
					(to == here->e.from && from == here->e.to) ) {
				in_out = here->in_out;
			}
			here = from == here->e.from ? here->from_next_in : here->to_next_in;
		}
		for (here=kvv[from].out ; here && in_out==FIXED_NEITHER ; ){
			if ( (from == here->e.from && to == here->e.to)  || 
					(to == here->e.from && from == here->e.to) ) {
				in_out = here->in_out;
			}
			here = from == here->e.from ? here->from_next_out : here->to_next_out;
		}
		switch( in_out ) {
		case FIXED_IN:
if ( verbose >= 200 ) {
	fprintf(stderr,"Fixed in edge (%d,%d)\n",from,to); fflush(stderr);
}
			fie[nfie].e.from = from;
			fie[nfie].e.to = to;
			fiep[nfie] = fie+nfie;
			nfie++;
			break;
		case FIXED_OUT:
			break;
		case FIXED_NEITHER:
if ( verbose >= 200 ) {
	fprintf(stderr,"Eligible edge (%d,%d)\n",from,to); fflush(stderr);
}
			ee[nee].e.from = from;
			ee[nee].e.to = to;
			eep[nee] = ee+nee;
			nee++;
			break;
		}
	}
}
num_ee[team_num] = nee;
num_fie[team_num] = nfie;





@@
@@<Module-level variables@@>=
static int *size_eligible;
static ee_t **pee;		/* Parallel Eligible Edge */
static ee_t ***peep;	/* Parallel Eligible Edge Pointer */
static ee_t **pfie;		/* Parallel Fixed In Edge */
static ee_t ***pfiep;	/* Parallel Fixed In Edge Pointer */
static int *num_ee;		/* Number of Eligible Edges */
static int *num_fie;	/* Number of Fixed In Edges */
static search_node_t **last_node;

@@
@@<Make team-specific initializations@@>=
ee = pee[team_num];
eep = peep[team_num];
fie = pfie[team_num];
fiep = pfiep[team_num];

@@
@@<Allocate more space if necessary @@>=
if ( size_eligible[team_num] < num_available_edges ) {
	free_mem( pee[team_num] ); mem_deduct( sizeof(ee_t)*size_eligible[team_num] );
	ee = pee[team_num] = new_arr_of( ee_t, num_available_edges );

	free_mem(peep[team_num]); mem_deduct(sizeof(ee_t *)*size_eligible[team_num]);
	eep = peep[team_num] = new_arr_of( ee_t *, num_available_edges );

	free_mem(pfie[team_num]); mem_deduct(sizeof(ee_t)*size_eligible[team_num]);
	fie = pfie[team_num] = new_arr_of( ee_t, num_available_edges );

	free_mem(pfiep[team_num]); mem_deduct(sizeof(ee_t *)*size_eligible[team_num]);
	fiep = pfiep[team_num] = new_arr_of( ee_t *, num_available_edges );

	size_eligible[team_num] = num_available_edges;
}



@@
@@<Allocate the storage needed for |p| teams for a graph of size |n|@@>=
last_node = new_arr_of(search_node_t *,p);
num_ee = new_arr_of(int,p);
num_fie = new_arr_of(int,p);
size_eligible = new_arr_of(int,p);
pee = new_arr_of( ee_t *,p);
peep = new_arr_of( ee_t **, p);
pfie = new_arr_of( ee_t *,p);
pfiep = new_arr_of( ee_t **, p);
for (i=0;i<p;i++) {
	last_node[i] = (search_node_t *)1;	/* Remember |NULL| is the root. */
	size_eligible[i] = 0;
	pee[i] = new_arr_of( ee_t,0);
	peep[i] = new_arr_of( ee_t *, 0);
	pfie[i] = new_arr_of( ee_t,0);
	pfiep[i] = new_arr_of( ee_t *, 0);
}

@@
@@<Type definitions@@>=
typedef struct {
	edge_t e;
	double len;
} ee_t;

@@
@@<Recycle the auxiliary storage@@>=
for (i=0;i<p;i++) {
	free_mem(pee[i]);
	free_mem(peep[i]);
	free_mem(pfie[i]);
	free_mem(pfiep[i]);
}
free_mem(num_ee);
free_mem(num_fie);
free_mem(size_eligible);
free_mem(pee);
free_mem(peep);
free_mem(pfie);
free_mem(pfiep);


@@
@@<Use the edge from |u| to |v| len |d|@@>=
errorif(num_edges==n,"Adding (%d,%d) but too many edges already present",u,v);
edge[num_edges].e.from = u;
edge[num_edges].e.to   = v;
edge[num_edges].from_next = onetree[u].edges;
edge[num_edges].to_next = onetree[v].edges;
onetree[u].edges = edge + num_edges;
onetree[v].edges = edge + num_edges;
onetree[u].degree_less2++;
onetree[v].degree_less2++;
num_edges++;
tot_len += d;
if ( verbose >= 1000 ) {
	printf("#####Adding (%d,%d) len %f tot_len now %f\n",u,v,d,tot_len);
}
merge(team_num,kvv+u,kvv+v);

@@ We exclude all new edges which would be incident upon a vertex which is
already saturated with fixed in edges.  For this we need a count of fixed
in degree.

@@<|kruskal_vertex_t| fields@@>=
int fixed_in_deg;

@@
@@<Initialize vertex |i|@@>=
kvv[i].fixed_in_deg = 0;


@@ Here's Kruskal's algorithm in action.
@@<Find a minimum spanning tree over the first |n-1| vertices@@>=
for ( i=0;i<nee;i++) {
	ee[i].len = cost(ee[i].e.from,ee[i].e.to) + lambda[ee[i].e.from]+lambda[ee[i].e.to];
	if ( verbose>=1000 ) {
		printf("#  Len (%d,%d) is %f\n",ee[i].e.from,ee[i].e.to,ee[i].len);
		fflush(stdout);
	}
}
qsort(eep,nee,sizeof(ee_t*),cmp);

for ( i=0; i<nee && num_edges < n-2 ; i++ ) {
	const int u = eep[i]->e.from;
	const int v = eep[i]->e.to;
	if ( kvv[u].fixed_in_deg < 2 && kvv[v].fixed_in_deg < 2 
			&& u != n-1 && v != n-1
			&& find(team_num,kvv+u) != find(team_num,kvv+v) ) {
		const double d = eep[i]->len;
		@@<Use the edge from |u| to |v| len |d|@@>@@;
	}
}
if ( num_edges < n-2 ) {
	/* Graph is disconnected */
	tot_len = prune_len + 1;
	printf("# Graph is disconnected; returning length %f==prune_len\n",prune_len);
	return prune_len;
}

@@
@@<Local subroutines@@>=
static int
cmp(const void *a, const void *b) 
{
	const double d = (*((ee_t**)a))->len - (*((ee_t**)b))->len;
	if ( d < 0.0 ) return -1;
	if ( d > 0.0 ) return 1;
	return 0;
}


@@
First process fixed in edges incident upon |n-1|, then examine others.
@@<Add the two shortest non-excluded edges incident upon |n-1|@@>=
	for (i=0;i<nfie;i++) {
		const int u = fie[i].e.from;
		const int v = fie[i].e.to;
		if ( u==n-1 || v==n-1 ) {
			const double d = cost(u,v)+lambda[u]+lambda[v];
			onetree[u].a_fixed_in_dest = v;
			onetree[v].a_fixed_in_dest = u;
			/* When a node is already saturated by fixed in edges, just quit. */
			if ( kvv[u].fixed_in_deg>=2 ) return incumbent_len;
			if ( kvv[v].fixed_in_deg>=2 ) return incumbent_len;
			kvv[u].fixed_in_deg++;
			kvv[v].fixed_in_deg++;
			@@<Use the edge from |u| to |v| len |d|@@>@@;
		}
	}
	for ( i=0; i<nee && num_edges < n ; i++ ) {
		const int u = eep[i]->e.from;
		const int v = eep[i]->e.to;
		if ( kvv[u].fixed_in_deg < 2 && kvv[v].fixed_in_deg < 2 
				&& (u == n-1 || v == n-1) ) {
			const double d = eep[i]->len;
			@@<Use the edge from |u| to |v| len |d|@@>@@;
		}
	}
	if ( num_edges < n ) {
		/* Graph is disconnected */
		tot_len = prune_len + 1;
		printf("# Graph is disconnected; returning length %f==prune_len\n",prune_len);
		return prune_len;
	}
@


1.3
log
@Cleaned up namespace pollution.
Include standard CWEB goodies.
@
text
@d5 7
a11 1
$Log$
@


1.2
log
@Change onetree kruskal to kruskal onetree.
Also removed team number parameter to the onetree routine.
@
text
@d1 7
d60 1
a60 1
unsigned long count_kruskal;
d85 1
a85 1
	count_kruskal = 0;
d250 1
a250 1
	if ( count_kruskal == 0 ) {
d255 1
a255 1
	count_kruskal++;
@


1.1
log
@Initial revision
@
text
@d26 3
d46 1
a46 1
@@ If the graph is disconnected, the |onetree_kruskal| routine returns 
d54 1
d56 1
d225 1
a225 1
@@ This is the |onetree_kruskal| routine itself.
d228 1
a228 1
onetree_kruskal(search_node_t *bbnode, const int team_num,
d244 1
d246 1
d274 1
a274 1
double onetree_kruskal(search_node_t *bbnode,const int team_num,
@
