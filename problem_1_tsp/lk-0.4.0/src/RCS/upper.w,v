head	1.103;
access
	david
	neto;
symbols
	zero-four-zero:1.103;
locks
	neto:1.103;


1.103
date	98.05.21.19.29.35;	author neto;	state Exp;
branches;
next	1.102;

1.102
date	96.07.29.17.07.27;	author neto;	state Exp;
branches;
next	1.101;

1.101
date	96.07.29.16.20.15;	author neto;	state Exp;
branches;
next	1.100;

1.100
date	96.05.29.11.13.24;	author neto;	state Exp;
branches;
next	1.4;

1.4
date	96.05.22.17.10.16;	author neto;	state Exp;
branches;
next	1.3;

1.3
date	96.05.22.17.08.13;	author neto;	state Exp;
branches;
next	1.2;

1.2
date	96.03.15.16.00.26;	author neto;	state Exp;
branches;
next	1.1;

1.1
date	96.03.04.13.55.17;	author neto;	state Exp;
branches;
next	;


desc
@Some upper bounding heuristics.
@


1.103
log
@Fixed up standard CWEB thingies and Log stuff.
@
text
@@@i webdefs.w
@@i copyrt.w
@@i types.w

{\obeylines
$Log$
}

@@*Upper bounding heuristics.
We will compute a the length of a few easy tours for the TSP problem at hand.
The best such bound will be used as a parameter 
in the initial ascent for the Held-Karp 1-tree relaxation.

The outline of this module is as follows.

@@c
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <assert.h>
#include "tsp.h"
#include <config.h>
#include "lkconfig.h"
#include "length.h"
#include "read.h"
#include "memory.h"
#include "debug.h"
#include "error.h"
@@<Other includes@@>@@#

@@<Subroutines@@>@@;

@@ The exported interface is contained in the {\tt upper.h} header file,
which has the following form.

@@(upper.h@@>=
@@<Exported routines@@>@@;

@@ The first tour is just the canonical tour: $(0,1,\ldots,n-1)$.
@@<Subroutines@@>=
static void
canonical(int n, int *tour)
{
	int i;	

	tour[n-1]=0;
	for (i=0; i<n-1;i++) {
		tour[i]=i+1;
	}
}

@@ The second tour is a random walk amongst the cities.
@@<Subroutines@@>=
static void
random_walk(int n, int *tour)
{
	int i, t;
	double drand48(void);
	void srand48(long seed);

	for (i=0; i< n;i++) {
		tour[i] = i;
	}

	srand48(42L);
	for (i=0; i<n;i++) {
		const int next = floor(drand48()*(n-i));
		const int t = tour[next];
		tour[next] = tour[n-1-i];
		tour[n-1-i] = t;
	}
}

@@
@@<Other includes@@>=
#include <math.h>

@@ This is the depth-first search of the minimum one-tree.
@@<Subroutines@@>=
static void 
dfs_onetree( int node, int *tour, int *sofar, int *visited, onetree_node_t*onetree)
{
	if ( !visited[node] ) {
		edge_list_t *e;
		visited[node] = 1;
		tour[*sofar] = node;
{extern FILE *debug; if (debug) {fprintf(debug,"( %d) %d label\n",*sofar,node);
fflush(debug);}}
		*sofar += 1;
		for ( e = onetree[node].edges ; e ; ) {
			if ( node == e->e.from ) {
				dfs_onetree(e->e.to,tour,sofar,visited,onetree);
				e = e->from_next;
			} else {
				dfs_onetree(e->e.from,tour,sofar,visited,onetree);
				e = e->to_next;
			}
		}
	}
}


static void
double_onetree(int n, int *tour)
{
	int *visited = new_arr_of(int,n);
	double *lambda = new_arr_of(double,n);
	edge_list_t *edges = new_arr_of(edge_list_t,n);
	onetree_node_t *onetree = new_arr_of(onetree_node_t,n);
	int i, sofar;

	for(i=0;i<n;i++) {
		lambda[i] = 0.0;
		visited[i] = 0;
	}
	onetree_prim(NULL,0,edges,onetree,lambda,0);
	sofar = 0;
	dfs_onetree(n-1,tour,&sofar,visited,onetree);
	errorif(sofar!=n,"upper.w:double_onetree: Didn't traverse the whole graph!  sofar==%d",sofar);

	free_mem(visited);
	free_mem(lambda);
	free_mem(edges);
	free_mem(onetree);
}

@@
@@<Other includes@@>=
#include "prim.h"

@@ This is the nearest insertion heuristic.

In one study (B.~L.~Golden and W.~R.~Stewart.  Empirical anaylsis of 
heuristics.  In 
E.~L.~Lawler and J.~K.~Lenstra and A.~H.~G.~Rinnooy Kan and D.~B.~Shmoys, 
editors, {\it The Traveling Salesman Problem}, chapter 7, pages 207--209.
John Wiley \& Sons Ltd., 1985) it was found to provide bounds within 15\%
of optimal.  

However,
in my experience with graphs whose edges were drawn from a uniform distribution
over [1,1000], it would often be off by a factor of 10 times.


@@<Subroutines@@>=
static void
nearest_addition(int n, int *tour)
{
	double *distance = new_arr_of(double,n);
	int *nearest_to = new_arr_of(int,n);
	int *prev = new_arr_of(int,n);
	int *next = new_arr_of(int,n);
	int next_v, v, i;
	int rows_to_process = n-1;
	double d;

	prev[0] = next[0] = 0;
	for (i=0; i<n;i++) {
		distance[i] = INFINITY;
	}
	v = 0;
	
	for ( v=0, rows_to_process = n-1; rows_to_process ;rows_to_process--) {
		@@<Find |next_v|, the nearest vertex to the cycle containing |v|@@>@@;
		v = next_v;
		@@<Insert |v| next to to |nearest_to[v]|@@>@@;
	}

	for (v=0,i=0; i<n ; i++ ) {
		tour[i] = v;
		v = next[v];
	}
	free_mem(distance);
	free_mem(nearest_to);
	free_mem(prev);
	free_mem(next);
}

@@
@@<Find |next_v|, the nearest vertex to the cycle containing |v|@@>=
{int i; double d = INFINITY;
distance[v] = -1;
for ( i=1;i<n;i++ ) {
	if ( distance[i] >= 0 ) {
		const double civ = cost(i,v);
		if ( civ < distance[i] ) {
			distance[i] = civ;
			nearest_to[i] = v;
		}
		if ( distance[i] < d ) {
			d = distance[i];
			next_v = i;
		}
	}
}
}

@@
@@<Insert |v| next to to |nearest_to[v]|@@>=
{ const int nv = nearest_to[v], pnv = prev[nv], nnv = next[nv];
	if ( cost(pnv,v) + cost(v,nv) - cost(pnv,nv) <
	    cost(nv,v) + cost(v,nnv) - cost(nv,nnv) ) {
		/* Insert before |nearest_to[v]|*/
		prev[v] = pnv;
		next[v] = nv;
		next[pnv] = prev[nv] = v;
	} else {
		/* Insert after |nearest_to[v]|*/
		prev[v] = nv;
		next[v] = nnv;
		next[nv] = prev[nnv] = v;
	}
}

@@ The arbitrary insertion heuristic originally appeared in 
D.~J.~Rosencrantz, R.~E.~Stearns, and P.~M.~Lewis~II, An analysis of several
heuristics for the traveling salesman problem.  {\it SIAM J. Comput.} {\bf 6},
563--581.

It works as follows:

Step 1. Start with a subgraph consisting of city $i$ only.

Step 2. Find city $k$ such that $c_{ik}$ is minimal and form the subtour $(i,k)$.

Step 3. (Selection) Given a subtour, arbitrarily select city $k$ not in the
subtour to enter the subtour.

Step 4. (Insertion) Find the edge $\{i,j\}$ in the subtour which minimizes
$c_{ik}+c_{kj} - c_{ij}$.  Insert $k$ between $i$ and $j$.

Step 5.  Go to Step 3 unless we have a Hamiltonian cycle.

@@<Subroutines@@>=
static void
arbitrary_insertion(int n, int *tour)
{
	int *available = new_arr_of(int,n);
	int *next = new_arr_of(int,n);
	int i, j, t, k, al, r;
	double d;


	if ( n < 2 ) { tour[0] = 0; return; }

	for ( i=0;i<n;i++ ) { available[i] = i; }
	
	d = cost(0,n-1);
	k = 0;
	for (i=1;i<n-1; i++) {
		const double cinm1 = cost(i,n-1);
		if ( cinm1 < d ) { d = cinm1; k = i; }
	}
	next[n-1] = k;
	next[k] = n-1;
	available[k] = n-2;
	al = n-2; /* available limit */

	gb_init_rand(42L);	/* Arbitrary constant */
	while ( al > 0 ) {
		@@<Arbitrarily select city $k$ not on the tour@@>@@;
		@@<Find the edge $\{i,j\}$ in the subtour minimizing $c_{ik}+c_{kj} - c_{ij}$@@>@@;
		@@<Insert $k$ between $i$ and $j$@@>@@;
	}
	@@<Unravel the linked lists into |tour|@@>@@;

	free_mem(available);
	free_mem(next);
}

@@ I use the Stanford GraphBase random number generator.
@@<Other includes@@>=
#include "gb_flip.h"

@@ I randomly pick a city from the remaining ones.
@@<Arbitrarily select city $k$ not on the tour@@>=
r = gb_unif_rand( al );
k = available[r];
available[r] = available[--al];

@@ We must take care to not go around forever.
@@<Find the edge $\{i,j\}$ in the subtour minimizing $c_{ik}+c_{kj} - c_{ij}$@@>=
{int best_i;
i = n-1; j = next[n-1];
d = cost(i,k)+cost(k,j)-cost(i,j);
best_i = i;
do {
	const double cost_here = cost(i,k)+cost(k,j)-cost(i,j);
	if ( cost_here < d ) { d = cost_here; best_i = i; }
	i = j; j = next[j];
} while ( i != n-1 );
i = best_i; j = next[i];
}

@@ @@<Insert $k$ between $i$ and $j$@@>=
next[k] = j;
next[i] = k;

@@ @@<Unravel the linked lists into |tour|@@>=
i = 0;
al = 0;
do {
	tour[al++] = i;
	i = next[i];
} while ( i!=0 );
assert( al == n );


@@ Putting it all together.  The |upper| routine tries all the strategies
out and places the best answer in the incumbent variables.

@@<Subroutines@@>=
static double
tour_len(const int n, const int *tour)
{
	double tot_len = 0.0;
	int i;
	for(i=0;i<n;i++) {
		tot_len += cost(tour[i],tour[(i+1)%n]);
	}
	return tot_len;
}

static int
not_tour(int n, int *tour, int *count)
{
	int i;
	for (i=0;i<n;i++) count[i]=0;
	for (i=0;i<n;i++) count[tour[i]]++;
	for (i=0;i<n;i++) 
		if ( count[i] != 1 ) {
			int j;
			for (j=0;j<n;j++) 
				printf( "    tour[%d]==%d count[%d]==%d\n",j,tour[j],j,count[j]);
			return 1;
		}
	return 0;
}

void
upper(const int n)
{
	int *best = new_arr_of(int,n);
	int *trial = new_arr_of(int,n);
	int *count = new_arr_of(int,n);
	double trial_len, best_len;
	int i;
	
	canonical( n, best );
	best_len = tour_len( n, best );
	incumbent_kind = CANONICAL;
	printf("#  Upper: canonical: %1.0f\n",best_len);
	show_tour("Canonical tour",n,best);
	fflush(stdout);
	errorif( not_tour(n,best,count), "  Upper: canonical didn't construct a tour!\n");

	random_walk( n, trial );
	trial_len = tour_len( n, trial );
	printf("#  Upper: random_walk: %1.0f\n",trial_len);
	show_tour("Random tour",n,trial);
	fflush(stdout);
	errorif( not_tour(n,trial,count), "  Upper: random_walk didn't construct a tour!\n");
	if ( trial_len < best_len ) {
		int *t = best;
		best = trial; trial = t;
		best_len = trial_len;
		incumbent_kind = RANDOM;
	}
	
	
	double_onetree( n, trial );
	trial_len = tour_len( n, trial );
	printf("#  Upper: double_onetree: %1.0f\n",trial_len);
	show_tour("Double 1-tree",n,trial);
	fflush(stdout);
	errorif( not_tour(n,trial,count), "  Upper: double_onetree didn't construct a tour!\n");
	if ( trial_len < best_len ) {
		int *t = best;
		best = trial; trial = t;
		best_len = trial_len;
		incumbent_kind = DOUBLE_ONETREE;
	}
	
	nearest_addition( n, trial );
	trial_len = tour_len( n, trial );
	printf("#  Upper: nearest_addition: %1.0f\n",trial_len);
	show_tour("Nearest Addition heuristic",n,trial);
	fflush(stdout);
	errorif( not_tour(n,trial,count), "  Upper: nearest_neighbour didn't construct a tour!\n");
	if ( trial_len < best_len ) {
		int *t = best;
		best = trial; trial = t;
		best_len = trial_len;
		incumbent_kind = NEAREST_NEIGHBOUR;
	}

	arbitrary_insertion( n, trial );
	trial_len = tour_len( n, trial );
	printf("#  Upper: arbitrary_insertion: %1.0f\n",trial_len);
	show_tour("Aribtrary Insertion heuristic",n,trial);
	fflush(stdout);
	errorif( not_tour(n,trial,count), "  Upper: arbitary_insertion didn't construct a tour!\n");
	if ( trial_len < best_len ) {
		int *t = best;
		best = trial; trial = t;
		best_len = trial_len;
		incumbent_kind = ARBITRARY_INSERTION;
	}

	incumbent_len = best_len;
	for (i=0;i<n;i++) {
		incumbent_edges[i].e.from = best[i];
		incumbent_edges[i].e.to   = best[(i+1)%n];
		incumbent_edges[i].from_next = incumbent_edges[i].to_next = NULL;	/* For now */
	}

	free_mem(best);
	free_mem(trial);
	free_mem(count);
}

@@
@@<Exported routines@@>=
void upper(const int n);
@


1.102
log
@Fixed to compile.
@
text
@d2 1
d5 2
a6 5
{\obeylines$Log:	upper.w,v $
Revision 1.101  96/07/29  16:20:15  neto
Added *\_rcs\_id.
Made sure RCS log is activated within this file.

d21 3
d27 1
a29 1
#include "upper.h"
a31 1
const char *upper_rcs_id="$Id: upper.w,v 1.101 96/07/29 16:20:15 neto Exp $";
a36 1
extern const char *upper_rcs_id;
d78 52
a144 1

a145 1

d149 1
a149 1
	length_t *distance = new_arr_of(length_t,n);
d155 1
a155 1
	length_t d;
d181 1
a181 1
{int i; length_t d = INFINITY;
d185 1
a185 1
		const length_t civ = cost(i,v);
d241 1
a241 1
	length_t d;
d251 1
a251 1
		const length_t cinm1 = cost(i,n-1);
d288 1
a288 1
	const length_t cost_here = cost(i,k)+cost(k,j)-cost(i,j);
d313 1
a313 1
static length_t
d316 1
a316 1
	length_t tot_len = 0;
d340 2
a341 2
length_t
upper(const int n, int *tour, int random_initial_tour)
d346 1
a346 1
	length_t trial_len, best_len;
d349 1
a349 2
	random_walk( n, best );
/*	|incumbent_kind = RANDOM;|*/
d351 3
a353 2
	printf("#  Upper: random_walk: "length_t_spec"\n",length_t_pcast(best_len));
/*	|show_tour("Random tour",n,trial);| */
d355 1
a355 1
	errorif( not_tour(n,best,count), "  Upper: random_walk didn't construct a tour!\n");
d357 39
a395 13
	if ( !random_initial_tour ) {
		canonical( n, trial );
		trial_len = tour_len( n, trial );
		printf("#  Upper: canonical: " length_t_spec"\n",length_t_pcast(trial_len));
	/*	|show_tour("Canonical tour",n,trial);| */
		fflush(stdout);
		errorif( not_tour(n,trial,count), "  Upper: canonical didn't construct a tour!\n");
		if ( trial_len < best_len ) {
			int *t = best;
			best = trial; trial = t;
			best_len = trial_len;
	/*|		incumbent_kind = CANONICAL; |*/
		}
d397 11
a407 42
		
		
	#if 0
		double_onetree( n, trial );
		trial_len = tour_len( n, trial );
		printf("#  Upper: double_onetree: "length_t_spec"\n",length_t_pcast(trial_len));
	/*|	show_tour("Double 1-tree",n,trial);| */
		fflush(stdout);
		errorif( not_tour(n,trial,count), "  Upper: double_onetree didn't construct a tour!\n");
		if ( trial_len < best_len ) {
			int *t = best;
			best = trial; trial = t;
			best_len = trial_len;
	/*|		incumbent_kind = DOUBLE_ONETREE;| */
		}
	#endif
		
		nearest_addition( n, trial );
		trial_len = tour_len( n, trial );
		printf("#  Upper: nearest_addition: "length_t_spec"\n",length_t_pcast(trial_len));
	/*|	show_tour("Nearest Addition heuristic",n,trial);| */
		fflush(stdout);
		errorif( not_tour(n,trial,count), "  Upper: nearest_neighbour didn't construct a tour!\n");
		if ( trial_len < best_len ) {
			int *t = best;
			best = trial; trial = t;
			best_len = trial_len;
	/*|		incumbent_kind = NEAREST_NEIGHBOUR;| */
		}

		arbitrary_insertion( n, trial );
		trial_len = tour_len( n, trial );
		printf("#  Upper: arbitrary_insertion: "length_t_spec"\n",length_t_pcast(trial_len));
	/*|	show_tour("Aribtrary Insertion heuristic",n,trial);| */
		fflush(stdout);
		errorif( not_tour(n,trial,count), "  Upper: arbitary_insertion didn't construct a tour!\n");
		if ( trial_len < best_len ) {
			int *t = best;
			best = trial; trial = t;
			best_len = trial_len;
	/*|		incumbent_kind = ARBITRARY_INSERTION;| */
		}
d410 1
a410 1
/*|	incumbent_len = best_len;| */
d412 3
a414 1
		tour[i] = best[i];
a419 1
	return best_len;
d424 1
a424 1
length_t upper(const int n, int *tour, int random_initial_tour);
@


1.101
log
@Added *\_rcs\_id.
Made sure RCS log is activated within this file.
@
text
@d4 5
a8 1
{\obeylines$Log$
a18 1
const char upper_rcs_id[]="$Id$";
d31 1
@


1.100
log
@This version works.  
Needs improvement:
	command-line switches
	faster tabu check
	allow Papadimitriou tabu rule
	faster preprocessing
	different candidate lists
@
text
@d1 6
d15 1
d33 1
@


1.4
log
@Fixed the prototypes.
@
text
@@


1.3
log
@Allow an option to specify only a random initial tour.
@
text
@d367 1
a367 1
length_t upper(const int n, int *tour);
@


1.2
log
@Initial implementation of LK.  This is buggy.
@
text
@d280 1
a280 1
upper(const int n, int *tour)
d288 2
a289 1
	canonical( n, best );
d291 1
a291 9
/*	|incumbent_kind = CANONICAL;|*/
	printf("#  Upper: canonical: " length_t_spec"\n",length_t_pcast(best_len));
/*	|show_tour("Canonical tour",n,best);| */
	fflush(stdout);
	errorif( not_tour(n,best,count), "  Upper: canonical didn't construct a tour!\n");

	random_walk( n, trial );
	trial_len = tour_len( n, trial );
	printf("#  Upper: random_walk: "length_t_spec"\n",length_t_pcast(trial_len));
d294 1
a294 36
	errorif( not_tour(n,trial,count), "  Upper: random_walk didn't construct a tour!\n");
	if ( trial_len < best_len ) {
		int *t = best;
		best = trial; trial = t;
		best_len = trial_len;
/*|		incumbent_kind = RANDOM; |*/
	}
	
	
#if 0
	double_onetree( n, trial );
	trial_len = tour_len( n, trial );
	printf("#  Upper: double_onetree: "length_t_spec"\n",length_t_pcast(trial_len));
/*|	show_tour("Double 1-tree",n,trial);| */
	fflush(stdout);
	errorif( not_tour(n,trial,count), "  Upper: double_onetree didn't construct a tour!\n");
	if ( trial_len < best_len ) {
		int *t = best;
		best = trial; trial = t;
		best_len = trial_len;
/*|		incumbent_kind = DOUBLE_ONETREE;| */
	}
#endif
	
	nearest_addition( n, trial );
	trial_len = tour_len( n, trial );
	printf("#  Upper: nearest_addition: "length_t_spec"\n",length_t_pcast(trial_len));
/*|	show_tour("Nearest Addition heuristic",n,trial);| */
	fflush(stdout);
	errorif( not_tour(n,trial,count), "  Upper: nearest_neighbour didn't construct a tour!\n");
	if ( trial_len < best_len ) {
		int *t = best;
		best = trial; trial = t;
		best_len = trial_len;
/*|		incumbent_kind = NEAREST_NEIGHBOUR;| */
	}
d296 56
a351 11
	arbitrary_insertion( n, trial );
	trial_len = tour_len( n, trial );
	printf("#  Upper: arbitrary_insertion: "length_t_spec"\n",length_t_pcast(trial_len));
/*|	show_tour("Aribtrary Insertion heuristic",n,trial);| */
	fflush(stdout);
	errorif( not_tour(n,trial,count), "  Upper: arbitary_insertion didn't construct a tour!\n");
	if ( trial_len < best_len ) {
		int *t = best;
		best = trial; trial = t;
		best_len = trial_len;
/*|		incumbent_kind = ARBITRARY_INSERTION;| */
@


1.1
log
@Initial revision
@
text
@@
